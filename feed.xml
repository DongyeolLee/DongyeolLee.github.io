<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dy:1992</title>
  
  <subtitle>Dy&#39;s 포크레인 삽질기</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="http://DongyeolLee.github.io/"/>
  <updated>2020-10-18T07:19:10.798Z</updated>
  <id>http://DongyeolLee.github.io/</id>
  
  <author>
    <name>Dy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DB - Data Modeling</title>
    <link href="http://DongyeolLee.github.io/2020/10/18/DB/Data-Modeling/"/>
    <id>http://DongyeolLee.github.io/2020/10/18/DB/Data-Modeling/</id>
    <published>2020-10-18T05:51:15.000Z</published>
    <updated>2020-10-18T07:19:10.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="들어가기"><a href="#들어가기" class="headerlink" title="들어가기"></a>들어가기</h1><p>사내에서 진행된 DB 관련 교육을 듣고 이를 정리하려한다.</p><p><strong>Why should we get data modeling training</strong></p><p>설계도 없이 커다란 건물을 짓는다고 생각해보자. 과연 가능한 일인가? 물론 작은 건물이거나 텐트 같은 경우는 설계도가 없더라도 설치가 가능할 수도 있다.</p><p>하지만 복잡하고 규모있는 건물일수록 설계도가 중요하다. 그렇지 않으면 부실 공사로 건물이 무너지는 것은 당연하다.</p><p>Data Modeling도 같은 이유다.</p><p>Database를 설계할때 그 기초가 되는 것은 Data 사이의 관계이다. 여러 Data의 관계가 복잡하지 않고 간단하다면 손 쉽게 설계도(Modeling)없이도 Database를 구축할 수 있다.</p><p>하지만 건물과 마찬가지로 복잡한 Data의 관계를 조금 더 정확하고 관리하기 편하게 구축 하기 위해서는 Data Modeling이 필요하다.</p><p>많은 서비스들이 Database에 의존적이라 할 수 있다. Database의 속도가 느려 bottleneck이 된다면 서비스들의 영향을 끼칠 수 있다.</p><h1 id="본론"><a href="#본론" class="headerlink" title="본론"></a>본론</h1><h2 id="데이터-모델이란"><a href="#데이터-모델이란" class="headerlink" title="데이터 모델이란"></a>데이터 모델이란</h2><p>데이터 모델이란 무엇인가? 이는 쉽게 설명해서 기업의 비지니스 룰에 대한 설계를 <strong><code>약속된 표기법으로 표현하는 과정(ERD)</code></strong>이라고 할 수 있다.</p><p><img src="/images/Database/erd.png" width="500"></p><p>만약 데이터 모델을 정의하지 않고 여러 사내 팀에서 회원 가입 테이블을 만든다고 상상해보자.</p><p>어떤 팀은 이메일과 이름만 필요할 것이고 또 다른 팀은 이름과 핸드폰 번호만 필요할 수도 있다.</p><p>이럴때마다 기준을 정해두지 않으면 중구 난방 비슷한 테이블을 만들 수 있다. </p><p><strong><code>데이터 모델은 데이터의 설계도이며 정규화, 반정규화, 테이블 통합, 테이블 분할 등 여러가지 고려 문제를 고려해 유연하게 설계한다.</code></strong></p><h2 id="데이터-모델의-구성"><a href="#데이터-모델의-구성" class="headerlink" title="데이터 모델의 구성"></a>데이터 모델의 구성</h2><p>데이터 표기법에는 바커 표기법과 I/E 표기법이 존재한다. 현재 사내에서는 I/E 표기법을 중심으로 사용한다. 또 I/E를 지원하는 툴들이 더 많이 존재한다.</p><p><img src="/images/Database/ie.jpg" width="500"></p><p>I/E는 쉽게 Entity, Relationship, cardinality 이 3가지로 구성된다.</p><p>Entity는 집합을, relationship은 집합간에 관계, cardinality 속성을 의미한다.</p><p>좀 더 자세히 말하자면 Entity는 반드시 해당 업무에서 필요하고 관리하고자 하는 정보이자 유일한 식별자(PK)에 의해 식별이 가능한 정보이다.</p><p>Attribute는 엔티티가 갖는 속성을 의미하며 반드시 단일 값이 필요하다. 중복되는 값이 있다면 이는 정규화가 필요하다는 의미일 수 있다.</p><p><img src="/images/Database/emp.png" width="300"></p><p>Relationship은 entity들 간에 존재하는 업무 규정(관계)이며 일반적으로 일반적으로 RDBMS에서는 FK로 구현한다.</p><p><img src="/images/Database/rnc.png" width="300"></p><h2 id="데이터-모델링-절차"><a href="#데이터-모델링-절차" class="headerlink" title="데이터 모델링 절차"></a>데이터 모델링 절차</h2><p>많이 데이터 모델링은 배울 것은 많이 없다. 경험이 중요하다.</p><p>데이터 모델링을 위한 표현은 단순하다. 하지만 직접 해보려고 하면 막막할 따름이다.</p><p>데이터 모델링에는 정답은 없다. 그러나 설계한 데이터 모델의 각 요소들이 시스템에 어떤 영향을 미칠지 데이터가 향후에 유용하게 사용될 수 있는지 검토하여 최적의 데이터 모델을 설계해야 한다.</p><p>절차 또한 따로 존재하지 않지만 주로 step by step으로 설계한다.</p><p>초반에는 핵심만, 그리고 점점 확장하는 방식으로 처음부터 예외처리 생각하지 않는다. 이는 문제를 더 복잡하게 만들 수 있기 때문이다.</p><ul><li>Conceptual - 가볍게 entity를 스케치(핵심 엔티티 + 관계), 전체적인 그림을 그리는 것</li><li>Logical - Conceptual을 약속된 표기법으로 그리면서 attribute 추가 및 필요한 entity 추가</li><li>Physical - 데이터 베이스 종류에 맞게 도출</li></ul><h2 id="정규화와-성능"><a href="#정규화와-성능" class="headerlink" title="정규화와 성능"></a>정규화와 성능</h2><p>데이터의 일관성 보장을 위한 데이터 중복을 최소화하는 장치</p><p><img src="/images/Database/nomalization.png" width="300"></p><h2 id="비정규화와-성능"><a href="#비정규화와-성능" class="headerlink" title="비정규화와 성능"></a>비정규화와 성능</h2><p>정규화된 entity, attribute, relationship에 대해 시스템 성능, 개발 &amp; 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 모델링 기법이다.</p><p><strong>정규화를 진행하다보니 오히려 빈번한 join과 같은 역효과가 발생할수도 있다</strong>. 이럴때 다시 반정규화를 진행한다.</p><h1 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h1><p>앞으로 교육이 몇회가 더 남아있지만 계속 정리를 해볼까한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;들어가기&quot;&gt;&lt;a href=&quot;#들어가기&quot; class=&quot;headerlink&quot; title=&quot;들어가기&quot;&gt;&lt;/a&gt;들어가기&lt;/h1&gt;&lt;p&gt;사내에서 진행된 DB 관련 교육을 듣고 이를 정리하려한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Why should we 
      
    
    </summary>
    
      <category term="programming" scheme="http://DongyeolLee.github.io/categories/programming/"/>
    
      <category term="database" scheme="http://DongyeolLee.github.io/categories/programming/database/"/>
    
    
      <category term="db" scheme="http://DongyeolLee.github.io/tags/db/"/>
    
      <category term="modeling" scheme="http://DongyeolLee.github.io/tags/modeling/"/>
    
      <category term="data" scheme="http://DongyeolLee.github.io/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>What is Gradle ?</title>
    <link href="http://DongyeolLee.github.io/2019/12/14/Gradle/gradle/"/>
    <id>http://DongyeolLee.github.io/2019/12/14/Gradle/gradle/</id>
    <published>2019-12-14T04:41:50.000Z</published>
    <updated>2019-12-15T04:22:35.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gradle-이란"><a href="#Gradle-이란" class="headerlink" title="Gradle 이란"></a>Gradle 이란</h1><p>Gradle은 차세대 빌드 tool로 주목받는 오픈 소스 제품이다. 아니 이미 많은 프로젝트에서 사용하고 있다해도 과언이 아니다.</p><p>2007년부터 개발이 시작된 Gradle을 스프링 관련 제품 개발이나 기업 솔루션을 중심으로 도입되는 사례가 점점 늘고 있다.</p><p>Gradle이 주목받는 이유는 기존 빌드 툴보다 우수한 점이 많기 때문이다. 가장 큰 특징은 <strong>빌드 스크립트를 간단하게 작성할 수 있다는 점</strong>이다. 또한, 배우기도 쉽고 읽기도 쉬워 처리 내용을 금방 이해할 수 있다.</p><p>또 다른 특징으로 <strong>Ant나 Maven 같은 기존 빌드 툴의 기능과 시스템도 활용할 수 있다는 점</strong>을 들 수 있다. Gradle은 Ant나 Maven의 build script나 Task를 이용할 수 있어서 과거에 축적한 자원을 활용할 수 있다.</p><p>즉, 자원을 최대한 활용하면서 단계적으로 Gradle로 이전할 수 있다는 얘기다.</p><h2 id="빌드-툴이란"><a href="#빌드-툴이란" class="headerlink" title="빌드 툴이란"></a>빌드 툴이란</h2><p>소프트웨어 개발에서 대부분의 작업은 정형화되어 있다. 자바 어플리케이션 개발을 예로 들면 다음과 같은 일련의 작업이 필요하다.</p><ul><li>소스코드(.java)를 컴파일해서 클래스 파일(.class)을 생성</li><li>코딩 규약에 맞게 작성했는지 확인</li><li>코드를 정적으로 해석</li><li>테스트하고 테스트 결과나 커버리지 측정 결과를 리포트로 출력</li><li>Javadoc과 같은 문서를 작성</li><li>클래스 파일과 리소스 파일을 패키징해서 압축 파일을 만듬(.jar or .war)</li><li>압축 파일을 BETA 환경이나 STAGING 환경에 배포</li><li>압축 파일을 저장소에 등록</li></ul><p><strong>빌드 툴이란 이런 정형화된 작업을 자동화하여 배포 과정에서 실수를 줄이고 보다 빠른 배포</strong>를 할 수 있게 하는데 그 뜻을 둔다.</p><p>보통 자바로 웹 어플리케이션을 개발한다면 이클립스를 많이 사용할 것이다. 이클립스의 마법사 도구로 새 프로젝트를 만들면 이클립스에서의 빌드를 전제로 한 프로젝트가 생성된다.</p><p>이 말은 이클립스에서만 빌드가 가능하다는 얘기다. 이클립스가 없으면 코드를 배포 가능한 어플리케이션 형태로 만들 수 없다는 것이다.</p><p>이런 개발 스타일은 개인 또는 소규모 프로젝트에서는 문제가 없지만 어느 정도 규모가 있는 팀이라면 여러가지 문제가 발생할 수 있다.</p><h1 id="왜-Gradle이어야-하나"><a href="#왜-Gradle이어야-하나" class="headerlink" title="왜 Gradle이어야 하나"></a>왜 Gradle이어야 하나</h1><h2 id="빌드-스크립트의-생산성"><a href="#빌드-스크립트의-생산성" class="headerlink" title="빌드 스크립트의 생산성"></a>빌드 스크립트의 생산성</h2><p>Gradle은 Maven과 마찬가지로 <strong>규칙 기반 빌드 접근법</strong>을 사용한다. 즉, 규칙을 따라 프로젝트 구조를 만들면 빌드 스크립트 내용을 크게 줄일 수 있다. 또한, 규칙을 벗어난다 해도 필요에 따라 스크립트를 추가할 수 있어서 유연하게 대응 가능하다.</p><p>더욱이 Gradle은 JVM 기반의 Groovy로 구축되어 있어 크로스 플랫폼에 유리하고 Groovy의 장점을 그대로 활용할 수 있다. 뿐만 아니라 맵 리터럴, 클로저 등 자바에는 없는 편리한 기능이 있어서 빌드 스크립트를 간단하게 작성할 수 있다.</p><h2 id="빌드-순서-제어가-쉽다"><a href="#빌드-순서-제어가-쉽다" class="headerlink" title="빌드 순서 제어가 쉽다"></a>빌드 순서 제어가 쉽다</h2><p>Maven의 빌드 순서는 추가나 변경이 불가능해서 Maven에 빌드 순서에 맞지 않는 프로젝트에는 적용할 수 없다. 빌드 스크립트 단순화 전략에 따라 불필요한 기능을 제거했기 때문이다.</p><p>Gradle은 Maven처럼 빌드 순서가 정해져 있지 않다. 하지만 이는 빌드 스크립트를 복잡하게 만들어 기존 Ant의 문제점과 같다. Gradle은 이런 문제점을 플러그인을 사용해서 빌드 스크립트를 간단하게 유지한다.</p><h2 id="멀티-프로젝트에-대응한다"><a href="#멀티-프로젝트에-대응한다" class="headerlink" title="멀티 프로젝트에 대응한다"></a>멀티 프로젝트에 대응한다</h2><p>프로젝트 규모가 어느 정도 커져서 여러 개발 팀이 작업을 분담해야 할 상황이 되면 보통 한 프로젝트를 서브 프로젝트로 나눈다. 하지만 이때 문제가 되는 것은 서브 프로젝트 간 의존관계나 서브 프로젝트들의 공통 빌드 설정을 어떻게 효율적으로 관리하느냐다.</p><p>Gradle은 다음과 같은 기능을 통해서 서브 프로젝트로 구성된 전체 프로젝트의 빌드를 지원한다.</p><ul><li>멀티 프로젝트에 있는 서브 프로젝트를 정의하는 기능</li><li>서브 프로젝트에 공통 빌드 스크립트를 집약하는 기능</li><li>서브 프로젝트 간 의존관계를 정의하는 기능</li><li>의존관계를 고려해서 변경 내역만 빌드하는 기능</li></ul><h2 id="컴포넌트로-만들기-쉽다"><a href="#컴포넌트로-만들기-쉽다" class="headerlink" title="컴포넌트로 만들기 쉽다"></a>컴포넌트로 만들기 쉽다</h2><p>빌드 스크립트로 프로그램의 일종이므로 ‘공통 기능을 컴포넌트로 만들어서 재사용하고 싶다’는 요구가 있을 수 있다. Gradle은 쉽게 사용할 수 있는 것부터 컴포넌트로 제대로 만들어서 공개 저장소에 등록할 수준의 것까지 유연하게 대응할 수 있는 컴포넌트 구조를 제공한다.</p><ul><li>빌드 스크립트에서 메서드나 클래스 추출</li><li>빌드 스크립트의 분할과 재사용</li><li>프로젝트에서만 사용할 수 있는 확장 모듈</li><li>여러 프로젝트에서 범용적으로 재사용할 수 있는 라이브러리</li></ul><h2 id="별도로-설치할-필요가-없다"><a href="#별도로-설치할-필요가-없다" class="headerlink" title="별도로 설치할 필요가 없다"></a>별도로 설치할 필요가 없다</h2><p>Ant나 Maven을 사용하려면 사용자 환경에 Ant나 Maven을 설치해야 하는 불편함이 있다. 이것은 사용자에게 부담을 줄 수도 있고, 관리 측면에서도 바람직하지 못하다. 예를 들어 사용자가 다른 버전의 Maven을 설치하면 A에서는 빌드가 성공하지만 B에서는 실패하는 문제가 생길 수도 있다.</p><p>이와 같은 문제에 대처하기 위해 Gradle은 래퍼라는 구조를 제공한다. 래퍼는 프로젝트 안에 그레이들의 부트스트랩을 심어서 지정한 버전의 Gradle을 자동으로 설치해주는 기능이다.</p><h1 id="다른-빌드-툴과의-비교"><a href="#다른-빌드-툴과의-비교" class="headerlink" title="다른 빌드 툴과의 비교"></a>다른 빌드 툴과의 비교</h1><h2 id="Make-vs-Gradle"><a href="#Make-vs-Gradle" class="headerlink" title="Make vs Gradle"></a>Make vs Gradle</h2><p>C언어를 중심으로 한 네이티브용 소프트웨어 개발 현장에서 Make는 아직도 많이 사용된다.</p><p>Make의 특징은 Makefile이라는 빌드 스크립트를 작성해서 결과물을 생성하기 위한 작업과 각 작업 간 관련성을 정의할 수 있다는 것이다. 이 방식에는 다음과 같은 장점이 있다.</p><ul><li>빌드 순서를 Shell 스크립트로 처음부터 작성할 필요가 없다.</li><li>갱신된 C 코드와 그에 의존하는 코드만을 선택적으로 빌드하는 방식이 가능하다.</li></ul><p>Make는 비교적 단순해서 결과물 생성 명령 또는 Shell 스크립트만 정의해도 빌드가 가능하다. 하지만 플랫폼 의존성이 커서 크로스 플랫폼 대응이 어렵다. 그리고 Make에는 의존관계 해결 기능이 없다.</p><p>Gradle에는 Make의 이러한 ‘스크립트 기반 유연성’이라는 장점을 취하면서 크로스 플랫폼 대응, 의존관계 해결, 규칙 기반 빌드와 같은 최신 빌드 툴이 요구하는 기능들이 충실하게 반영되어 있다.</p><h2 id="Ant-vs-Gradle"><a href="#Ant-vs-Gradle" class="headerlink" title="Ant vs Gradle"></a>Ant vs Gradle</h2><p>Make의 문제였던 크로스 플랫폼 대응을 해결하기 위해 플랫폼에 의존하지 않는 자바와 XML을 기반으로 구축했다. Ant의 기능은 Make보다 많지만, 빌드 툴로서는 매우 단순하다. 또한, 확장이 쉬워서 많은 확장 Task들이 만들어졌고, 이로 인해 에코시스템이 강화됐다.</p><p>하지만 Ant는 다음과 같은 문제가 있다.</p><ul><li>기본 기능이 단순해서 복잡한 것을 만들려면 빌드 스크립트가 길어진다.</li><li>디렉터리 구조와 관련된 표준 규칙이 없고 프로젝트 단위로 다른 빌드 스크립트를 사용해야하므로 재사용이 어렵다.</li><li>라이브러리 의존관계 관리 기능이 없어서 의존 라이브러리를 직접 받아야 한다.</li></ul><p>Ant의 단순함과 크로스 플랫폼 특성을 도입한 Gradle의 특징은 다음과 같다.</p><ul><li>Groovy 기반의 DSL을 도입해서 빌드 스크립트를 사용한 유연한 처리가 가능하다.</li><li>의존관계 해결이나 규칙 기반 빌드 기능을 도입해서 사용하기 쉽다.</li></ul><h2 id="Maven-vs-Gradle"><a href="#Maven-vs-Gradle" class="headerlink" title="Maven vs Gradle"></a>Maven vs Gradle</h2><p>Maven이 도입한 규칙 기반 빌드 접근법은 프로젝트 종류별로 디렉터리 구조와 빌드 순서를 표준화한다. 이 표준 규칙을 따르면 빌드 내용을 상세하게 지시하지 않아도 빌드가 된다. 즉, 빌드 스크립트를 간략하게 하고 프로젝트의 재사용성을 높이는데 크게 공헌했다.</p><p>반면 다음과 같은 단점이 있다.</p><ul><li>제대로 사용하려면 복잡한 Maven 규칙을 이해해야 하므로 진입 장벽이 높다.</li><li>규칙에 맞지 않는 프로젝트에서는 사용 난이도가 높아진다.</li></ul><p>원칙적으로 Maven은 스크립트에 로직을 직접 작성할 수 없다. 이 때문에 기존 플러그인이 제공하지 않는 기능을 구현하려면 플러그인을 직접 만들어야 한다. 플러그인을 직접 개발하기란 상당히 어려울 것이다.</p><p>한편 Gradle은 Groovy 기반이므로 다음과 같이 간단히 구현할 수 있다.</p><ul><li>빌드 스크립트에 처리를 직접 작성한다.</li><li>빌드 스크립트에서 자바 클래스를 직접 이용한다.</li></ul><p>Gradle은 Maven처럼 규칙 기반 빌드 및 의존관계 관리 기능을 제공하면서 Maven보다 유연하게 기능을 변경하거나 확장할 수 있는 빌드 툴이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Gradle-이란&quot;&gt;&lt;a href=&quot;#Gradle-이란&quot; class=&quot;headerlink&quot; title=&quot;Gradle 이란&quot;&gt;&lt;/a&gt;Gradle 이란&lt;/h1&gt;&lt;p&gt;Gradle은 차세대 빌드 tool로 주목받는 오픈 소스 제품이다. 아니 이
      
    
    </summary>
    
      <category term="programming" scheme="http://DongyeolLee.github.io/categories/programming/"/>
    
      <category term="gradle" scheme="http://DongyeolLee.github.io/categories/programming/gradle/"/>
    
    
      <category term="gradle" scheme="http://DongyeolLee.github.io/tags/gradle/"/>
    
      <category term="build" scheme="http://DongyeolLee.github.io/tags/build/"/>
    
  </entry>
  
  <entry>
    <title>2018년도 LINE(라인) 채용 - 서류부터 최종면접까지 후기</title>
    <link href="http://DongyeolLee.github.io/2019/08/15/Review/line/"/>
    <id>http://DongyeolLee.github.io/2019/08/15/Review/line/</id>
    <published>2019-08-15T06:32:24.000Z</published>
    <updated>2019-08-15T08:42:11.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="들어가기"><a href="#들어가기" class="headerlink" title="들어가기"></a>들어가기</h1><p>지난 <strong><em><a href="https://dongyeollee.github.io/2019/05/23/Review/nhn/">NHN(NHN 엔터테인먼트)</a></em></strong>에 이어 라인에 지원하면서 간략하게 전형 및 느낌점을 정리해본다.</p><h1 id="서류-평가"><a href="#서류-평가" class="headerlink" title="서류 평가"></a>서류 평가</h1><p>라인 역시 IT 회사답게 어마 무시한 내용을 적는 자기소개서는 아니었다. 단지 어떤 활동을 했는지, 프로젝트 진행 여부를 묻는 듯한 질문이 많았다.</p><p>문항은 다음과 같았다.</p><ul><li>자신을 자유롭게 소개해 주세요.(제한 없음)</li><li>학교 수업이나 대외활동 등을 통해 경험한 프로젝트를 적어주세요. 프로젝트에서 맡았던 역할과 활용한 기술 및 개발 방식, 진행하면서 겪었던 어려움이나 이를 극복한 방법 등도 함께 설명해주세요.(제한 없음)</li><li>LINE에서 왜 자신을 채용해야 하는지, 자신의 경쟁력에 대해 구체적으로 적어주세요.(제한 없음)</li></ul><p>당시 개발 직군은 Server, Client, Game, Security로 지원이 가능했다.</p><p>당시 제일 어려웠던 문항이 개인적으로 1번 문항과 3번 문항이었다. 어떻게 작성할 수 있을까 고민이 많았다.</p><p>자기소개서 문항 1번에는 학부 시절 공부했던 내용과 ‘내가 왜 개발 분야에 흥미를 느끼게 됐는지’를 주로 피력했다.</p><p>그리고 3번 문항에는 입사 후 가질 마음가짐과 나의 장점을 주로 쓰는 것으로 마무리했다.</p><p>참고로 프로젝트를 적는 문항에는 내가 어떤 프로젝트를 했는지는 많이 작성하지 않았다.</p><p>프로젝트 개요는 최대한 단순하게 설명했다. 그보다 어떤 라이브러리를 썼고, 왜 그 라이브러리를 사용했는지, 또 어디서 많은 시간을 들여 개발했는지를 위주로 썼다.</p><h1 id="온라인-필기-시험"><a href="#온라인-필기-시험" class="headerlink" title="온라인 필기 시험"></a>온라인 필기 시험</h1><p><img src="/images/Review/line_online.png" width="600"></p><p>시험은 토요일 오전 Goorm으로 테스트를 진행했다. 라인 온라인 시험은 알고리즘 + 전공 기반 문제였다</p><p>알고리즘 4~5문제 전공 필기가 20문제 내외였다. 전공 필기 문제는 0,X 문항과 모두 고르는 객관식이 섞여 있는 문제였고 알고리즘 역시 구현에서부터 탐색까지 다양하게 나왔다.</p><p>10시에 딱 맞춰 시험이 시작됐다. 근데 웃긴 게 Goorm으로 알고리즘 시험을 보던 중, 사이트가 폭발했다. 그래서 시험 20분? 만에 온라인 알고리즘 시험을 취소한다는 이메일을 받았다.</p><p><img src="/images/Review/line_alert.png" width="600"></p><p>온라인 필기시험은 전공 점수로만 평가하고 알고리즘은 추후 오프라인 시험에서 다시 진행한다고 공지했다. 당시 사이트 문제로 알고리즘 시험을 진행할 수 없다고 했다.</p><p>이후 다시 시간에 맞춰 전공 시험을 봤는데 이 역시 상당히 어려웠다. 근데 라인은 찍으면 감점된다는 이야기가 있어 찍지도 못하고 울며 겨자 먹기로 아는 것만 열심히 풀었다. 워낙 어려워서 커트 라인이 어느 정도에서 형성될지도 감이 안 왔다.</p><p>정말 학부 시절 배운 모든 것을 물어보는 듯한 느낌이 강했다. 주로 네트워크, DB, OS, 컴퓨터 구조가 대부분이라 그 위주로 준비했으나 모르는 문제도 많았다.</p><p>전공 시험도 어려워 ‘망했다’라는 생각이 지배적이었다. 그냥 여기서 라인은 보내줘야겠다고 생각했다.</p><h1 id="오프라인-필기-시험"><a href="#오프라인-필기-시험" class="headerlink" title="오프라인 필기 시험"></a>오프라인 필기 시험</h1><p><img src="/images/Review/line_offline.png" width="400"></p><p>합격 메일을 받고 많이 당황했다. 메일이 잘 못 왔다는 생각까지 했다. 내가 왜 붙었지 의아했지만, 기분은 좋았다. 근데 막상 다시 볼 시험을 생각하니 걱정이 이만저만 아니었다.</p><p>2주 정도 여유가 있어 이전에 준비했던 것처럼 주로 OS, 알고리즘, 컴퓨터 구조, 네트워크, DB 등을 공부하며 오프라인 시험을 준비했다.</p><p>시험은 역삼역 근처에 있는 멀티캠퍼스에서 진행됐다. 내가 도착했을 당시 나 말고 응시자가 상당히 많아 어차피 떨어질 거 편하게 보자는 생각을 가졌다.</p><p>먼저 저번에 취소된 알고리즘 시험부터 2시간 가량 봤던 거로 기억한다. 문제는 4문제였고 배점이 다 달랐던 거로 기억한다.</p><p>당연히 온라인으로 봤던 문제와는 다른 문제들이 출제됐고 유형은 약간 비슷했다.</p><p>이어서 1시간 정도 전공시험을 쳤다. 컴퓨터로 작성하는 시험이었고 문제도 10문제 정도였다.</p><p>여기서 살짝 당황한 게 전공 문제가 아닌 약간 실제 프로젝트를 진행하면서 겪을 수 있는 문제? 를 위주로 나왔던 것 같다.</p><p>JAVA 관련 깊은 질문, 남이 작성한 코드를 보고 빈칸 채워 넣어 프로그램 작동시키기 같은 문제가 많았다.</p><p>당연히 모든 문제가 서술형이었고 모르면 찍지도 못하는 문제들이었다. </p><p>시험을 끝내고 나오면서 같이 본 친구들과 시험에 관해 이야기했다.</p><p>대체로 알고리즘은 비슷한 수준으로 풀었던 것 같다. 1 ~ 2.5 문제?? 정도가 우리들의 평균이었다. 근데 배점이 다 달라서 예상할 수가 없었다.</p><p>전공 시험은 전혀 내가 어느 정도 인지 감도 오지 않았지만 그래도 모르는 문제도 최대한 주워들은 지식으로 작성하려고 노력했다.</p><p>그래도 친구들보다 전공 시험은 뭔가 잘 본 듯한 느낌이었지만 안심할 수 없었다.</p><h1 id="1차-면접"><a href="#1차-면접" class="headerlink" title="1차 면접"></a>1차 면접</h1><p><img src="/images/Review/line_1.png" width="400"></p><p>다행히 합격 통보를 받을 수 있었다. 서술형 같은 경우는 어떻게 채점을 다 했는지 모르겠지만 합격해서 다행이었다.</p><p>라인 1차 면접에 관해서는 아는 정보가 많이 없어 어떻게 준비를 해야 할지 걱정이 앞섰다.</p><p>일단 자소서 기반으로 면접을 준비하되, 기본적인 전공 질문을 받을 수 있기에 전공 공부도 같이 진행하기로 했다.</p><p>1차 면접은 라인 판교 오피스에서 본다고 안내 메일에 적혀있었다. 면접 시간보다 30분 먼저 도착해 대기실에 앉아 있으면서 긴장하지 않으려 노력했다.</p><p>면접은 명시된 대로 딱 50분 진행됐다. 뭔가 폭풍이 지나간 느낌이었다.</p><p>자소서에 적은 프로젝트를 기반으로 질문을 많이 받았다. 왜 이게 어려웠는지, 문제 해결은 어떻게 했는지, 그게 최선책이었는지, 지금 생각해볼 때의 다른 방법은 어떤 게 있을지 프로젝트 관련해서는 대부분 저런 질문이었다.</p><p>또 프로젝트 관련해서 응용 질문도 많았다. 제약 사항을 주고 이럴 경우 어떻게 해결할 수 있는지 물어봤다. 문제 해결력을 보려고 하는 건가? 정답인지는 모르겠지만 내가 생각하는 방안을 제시하면서 답변했다.</p><p>물론 중간중간 모르는 부분이 상당히 많았다. 근데 틀린 대답을 하는 것보다는 모르는 건 진짜 모르겠다고 답했다.</p><p>뭔가 깔끔하지는 않지만, 엄청나게 잘 본 느낌도 아닌 그런 면접이었다.</p><h1 id="2차-면접"><a href="#2차-면접" class="headerlink" title="2차 면접"></a>2차 면접</h1><p><img src="/images/Review/line_2.png" width="400"></p><p>드디어 마지막 관문까지 왔다.</p><p>1차 면접을 준비했던 것처럼 2차 면접을 준비했다. 더 깊이 있게 공부하기보다는 1차 면접에서 답 못했던 내용을 정리해 준비했다.</p><p>2차 면접은 라인 서현 오피스에서 봤다. 집에서 서현까지 상당히 멀었지만 그래도 면접이 오후 4시정도여서 다행이었다.</p><p>그리고 기억하기로는 1차 면접 합격한 뒤 지원했던 분야인 Server에서 어디로 배치받고 싶은지 설문도 했다.</p><p>2차 면접 역시 50분 정도 이어졌고 1차와 비슷한 느낌이었다. 근데 뭔가 더 응용적인 질문도 많았다. 또 제약 상황을 많이 만들어 문제 해결력을 더 보는 듯한 느낌이었다.</p><p>1차 면접에서 답 못했던 부분을 다시 질문하고 나의 생각을 물어보기도 했다. 찾아보고 가길 잘했다.</p><p>근데 2차 면접의 전체적인 느낌은 너무 부정적이었다. 1차 면접보다 모르겠다고 답한 부분이 상당히 많았고 특히 전공 관련해서 깊게 물어볼 때 모르겠다고 답한 게 많아 아쉬웠다.</p><p>가장 당황했던 부분은 내가 사용한 언어에 있어 구동 방식에 문제점이 있었는데 그게 왜 문제일 것 같냐는 질문이었다. 너무 당황했다.</p><p>내가 대략 설명하고 잘 모르겠다고 하자 면접관이 그럼 우리 같이 추측해보자고 하면서 노트를 들이밀고 그림을 그리면서 설명해보라고 했다.</p><p>그냥 아는 부분만 대충 설명했다. 면접관 역시 뜨뜻미지근한 표정으로 알겠다고 한 뒤 넘어갔다.</p><p>라인은 면접이 매우 어려웠다. 다른 기업 면접보다 확실히 더 어렵게 느껴졌다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;들어가기&quot;&gt;&lt;a href=&quot;#들어가기&quot; class=&quot;headerlink&quot; title=&quot;들어가기&quot;&gt;&lt;/a&gt;들어가기&lt;/h1&gt;&lt;p&gt;지난 &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://dongyeollee.github.io/2019/05/
      
    
    </summary>
    
      <category term="review" scheme="http://DongyeolLee.github.io/categories/review/"/>
    
      <category term="job" scheme="http://DongyeolLee.github.io/categories/review/job/"/>
    
    
      <category term="review" scheme="http://DongyeolLee.github.io/tags/review/"/>
    
      <category term="recruiting" scheme="http://DongyeolLee.github.io/tags/recruiting/"/>
    
      <category term="job" scheme="http://DongyeolLee.github.io/tags/job/"/>
    
  </entry>
  
  <entry>
    <title>2018년도 NHN 채용 - 서류부터 최종면접까지 후기</title>
    <link href="http://DongyeolLee.github.io/2019/05/23/Review/nhn/"/>
    <id>http://DongyeolLee.github.io/2019/05/23/Review/nhn/</id>
    <published>2019-05-23T12:44:48.000Z</published>
    <updated>2019-09-20T04:09:17.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="들어가기"><a href="#들어가기" class="headerlink" title="들어가기"></a>들어가기</h1><p>지난 번 <strong><em><a href="https://dongyeollee.github.io/2019/05/21/Review/11st/">11번가 후기</a></em></strong>에 이어서 이번에는 NHN(NHN 엔터테인먼트)의 후기를 생각나는대로 써보려한다.</p><h1 id="서류-평가"><a href="#서류-평가" class="headerlink" title="서류 평가"></a>서류 평가</h1><p>NHN은 서류 평가가 그렇게 어렵지 않다고 어디서 주워 들은 것 같다. 실제로 주변 많은 사람들이 서류를 합격했다. 문항 역시 2개로 심플했다.</p><ul><li>재학 중 가장 자신 있는 전공과목을 적고(최대 3가지), 그 이유를 설명해주세요.(제한 없음)</li><li>가장 자신있는 프로그래밍 언어를 사용하여 성취한 대표적인 프로젝트 또는 개발산출물 한 가지를 설명해주세요. 그리고 개발과정에서 가장 중요하게 생각한 것은 무엇인지 설명해주세요.(제한 없음)</li></ul><p>정말 부담없이 자기소개서를 작성했던 걸로 기억한다. SW 개발 직군에 지원하면서 이전 자소서와 비슷한 문항이였기에 작성하는데는 크게 어려움이 없었다. 그리고 글자수 역시 그렇게 많이 채우지는 않고 800자, 1300자 정도 작성 후 제출했다.</p><h1 id="코딩-테스트"><a href="#코딩-테스트" class="headerlink" title="코딩 테스트"></a>코딩 테스트</h1><p><img src="/images/Review/nhn_1.png" width="500"></p><p>누구나 걱정하는 온라인 코딩 테스트!! 후기도 많이 없고 자료도 없어서 다들 걱정하는 것 같았다. 시험 당시 문제는 4~5문제 였던 걸로 기억한다.</p><p>난이도 역시 뒤로 갈수록 까다롭고 오래 걸리는 문제들이 나왔다. 1번과 2번 문제는 비교적 쉬웠던 거로 기억한다. 구조체 정렬과 배열을 이용하는 문제 정도??</p><p>3번은 구현하기 귀찮으면서 예외처리가 많았던 문제로 기억하며 완탐도 1문제 나왔다.</p><p>평소 알고리즘을 준비했다면 무난하게 4문제 정도는 풀었지 않았나 싶다. 근데 난 3문제 풀었나?? 시간도 3시간?? 정도 진행했다. </p><h1 id="오프라인-필기-시험"><a href="#오프라인-필기-시험" class="headerlink" title="오프라인 필기 시험"></a>오프라인 필기 시험</h1><p><img src="/images/Review/nhn_2.png" width="500"></p><p>NHN 오프라인 필기시험이 많이 어렵다는 후기를 보았기에 나름대로 열심히 준비했다. 운영체제, 네트워크, DB, 자료구조를 중점으로 공부했다. 또 실무적인 것보다는 전공에 관해서 많이 출제된다고 예고를 했기에 그 부분을 중점적으로 봤다.</p><p>판교역에 위치한 경기창조혁신센터?? 에서 시험을 봤다. 총 응시자는 약 900명 정도 됐다. 이 사람들을 뚫고 내가 면접을 갈 수 있을까 살짝 겁도 났지만 그래도 시험 보는 데 집중했다. 정말 좁은 책상에 앉아서 문제를 풀었고 2시간 정도 진행했다.</p><p>문제는 객관식 + 주관식으로 나왔으며 정말 대학 시험처럼 나왔다. 조금 어려운 용어나 내용 같은 것은 먼저 예시를 주고 풀게 했으며 영어 레퍼런스를 읽고 문제를 해결하는 유형도 있었다. ‘와 엄청 어렵다.’ 이 정도 수준은 아니었으나 헷갈리고 정확하게 모르겠는 문제투성이였다.</p><p>객관식에서 주관식 순으로 문제를 풀었고 객관식 약 19문제 중 5문제 정도 찍었던 것 같다. 주관식도 약 소 문제 포함 20문제 정도였는데 약 60% 정도 풀고 나머지는 그냥 느낌에 맡겼다. 시간이 부족하진 않았지만 그렇다고 남지도 않았다.</p><p>시험이 끝나고 같이 간 친구들이랑 서로 적은 답을 공유하고 설명하면서 갔는데 답이 다 달라서 조금 많이 불안했다. </p><h1 id="1차-면접"><a href="#1차-면접" class="headerlink" title="1차 면접"></a>1차 면접</h1><p><img src="/images/Review/nhn_3.png" width="500"></p><p>친구 8명이 같이 필기시험을 봤는데 나만 살아남았다. 뭔가 뿌듯하기도 했는데 1차 면접에서 다시 코딩 테스트를 본다고 해서 살짝 걱정됐다. 1차 면접은 NHN 사옥에서 진행됐고 여기는 복장 제한이 없었다.</p><p>또 면접을 보기 위해 아침 9시까지 가야 했는데 도착하니 후드티를 나눠주며 입으라고 했다. 다들 똑같은 옷을 입고 면접을 진행했다. 9시 30분??정도부터 면접 일정이 시작된다. 먼저 알고리즘 문제 풀기를 약 2시간에서 3시간 정도 진행하고 이후 조별로 움직이며 면접 절차를 진행했다.</p><p>알고리즘 문제는 온라인 코딩 테스트보다 살짝 더 난도가 있는 듯했다. 사실 난 풀지 못했다. 코딩 테스트가 끝나고 바로 점심을 다 같이 먹는데 입맛도 없었다. 이건 진짜 떨어졌다는 생각이 앞서 밥이 안 들어갔다.</p><p>점심 식사가 끝나면 1시 정도부터 회사 사옥 투어 &gt; 오전에 풀었던 코딩 테스트 코드 리뷰 면접 &gt; 기술 면접 &gt; NHN 선배 직원과의 대화가 진행되고 각 일정은 조별로 다르게 진행된다.</p><p>나는 사옥 투어 &gt; 선배 NHN 직원과의 대화 &gt; 기술 면접 &gt; 코드 리뷰 순으로 진행되는 조에 편성됐고 먼저 가볍게 사옥 투어를 하면서 긴장을 풀었다. 사옥 투어를 하면서 NHN의 좋은 점을 인사팀에서 잘 설명해줬다. 인사팀이 건물 지하에서 커피도 사주면서 편안한 분위기에서 면접자들과 대화를 했다.</p><p>선배 직원과의 대화 시간에는 그냥 궁금한 것들 다 물어보면 대답해주는 시간이었다. 누군가 연봉이 얼마냐, 여기는 보너스 얼마 주냐 이런 걸 물어봤는데 그냥 아무렇지도 않게 대답해주셨다.</p><p>여기서부터가 진짜다. 기술 면접의 비중이 가장 크다고 들었기에 오전에 망했던 것을 여기서 만회해야만 했다. 면접관 2명이 앉아 있었고 들어가니 1분 자기소개 이런 것도 없이 쓱 종이 하나를 들이밀었다.</p><p>대충 읽어보니 이것도 알고리즘이었다. 읽어보고 손으로 코딩하라고 했고 손 코딩 도중에 약간 이상한 방향으로 가거나 틀린 방향으로 가는 것 같으면 계속 힌트를 던져주셨다. 느끼기에는 어떻게 해결하는지 감이 안 오더라도 면접관들과 커뮤니케이션을 진행하면서 해결해 나아가는 능력을 많이 평가하는 것 같았다. </p><p>1시간 정도의 면접 시간 중 25분?? 이지나 손 코딩을 제출했다. “빨리 풀었나?? 된 건가??” 이런 생각을 했지만 아니었다. 다른 문제 하나가 또 있었고 그것은 진짜 수학 문제였다. 고등 수학의 문제 유형은 아니었고 쉬우면서도 어렵다고 느낄 수 있는 문제였으며 규칙성을 찾는 수학 문제였다. 이 역시 면접관들과 대화를 해 나가며 해결하려고 노력했다.</p><p>문제를 풀던 중 시간이 다 돼서 면접관이 이 문제는 어떤 문제였는지 설명해주셨고 지금 어디까지 내가 풀었는지 알려주셨다. 그냥 느낌에는 반 정도 풀었던 것 같다. 기술 면접이 끝나고 나와서 다른 면접자들한테 잘 봤는지 물어봤는데 다들 나랑 비슷한 상황이었다.</p><p>그리고 마지막으로 오전에 알고리즘을 풀고 제출했던 코드의 리뷰가 남아있었다. 이는 면접관 2명이 면접자 3명의 코드를 보면서 동시에 진행됐다. 한 명당 약 10분 정도 생각한 알고리즘과 어떤 방식으로 풀려고 했는지 설명했다.</p><p>나는 문제를 풀지도 못했고 코드가 정상적으로 돌아가지도 않았기에 면접관들한테 내가 생각한 알고리즘은 무엇이고 어떤 자료 구조를 선택했고 지금 이 코드가 왜 동작하지 않는 것 같은지를 설명했다. 또 개선 방향까지 설명하니 딱 10분 정도가 지났다. </p><h1 id="2차-면접"><a href="#2차-면접" class="headerlink" title="2차 면접"></a>2차 면접</h1><p><img src="/images/Review/nhn_4.png" width="500"></p><p>2차 면접은 1차 면접과 달리 짧은 시간 내에 끝났다. 다대다 면접이 진행됐고 면접관 2명, 면접자 3명이었다. 면접에 들어가기 전 30분 정도 4개의 전공 문제를 풀고 면접에 들어갔다.</p><p>답이 있는 문제도 있었고 생각을 묻는 문제도 있었다. 2차 면접은 기술과 인성 7 대 3 정도로 진행됐다. 먼저 기술 면접은 풀었던 문제를 화이트보드에 작성하면서 답을 설명하고 왜 그렇게 생각하는지 설명하는 식으로 진행됐다.</p><p>답이 있는 문제이지만 틀려도 크게 뭐라 하지 않았다. 면접관이 계속 답을 유도하고 생각을 물어보기 때문에 그냥 면접관의 질문에 대답하다 보면 답이 떠오른다. 즉, 문제를 풀 때는 모를 수도 있지만, 면접관들과 대화를 하다 보면 내가 작성한 답은 이런 오류가 있었다는 것을 깨닫고 수정할 수 있게 된다.</p><p>나 역시 틀렸지만 계속 대화를 하면서 작성했던 답의 오류를 발견하고 어떻게 수정할 수 있을지 설명했더니 면접관이 고개를 끄덕였다.</p><p>기술 면접이 끝나면 그 자리에서 바로 인성 면접이 진행되는데 이건 정말 다른 회사랑 똑같이 진행된다. 지원동기, 하고 싶은 일 등등</p><p>솔직히 1차 면접에서 떨어질 줄 알았지만 어쩌다 보니 내가 2차 면접까지 보고 있었다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;들어가기&quot;&gt;&lt;a href=&quot;#들어가기&quot; class=&quot;headerlink&quot; title=&quot;들어가기&quot;&gt;&lt;/a&gt;들어가기&lt;/h1&gt;&lt;p&gt;지난 번 &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://dongyeollee.github.io/2019/0
      
    
    </summary>
    
      <category term="review" scheme="http://DongyeolLee.github.io/categories/review/"/>
    
      <category term="job" scheme="http://DongyeolLee.github.io/categories/review/job/"/>
    
    
      <category term="review" scheme="http://DongyeolLee.github.io/tags/review/"/>
    
      <category term="recruiting" scheme="http://DongyeolLee.github.io/tags/recruiting/"/>
    
      <category term="job" scheme="http://DongyeolLee.github.io/tags/job/"/>
    
  </entry>
  
  <entry>
    <title>2018년도 11번가 채용 - 서류부터 최종면접까지 후기</title>
    <link href="http://DongyeolLee.github.io/2019/05/21/Review/11st/"/>
    <id>http://DongyeolLee.github.io/2019/05/21/Review/11st/</id>
    <published>2019-05-21T12:24:11.000Z</published>
    <updated>2019-11-30T04:28:09.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="들어가기"><a href="#들어가기" class="headerlink" title="들어가기"></a>들어가기</h1><p>지금에 와서야 작년(2018) 하반기에 했던 취업 준비 과정을 정리하는 것이 이상한 것 같다. 하지만 이번 정리?? 후기??로 인해 조금이나마 정보를 얻으려는 분들께 도움이 됐으면 한다.</p><h1 id="서류-평가"><a href="#서류-평가" class="headerlink" title="서류 평가"></a>서류 평가</h1><p>11번가 서비스 개발 분야에 지원했다. 역시 sk 회사답게 자기소개서에 써야 하는 내용과 문항이 예사롭지 않았다. 문항들은 다음과 같았다. </p><ul><li>본인의 개발 역량을 보여줄 수 있는 대표적 프로젝트 1가지에 대해 구체적으로 기술하고, 다룰수 있는 프로그래밍언어나 기술에 대해 적어주세요.(2000)</li><li>지원분야와 관련되어 경험한 활동을 적어주세요.(2000자)</li><li>지원분야와 관련성은 없으나 관심을 갖고 있는 영역과 이것을 향상시켜온 경험에 대해 적어주세요.(2000자)</li><li>향후 11번가에 입사하게 되면 하고 싶은 업무 영역과 궁극적 본인의 Career Goal은 무엇이며 이유는 무엇인지 적어주세요.(2000자)</li></ul><p>총 8000자라니… 아직 그때 상황을 기억한다. 상당히 쓰기 싫어서 미루고 미루다가 결국 이전 자소서를 복사해 붙여넣어서 냈던 걸로… 글자수도 완벽하게 채우지 못했다.<br>대략 1400자, 1900자, 1600자, 900자 정도 썼던 것 같다.</p><p>전체적으로 토 나오는 분량이었지만 최대한 관련 경험을 쓰려고 노력했다. </p><p><strong>1번 문항</strong>에는  스타트업 인턴 당시 수행했던 프로젝트를 이야기하면서 삽질했던 내용을 상세히 썻다. 결국 ‘별거 아니었는데 이런 실수를 했더라’는 느낌으로 썼다. 그리고 내가 왜 그런 실수를 했는지 이로써 얻은 경험은 무엇인지를 적었다. </p><p><strong>2번 문항</strong>에는 2가지 이야기를 풀어 썼다. 먼저 연합 동아리 활동을 하며 해커톤에 참가한 경험을 썼다. 다른 이야기로 개인 프로젝트를 만들었던 이야기를 쓰면서 내가 왜 개인 프로젝트를 진행했는지를 서술했다. </p><p><strong>3번 문항</strong>에는 내가 기술 블로그를 시작한 이유와 이로써 얻은 긍정적인 효과를 자기소개서에 담아냈다. </p><p><strong>마지막 문항</strong>에는 11번가에서 무슨 업무를 수행하고 싶은지 그 업무를 수행하기 위해 어떤 노력을 했는지 어필했다. 더 나아가 해당 업무를 수행하여 어떻게 11번가 기여할 수 있는지를 적었다. </p><h1 id="코딩-테스트"><a href="#코딩-테스트" class="headerlink" title="코딩 테스트"></a>코딩 테스트</h1><p><img src="/images/Review/11st_coding.png" width="500"></p><p>특이하게 서류를 제출하고 나면 이메일로 코딩 테스트를 볼 수 있는 URL을 보내줬다. 이메일을 받고 1일?? 3일?? 이내에 코딩 테스트를 제출해야 했다. 문제는 총 4문제로 2시간의 시간이 주어졌다.</p><p>문제는 그렇게 어렵지 않았다. 문제가 영어라 당황만 하지 않으면 누구나 풀 수 있는 그런 수준이다. 배열을 sorting 하는 문제, 배열에서 몇 번째 요소를 찾는 문제 약간 이런 형식의 문제가 주를 이뤘다. 그리고 특이하게 SQL을 묻는 문제가 1개 있었는데 이 역시 그렇게 난도가 있다고 생각하지는 않았다.</p><p>코딩 테스트를 제출하고 나면 바로 코딩 테스트 점수를 보여준다. 근데 이 결과가 그렇게 합격 여부의 큰 비중을 차지하지 않는 것 같았다. 누구는 100점을 맞고 떨어지는 반면 누구는 50점을 받았는데 서류 합격한 사람들도 있었다. </p><h1 id="SKCT"><a href="#SKCT" class="headerlink" title="SKCT"></a>SKCT</h1><p><img src="/images/Review/11st_1.png" width="500"></p><p>좀 걱정을 많이 했던 인·적성 문제였지만 10일? 정도 되는 시간에 2권 정도를 풀고 갔다. 영역당 약 20문제 정도 된다. 이 중 시간 내에 13개는 풀자는 마인드로 시험장에 갔지만, 실전은 그것보다 못한 것 같다.</p><p>평균 11문제? 10문제? 정도 풀었다. 실제 문제 난이도는 시중에서 구매한 책이 훨씬 더 어려웠지만 뭔가 모르게 긴장을 해서 그런지 생각보다 많이 풀지는 못했다.</p><p>아침 일찍부터 동국대학교로 가서 시험을 보는 만큼 문제를 풀다가 집중력을 잃을 수도 있다. 또, 기억하기로는 개인용품은 최소한으로 사용했던 것 같다. 시계도 사용 못 하고 감독관이 계속 시간을 알려준다. </p><h1 id="1차-면접"><a href="#1차-면접" class="headerlink" title="1차 면접"></a>1차 면접</h1><p><img src="/images/Review/11st_2.png" width="500"></p><p>편안한 복장으로 면접을 보러 갔다. 진짜 편하게 니트를 입고 갔는데.. 주변이 다 양복이었다. 뭔가 망한 느낌이 살짝 났지만 당황하지 않은 척했다.</p><p>1차 면접에 들어가기 전 50분가량 문제를 풀고 들어간다. 2가지 종류의 문제가 있고 이 중 하나를 선택하면 그에 관한 3~4가지 문제가 있었다.</p><p>그리고 약간 특이한 점이 있었는데 문제를 푸는 동안 핸드폰으로 검색이 가능했다. 하지만 문제에 대한 답을 1도 모른 채 검색으로 답만 찾으려고 한다면 시간이 부족했을 것 같다.</p><p>상당히 포괄적인 것을 물어보고 어디까지 아는지 확인하는 듯한 문제??? 약간 인터넷을 설명해봐라. 이런 느낌이다. 이걸 전공과 연결해서 답안을 작성해야 한다. 참고로 문제지는 다시 제출해야 했으므로 나는 문제를 요약해 차례대로 답안지에 적었다.</p><p>50분이 지나면 바로 면접으로 들어간다. 2:1 면접으로 진행하고 그렇게 압박하는 분위기는 아니다. 간단한 아이스브레이킹이 끝난 뒤 바로 풀었던 문제를 설명해보라고 한다. 어떤 면접자는 답은 적었는데 문제가 기억나지 않아 당황했다고 하니 미리 문제를 적어간 나는 뭔가 운이 좋았다.</p><p>40분 내외의 면접 중 10분 정도를 어떻게 문제를 풀었는지 또 내가 생각하는 답은 무엇인지를 그림을 그리면서 설명했다. 뭔가 설명을 잘했는지 면접관이 이 문제 말고 혹시 선택하지 않았던 다른 문제를 기억하고 있는지 물었고 그 문제에 관해 추상적으로라도 좋으니 설명해보라고 했다.</p><p>그 문제는 실무 경험이 있으면 유리한 문제여서 아는 범위내에서 설명하니 살짝 미소를 보였다. 해당 문제 설명을 마치면 정말 자소서 기반으로 질문을 하고 답을 하는 면접이였다. 기술적인 질문이 50% 였고 이 동아리는 무엇인지 왜 11번가에 지원했는지와 같은 질문이 50% 였다. </p><h1 id="2차-면접"><a href="#2차-면접" class="headerlink" title="2차 면접"></a>2차 면접</h1><p><img src="/images/Review/11st_3.png" width="500"></p><p>1차 면접과 달리 문제도 풀지 않고 그냥 앉아 있다가 바로 들어간다. 임원 면접이라고 해서 기술 관련 질문은 물어보지 않을 것 같았지만 예상은 빗나갔다. 이 역시 2대1 면접이었는데 1명이 기술 임원 다른 한 분은 그냥 임원이었다. 기술 임원이 계속 웃으면서 기술적인 질문을 던졌고 대답을 못 하는 것 같으면 힌트를 던져주셨다.</p><p>힌트를 듣고 정답을 이야기하면 계속 추임새로 ‘아시네요’, ‘잘하시네요’ 등 계속 칭찬을 해주며 편하게 해주려는 것 같았다. 2차 면접 역시 압박은 하나도 없었고 그냥 동네 아저씨랑 이야기하는 느낌이 들었다. 2차 면접은 기술 질문과 인성 질문이 60 대 40 정도였던 것 같다.</p><p>한 가지 당황했던 점이 기술면접관이 내 개인 기술 블로그에 들어와 특정 포스팅에 대해 질문을 던졌다. 진짜 들어와서 볼 줄은 몰랐는데… 대충 대답은 했지만 엄청나게 당황했다. 그리고 또 임원 면접에서 느낀 점은 2명 임원 모두 나의 자소서와 포트폴리오를 전날 확인한 것 같았다. 세세한 부분까지 알고 있었고 질문 또한 겉핥기 수준으로 대충 물어보지 않았다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;들어가기&quot;&gt;&lt;a href=&quot;#들어가기&quot; class=&quot;headerlink&quot; title=&quot;들어가기&quot;&gt;&lt;/a&gt;들어가기&lt;/h1&gt;&lt;p&gt;지금에 와서야 작년(2018) 하반기에 했던 취업 준비 과정을 정리하는 것이 이상한 것 같다. 하지만 이번 정리
      
    
    </summary>
    
      <category term="review" scheme="http://DongyeolLee.github.io/categories/review/"/>
    
      <category term="job" scheme="http://DongyeolLee.github.io/categories/review/job/"/>
    
    
      <category term="review" scheme="http://DongyeolLee.github.io/tags/review/"/>
    
      <category term="recruiting" scheme="http://DongyeolLee.github.io/tags/recruiting/"/>
    
      <category term="job" scheme="http://DongyeolLee.github.io/tags/job/"/>
    
  </entry>
  
  <entry>
    <title>자바 8 - lambda(람다) 더 알아보기</title>
    <link href="http://DongyeolLee.github.io/2019/04/30/JAVA/lambda-more/"/>
    <id>http://DongyeolLee.github.io/2019/04/30/JAVA/lambda-more/</id>
    <published>2019-04-30T07:42:42.000Z</published>
    <updated>2019-07-22T07:42:38.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="들어가기"><a href="#들어가기" class="headerlink" title="들어가기"></a>들어가기</h1><p>지난 <strong><a href="https://dongyeollee.github.io/2019/04/14/JAVA/lambda/">포스트</a></strong>에서는 람다(lambda)가 왜 사용되면 편리한지 또 어떻게 사용될 수 있을지에 대해 아주 간단하게 알아보았습니다.<br>이번 포스트에서는 람다(lambda)를 다시 한 번 정리하고 조금 더 심화된 내용을 알아보려고 합니다.</p><h1 id="람다란-무엇인가"><a href="#람다란-무엇인가" class="headerlink" title="람다란 무엇인가"></a>람다란 무엇인가</h1><p><strong>람다 표현식</strong>은 메서드로 전달할 수 있는 익명 함수를 간단하게 표현한 것입니다. 람다 표현식은 익명 함수와 비슷하게 이름은 없지만, 파라미터, 바디, 반환 형식, 예외 리스트를 가질 수 있습니다.<br>즉, 보통의 메서드와는 달리 이름이 없으므로 <strong>익명</strong>이라 표현하고 특정 메서드에 종속되지 않은 독립적인 것이므로 메서드가 아닌 함수라고 부릅니다.<br>하지만 람다가 기술적으로 자바8 이전의 자바로 할 수 없었던 일을 제공하는 것은 아닙니다. 다만 람다는 동작 파라미터 형식의 코드를 더 쉽게 구현하고 보기 쉬운 코드를 작성하는데 큰 도움이 됩니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Apple&gt; byWeight = <span class="keyword">new</span> Comparator&lt;apple&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple a1, Apple a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a1.getWeight().compareTo(a2.getWeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 코드를 람다를 이용하면 훨씬 간단한 코드로 작성할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Apple&gt; byWeight = (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</span><br></pre></td></tr></table></figure><p>즉, compare 메서드의 바디를 직접 전달하는 것처럼 코드를 전달할 수 있으면 이전 코드에 비해 훨씬 가독성 또한 높아졌습니다.<br>확인한 것처럼 람다 표현식의 기본 문법은 간단합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 유효</span></span><br><span class="line">() -&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// 유효</span></span><br><span class="line">() -&gt; <span class="string">"Raoul"</span></span><br><span class="line"><span class="comment">// 유효</span></span><br><span class="line">() -&gt; &#123;<span class="keyword">return</span> <span class="string">"Lee"</span>;&#125;</span><br><span class="line"><span class="comment">// 유효하지 않음</span></span><br><span class="line">(Integer i) -&gt; <span class="keyword">return</span> <span class="string">"Alan"</span> + i;</span><br><span class="line"><span class="comment">// 유효하지 않음</span></span><br><span class="line">(String s) -&gt; &#123;<span class="string">"Iron Man"</span>&#125;</span><br></pre></td></tr></table></figure><p>(parameters) -&gt; expression 또는 (parameters) -&gt; {statement;} 형식으로 람다 표현식을 작성할 수 있습니다.</p><h1 id="어디에-어떻게-람다를-사용할까"><a href="#어디에-어떻게-람다를-사용할까" class="headerlink" title="어디에, 어떻게 람다를 사용할까"></a>어디에, 어떻게 람다를 사용할까</h1><h2 id="함수형-인터페이스"><a href="#함수형-인터페이스" class="headerlink" title="함수형 인터페이스"></a>함수형 인터페이스</h2><p>함수형 인터페이스는 오직 하나의 추상 메서드를 지정하는 인터페이스 입니다.</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.Comparator</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.lang.Runnable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.util.concurrent.Callable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>과연 이런 함수형 인터페이스로 무엇을 할 수 있을까요? 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있으므로 전체 표현식을 함수형 인터페이스의 인스턴스로 취급할 수 있습니다.<br>또, 함수형 인터페이스보다는 덜 깔끔하지만 익명 내부 클래스로도 같은 기능을 구현할 수 있습니다.</p><p>다음과 같은 코드는 모두 올바른 코드입니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 람다 사용</span></span><br><span class="line">Runnable r1 = () -&gt; System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line"><span class="comment">// 익명 클래스 사용</span></span><br><span class="line">Runnable r2 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    r.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process(r1);</span><br><span class="line">process(r2);</span><br><span class="line">process(() -&gt; System.out.println(<span class="string">"Hello 3"</span>));</span><br></pre></td></tr></table></figure><h2 id="함수-디스크립터"><a href="#함수-디스크립터" class="headerlink" title="함수 디스크립터"></a>함수 디스크립터</h2><p>람다 표현식의 시그니처를 서술하는 메서드를 <strong>함수 디스크립터</strong>라고 부릅니다. 예를 들어 Runnable 인터페이스의 유일한 추상 메서드 run은 인수와 반환값이 없으므로 Runnable 인터페이스는 인수와 반환값이 없는 시그니처로 생각할 수 있습니다.<br>즉, Runnable 인터페이스의 run은 () -&gt; void과 같이 표현될 수 있습니다. 그리고 이에 대응하는 람다의 함수 디스크립터 역시 () -&gt; void로 표현되어야 합니다.</p><h1 id="함수형-인터페이스-사용"><a href="#함수형-인터페이스-사용" class="headerlink" title="함수형 인터페이스 사용"></a>함수형 인터페이스 사용</h1><h2 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h2><p> java.util.function.Predicate&lt; T &gt; 인터페이스는 test라는 추상메서드를 정의하며 test는 제네릭 형식의 t의 객체를 인수로 받아 Boolean을 반환합니다. 즉, 따로 Predicate를 만들 필요없이 필요에 따라 바로 Predicate 인터페이스를 사용할 수 있습니다.</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">filter</span><span class="params">(List&lt;T&gt; list, Predicate&lt;T&gt; p)</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(T s : list) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.test(s)) &#123;</span><br><span class="line">            results.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; nonEmptyStringPredicate = (String s) -&gt; !s.isEmpty();</span><br><span class="line">List&lt;String&gt; nonEmpty = filter(listOfString, nonEmptyStringPredicate)</span><br></pre></td></tr></table></figure><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><p>java.util.function.Consumer&lt; T &gt; 인터페이스는 제네릭 형식 T 객체를 받아서 void를 반환하는 accept라는 추상 메서드를 정의합니다. T 형식의 객체를 인수로 받아서 어떤 동작을 수행하고 싶을 때 Consumer 인터페이스를 사용할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(List&lt;T&gt; list, Consumer&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T i : list) &#123;</span><br><span class="line">        c.accept(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; i = map(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), (Integer i) -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>java.util.function.Function&lt; T, R &gt; 인터페이스는 제네릭 형식 T를 인수로 받아서 제네릭 형식 R 객체를 반환하는 apply라는 추상 메서드를 정의하며 이를 활용하여 입력을 출력으로 매핑하는 형식으로 사용할 수 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, R&gt; <span class="function">List&lt;R&gt; <span class="title">map</span><span class="params">(List&lt;T&gt; list, Function&lt;T, R&gt; f)</span> </span>&#123;</span><br><span class="line">    List&lt;R&gt; = result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(T s : list) &#123;</span><br><span class="line">        result.add(f.apply(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4, 2, 3</span></span><br><span class="line">List&lt;Integer&gt; i = map(Array.asList(<span class="string">"test"</span>, <span class="string">"dy"</span>, <span class="string">"lee"</span>), (String s) -&gt; s.length());</span><br></pre></td></tr></table></figure><h2 id="기본형-특화"><a href="#기본형-특화" class="headerlink" title="기본형 특화"></a>기본형 특화</h2><p>자바에는 기본형과 참조형이 존재하지만 제네릭 파라미터에는 참조형만 사용할 수 있습니다. 이에 따라 자바에서는 기본형을 참조형으로 변환할 수 있는 기능을 제공하고 이 기능을 <strong>박싱</strong>이라고 부릅니다.<br>또 이와 반대로 참조형을 기본형으로 변환하는 작업을 <strong>언박싱</strong>이라고 부릅니다. 더 나아가 자바에서는 박싱과 언박싱이 자동으로 이루어지는 오토 박싱이라는 기능도 제공합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">300</span>; i &lt; <span class="number">400</span>; i ++) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>예시와 같은 코드는 동작하는데는 무리가 없지만 기본형이 참조형으로 변환하는 과정에서 어쩔수 없는 비용이 소모됩니다. 박싱한 값은 기본형을 감싸는 래퍼이며 힙에 저장됩니다. 따라서 박싱한 값은 메모리를 더 소비하며 기본형을 가져올 때도 메모리를 탐색하는 과정이 필요합니다.<br>자바 8에서는 오토박싱 동작을 피할 수 있도록 특별한 버전의 함수형 인터페이스를 제공합니다. 예를 들어 아래 예제에서 IntPredicate는 1000이라는 값을 박싱하지 않지만, Predicate&lt; Integer &gt;는 1000이라는 값을 Integer로 박싱합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntPredicate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 박싱 없음</span></span><br><span class="line">IntPredicate evenNumbers = (<span class="keyword">int</span> i) -&gt; i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">evenNumbers.test(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 박싱</span></span><br><span class="line">Predicate&lt;Integer&gt; oddNumbers = (Integer i) -&gt; i % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">oddNumbers.test(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p>자바 8에서 중요한 요소인 람다의 정리를 마치겠습니다. 질문은 언제든지 자유롭게 달아주시면 찾아서라도 답 달아보도록 노력할게요~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;들어가기&quot;&gt;&lt;a href=&quot;#들어가기&quot; class=&quot;headerlink&quot; title=&quot;들어가기&quot;&gt;&lt;/a&gt;들어가기&lt;/h1&gt;&lt;p&gt;지난 &lt;strong&gt;&lt;a href=&quot;https://dongyeollee.github.io/2019/04/14/J
      
    
    </summary>
    
      <category term="programming" scheme="http://DongyeolLee.github.io/categories/programming/"/>
    
      <category term="java" scheme="http://DongyeolLee.github.io/categories/programming/java/"/>
    
    
      <category term="java" scheme="http://DongyeolLee.github.io/tags/java/"/>
    
      <category term="lambda" scheme="http://DongyeolLee.github.io/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>자바 8 - lambda(람다) 함수</title>
    <link href="http://DongyeolLee.github.io/2019/04/14/JAVA/lambda/"/>
    <id>http://DongyeolLee.github.io/2019/04/14/JAVA/lambda/</id>
    <published>2019-04-14T05:15:55.000Z</published>
    <updated>2019-04-30T07:24:41.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="들어가기"><a href="#들어가기" class="headerlink" title="들어가기"></a>들어가기</h1><p>어떤 상황에서 일을 하든 소비자 요구사항은 항상 바뀔 가능성이 높습니다. 따라서 변화하는 요구사항은 소프트웨어에서는 피할 수 없는 문제입니다.<br>이런 상황에서 조금 더 가독성있게 편리하게 사용할 수 있는 것이 <strong><code>Lambda(람다)</code></strong>라는 자바 8에서 추가된 기능이라고 할 수 있습니다. </p><p><strong><code>lambda</code></strong>를 이해하기 전 우리는 먼저 시시각각 변하는 사용자 요구사항에 어떻게 대응해야 할까 생각을 해보아야 합니다. 새로 추가되거나 변경되는 기능이 쉽게 구현 가능하며 장기적인 관점에서는 유지 보수가 쉬워야 합니다.</p><h1 id="동작-파라미터화"><a href="#동작-파라미터화" class="headerlink" title="동작 파라미터화"></a>동작 파라미터화</h1><p><strong>동작 파라미터화</strong>를 이용하면 자주 바뀌는 요구사항을 효과적으로 대응할 수 있습니다. <strong>동작 파라미터화</strong>란 아직은 어떻게 실행할 것인지 결정하지 않은 코드 블록을 의미합니다.<br>글로만 보려하니 잘 이해가 가지 않을 수도 있습니다. 한번 예시를 살펴보겠습니다.</p><p>사과가 담긴 리스트에서 녹색 사과만 필터링 하는 기능을 구현하는 코드를 한번 보겠습니다.</p><pre><code class="java">public class filterGreenApples {    public static List<apple> filterGreenApples(List<apple> inventory) {        List<apple> result = new ArrayList<apple>();        for (Apple apple : inventory) {            if ("green".equals(apple.getColor()) {                result.add(apple);            }        }        return result;    }}</apple></apple></apple></apple></code></pre><p>위와 같은 코드에서 과연 초록 사과 뿐만이 아닌 빨간 사과도 필터링 하고 싶으면 어떤 식으로 코드를 수정해야 할까요?<br>물론 코드 자체를 복사해서 “green” 부분만 “red”로 수정해도 문제는 없습니다. 하지만 나중에 다양한 색으로 필터링 하기는 어려운 관계로 조금 더 변화에 적절하게 바꿔 보겠습니다.</p><pre><code class="java">public class filterApplesByColor {    public static List<apple> filterApplesByColor(List<apple> inventory, String color) {        List<apple> result = new ArrayList<apple>();        for(Apple apple : inventory) {            if (apple.getColor().equals(color)) {                result.add(apple);            }        }        return result;    }}</apple></apple></apple></apple></code></pre><p>이제 모든 색의 사과를 필터링 할 수 있게 됐습니다. 하지만 더 나아가 특정 색을 가진 사과를 다시 무게로 필터링을 하려면 어떻게 수정할 수 있을까요? 여러가지 방법이 있을 수 있겠지만 가장 쉽게 생각할 수 있는 방법은 다음과 같습니다.</p><pre><code class="java">public class filterApplesByWeight {    // 특정 무게보다 무거운 사과만 담기    public static List<apple> filterApplesByWeight(List<apple> inventory, int weight) {        List<apple> result = new ArrayList<apple>();        for(Apple apple : inventory) {            if (apple.getWeight() > weight) {                result.add(apple);            }        }        return result;    }}</apple></apple></apple></apple></code></pre><p>지금까지 세개의 예시 코드를 보았습니다. 무엇가 느껴지시지 않으신가요? 검색 조건이 추가될 때마다 파라미터가 증가한다거나 또 색으로만 검색하고 싶은 경우는 별도의 중복된 함수를 따로 둬야 한다는 문제가 있습니다.<br>어떤 식으로 변경을 하면 조금 더 유연하게 변경이 가능할까요? 먼저 검색 조건을 추상화 해보겠습니다.</p><pre><code class="java">public interface ApplePredicate {    boolean test (Apple apple);}public class filterApplesWithPredicate {    public static List<apple> filterApplesWithPredicate(List<apple> inventory, ApplePredicate p) {        List<apple> result = new ArrayList<apple>();        for(Apple apple : inventory) {            if(p.test(apple)) {                result.add(apple);            }        }        return result;    }    public class AppleHeavyWeightPredicate implements ApplePredicate {        @Override        public boolean test(Apple apple) {            return apple.getWeight() > 150;        }    }}</apple></apple></apple></apple></code></pre><p>위와 같은 코드는 어떤가요? 전략 패턴을 사용하여 메서드가 다양한 동작을 받아서 내부적으로 수행할 수 있게되어 훨씬 유연한 코드로 변화하였습니다. ApplePredicate를 적절하게 구현하는 클래스를 만들면 다양한 요구사항에 맞게 기능을 추가할 수 있습니다.<br><strong>즉, 우리가 전달한 ApplePredicate 객체에 의해 filterApplesWithPredicate 메서드의 동작을 파라미터화 한 것입니다.</strong></p><p>자! 오래 기다리셨습니다. 이제 <strong><code>lambda(람다)</code></strong>를 이야기 할때가 된 것 같습니다. 바로 직전 본 코드에서 filter 함수를 어떤 식으로 호출할 수 있을까요?<br>아마 다음과 같이 호출할 수 있습니다.</p><pre><code class="java">public class FilteringApples {    public static void main(String...args) {        List<apple> inventory = Arrays.asList(new Apple(90, "green"),                                       new Apple(200, "red"),                                       new Apple(90, "red"));        List<apple> heavyApples = filterApplesWithPredicate(inventory,                                                       new AppleHeavyWeightPredicate);    }}</apple></apple></code></pre><p>또 실제로 AppleHeavyWeightPredicate 메서드를 활용하지 않고 익명 함수로 처리할 수도 있습니다.</p><pre><code class="java">public class FilteringApples {    public static void main(String...args) {        List<apple> inventory = Arrays.asList(new Apple(90, "green"),                                       new Apple(200, "red"),                                       new Apple(90, "red"));        List<apple> heavyApples = filterApplesWithPredicate(inventory, new ApplePredicate() {            @Override            public boolean test(Apple apple) {                return apple.getWeight() > 150;            }        });    }}</apple></apple></code></pre><p>하지만 다음과 같은 익명 클래스에서도 다소 고치고 싶은 부분이 있습니다. 바로 중복되는 부분의 코드입니다. 익명 클래스로 <strong>ApplePredicate()</strong>를 넘겨 줄 때마다 명시적으로 public boolean test까지 표현해야해 여전히 많은 공간을 차지 합니다.<br>또, 익명 클래스에 익숙하지 않으면 사용하기 어렵다는 문제도 발생할 수 있습니다. </p><p>이런 코드의 장황함과 익숙하지 않음을 해결해 줄 수 있는 방법이 바로 <strong><code>lambda(람다)</code></strong>입니다. 즉, <strong><code>lambda(람다)</code></strong>는 한눈에 이해할 수 있는 코드를 구현하는 데 많은 도움을 줄 수 있습니다.<br>명시적으로 익명 클래스처럼 객체를 만들고 새로운 동작을 정의하는 메서드를 구현하는데는 변하지 않지만 훨씬 가독성이 뛰어난 것을 확인할 수 있습니다. </p><p>이제 <strong><code>lambda(람다)</code></strong>를 활용하여 앞에서 본 예제가 어떻게 변화했는지 확인 해보겠습니다.</p><pre><code class="java">public class FilteringApples { public static void main(String...args) {     List<apple> inventory = Arrays.asList(new Apple(90, "green"),                                    new Apple(200, "red"),                                    new Apple(90, "red"));     List<apple> heavyApples = filterApplesWithPredicate(inventory,         // 람다 표현식        (Apple apple) -> apple.getWeight() > 150); }}</apple></apple></code></pre><p>이전 보다 훨씬 코드가 간결해지지 않았나요? 코드가 간결해지면서 가독성 또한 많이 높아졌습니다. 즉, <strong><code>lambda(람다)</code></strong>는 코드의 장황성을 배제하고 프로그래머로 하여금 훨씬 좋은 코드를 짤 수 있도록 많이 사용되고 있습니다.<br>다시 한번 정리하자면 <strong><code>lambda(람다)</code></strong>는 익명 클래스처럼 이름이 없는 함수면서 메서드를 간결하고 장황하지 않게 인수로 전달할 수 있는 코드 블록를 의미합니다.</p><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p><strong><code>lambda(람다)</code></strong>를 설명하기에는 다소 부족한 점이 많이 있었을 것이라 생각됩니다. 틀린 부분이 있거나 이해가 잘 가지 않는 부분이 있다면 언제든지 comment 달아주세요~<br>이번은 겉핥기식으로 정리를 해보았지만 이후 조금 더 심화된 내용의 <strong><code>lambda(람다)</code></strong>를 정리해볼까합니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;들어가기&quot;&gt;&lt;a href=&quot;#들어가기&quot; class=&quot;headerlink&quot; title=&quot;들어가기&quot;&gt;&lt;/a&gt;들어가기&lt;/h1&gt;&lt;p&gt;어떤 상황에서 일을 하든 소비자 요구사항은 항상 바뀔 가능성이 높습니다. 따라서 변화하는 요구사항은 소프트웨어에
      
    
    </summary>
    
      <category term="programming" scheme="http://DongyeolLee.github.io/categories/programming/"/>
    
      <category term="java" scheme="http://DongyeolLee.github.io/categories/programming/java/"/>
    
    
      <category term="java" scheme="http://DongyeolLee.github.io/tags/java/"/>
    
      <category term="lambda" scheme="http://DongyeolLee.github.io/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>백준[1759] - 암호 만들기</title>
    <link href="http://DongyeolLee.github.io/2018/12/04/Al/1759/"/>
    <id>http://DongyeolLee.github.io/2018/12/04/Al/1759/</id>
    <published>2018-12-03T16:51:13.000Z</published>
    <updated>2019-04-30T07:24:41.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p><a href="https://www.acmicpc.net/problem/1759" target="_blank" rel="noopener"><strong><em>백준 1759 문제 보기</em></strong></a></p><h1 id="접근-방법"><a href="#접근-방법" class="headerlink" title="접근 방법"></a>접근 방법</h1><p>이번 문제는 백 트래킹을 활용해 문제를 풀 수 있다.</p><p>입력 받은 문자열을 오름 차순으로 정렬한 뒤 백 트래킹을 실시 한다.</p><p>조합을 통해 만들어 낸 문자열의 길이가 최종 길이와 같다면 문자열 중복을 set을 활용해 피한다.</p><h1 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h1><pre><code class="cpp">#include &ltiostream&gt#include &ltvector>#include &ltstring>#include &ltalgorithm>#include &ltset>using namespace std;int L, C;vector&ltchar> c_arr;set&ltstring> se;void back_tracking(int idx, int cnt, string s) {    // 문자열 길이가 최종 길이와 같다면    if(cnt == L) {        // 모음 갯수, 자음 갯수        int chk1 = 0, chk2 = 0;        // 알파벳 중복 체크        int visited[27] = {0, };        for(int i = 0; i < s.length(); i ++) {            // 모음인 경우            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {                chk1 ++;            }            // 자음인 경우            else {                // 중복 자음이 아닌 경우 카운트 증가                if(!visited[s[i]-'0'-48])                    chk2 ++;            }        }        // 모음이 하나 이상이고 서로 다른 자음이 2개이상 사용하면 set에 저장        if(chk1 >= 1 && chk2 >= 2)            se.insert(s);        return;    }    for(int i = idx; i < C; i ++) {        // 문자를 선택한 경우        back_tracking(i + 1, cnt + 1, s + c_arr[i]);        // 선택하지 않고 지나친 경우        back_tracking(i + 1, cnt, s);    }}int main() {    cin >> L >> C;    for(int i = 0; i < C; i ++) {        char c;        cin >> c;        c_arr.push_back(c);    }    // 오름 차순으로 정렬    sort(c_arr.begin(), c_arr.end());    // 백 트래킹 시작    back_tracking(0, 0, "");    // set에 저장된 문자열 출력    for(auto it = se.begin(); it != se.end(); it++) {        cout << *it << endl;    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1759&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
      <category term="computer science" scheme="http://DongyeolLee.github.io/categories/computer-science/"/>
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/"/>
    
      <category term="problems" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"/>
    
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/tags/algorithms/"/>
    
  </entry>
  
  <entry>
    <title>백준[1261] - 알고스팟</title>
    <link href="http://DongyeolLee.github.io/2018/11/27/Al/1261/"/>
    <id>http://DongyeolLee.github.io/2018/11/27/Al/1261/</id>
    <published>2018-11-27T06:12:05.000Z</published>
    <updated>2019-04-30T07:24:41.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p><a href="https://www.acmicpc.net/problem/1261" target="_blank" rel="noopener"><strong><em>백준 1261 문제 보기</em></strong></a></p><h1 id="접근-방법"><a href="#접근-방법" class="headerlink" title="접근 방법"></a>접근 방법</h1><p>문제의 정답은 벽을 최소로 부수면서 도착지에 도착하게끔 구현해야한다.</p><p>bfs로도 풀수 있을 것 같긴하나 시간 초과가 발생할 수도 있을것 같다. 따라서 다익스트라 알고리즘을 사용했다.</p><p>벽을 부수는 갯수를 해당 좌표까지 이동하는 비용으로 생각하고 문제를 풀었다.</p><h1 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h1><pre><code class="cpp">#include &ltiostream&gt#include &ltcstring>#include &ltqueue>using namespace std;int r, c;int map[101][101];int broken[101][101];int dr[4] = {-1, 0, 1, 0};int dc[4] = {0, 1, 0, -1};priority_queue&ltpair&ltint, pair&ltint, int>>> pq;int main() {    cin >> c >> r;    // 벽을 부순 갯수를 나타내는 broken 지도    memset(broken, -1, sizeof(broken));    for(int i = 0; i < r; i ++) {        for(int j = 0; j < c; j ++) {            // 숫자 하나씩 입력 받으며 map에 그림            scanf(" %1d", &map[i][j]);        }    }    // 우선 순위 큐에 {벽을 부순 숫자, {좌표1, 좌표2}}    // 즉, (좌표1, 좌표2)까지 이동하기 위해 부순 벽돌수를 저장    pq.push({0, {0, 0}});    while(!pq.empty()) {        int broken_cnt = -pq.top().first;        int rr = pq.top().second.first;        int cc = pq.top().second.second;        pq.pop();        // 이미 해당 경로를 통과했을 경우        if(broken[rr][cc] != -1) {            continue;        }        // 부순 벽돌 수 저장        broken[rr][cc] = broken_cnt;        // 위, 오른쪽, 아래, 왼쪽        for(int i = 0; i < 4; i ++) {            int nr = rr + dr[i];            int nc = cc + dc[i];            // 범위 안에 존재하고            if(nr >= 0 && nc >= 0 && nr < r && nc < c) {                // 다음 목적지를 방문한적이 없으면                if(broken[nr][nc] == -1) {                    // 다음 목적지가 벽돌이라면                    if(map[nr][nc] == 1) {                        pq.push({-(broken_cnt + 1), {nr, nc}});                    }                    // 벽돌 없는 빈방이라면                    else {                        pq.push({-broken_cnt, {nr, nc}});                    }                }            }        }    }    cout << broken[r-1][c-1];    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1261&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
      <category term="computer science" scheme="http://DongyeolLee.github.io/categories/computer-science/"/>
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/"/>
    
      <category term="problems" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"/>
    
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/tags/algorithms/"/>
    
  </entry>
  
  <entry>
    <title>백준[1238] - 파티</title>
    <link href="http://DongyeolLee.github.io/2018/11/16/Al/1238/"/>
    <id>http://DongyeolLee.github.io/2018/11/16/Al/1238/</id>
    <published>2018-11-16T05:20:50.000Z</published>
    <updated>2019-04-30T07:24:41.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p><a href="https://www.acmicpc.net/problem/1238" target="_blank" rel="noopener"><strong><em>백준 1238 문제 보기</em></strong></a></p><h1 id="접근-방법"><a href="#접근-방법" class="headerlink" title="접근 방법"></a>접근 방법</h1><p>다익스트라 알고리즘을 사용하되 다시 각자의 마을로 복귀해야 하므로 다익스트라 알고리즘을 한번 더 사용한다.</p><p>dis_go 배열에는 갈때의 비용을 저장하고 dis_come 배열에는 다시 돌아올때의 비용을 저장한다.</p><h1 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h1><pre><code class="cpp">#include &ltiostream&gt#include &ltvector>#include &ltqueue>#include &ltalgorithm>#include &ltutility>#include &ltcstring>using namespace std;int N, M, X, ans = -1, dis_go[1001], dis_come[1001];vector&ltvector&ltpair&ltint, int>>> graph;priority_queue&ltpair&ltint, int>> pq;int main() {    // 학생, 도로 숫자, 도착 마을    cin >> N >> M >> X;    // 마을 수 만큼 그래프를 증가    graph.resize(M+1);    for(int i = 0; i < M; i ++) {        int from, to, time;        cin >> from >> to >> time;        // 그래프를 그림        graph[from].push_back({to, time});    }    // 모든 마을에서 도착지점으로 가야하므로 반복문 사용    for(int i = 1; i &lt= N; i ++) {        // 출발지 설정        int source = i;        // 우선순위 큐를 초기화(나에게 오는 비용은 0)        pq.push({0, source});        // 모든 비용을 -1로 처리        memset(dis_go, -1, sizeof(dis_go));        while(!pq.empty()) {            int here = pq.top().second;            int cost = -pq.top().first;            pq.pop();            // 방문한 적이 있다면 무시            if(dis_go[here] != -1) {                continue;            }            // 해당 마을까지의 비용을 저장            dis_go[here] = cost;            // 현재 마을로 부터 연결된 지점을 탐색            for(int n = 0; n < graph[here].size(); n ++) {                int next = graph[here][n].first;                int n_cost = -graph[here][n].second - cost;                // 방문한 적이 있다면 무시                if(dis_go[next] != -1) {                    continue;                }                // 새로운 마을이라면 우선 순위큐에 삽입                pq.push({n_cost, next});            }        }        // 원래 마을로 복귀해야 하므로 도착지점을 출발지점으로 설정        pq.push({0, X});        memset(dis_come, -1, sizeof(dis_come));        while(!pq.empty()) {            int here = pq.top().second;            int cost = -pq.top().first;            pq.pop();            if(dis_come[here] != -1) {                continue;            }            dis_come[here] = cost;            for(int n = 0; n < graph[here].size(); n ++) {                int next = graph[here][n].first;                int n_cost = -graph[here][n].second - cost;                if(dis_come[next] != -1) {                    continue;                }                pq.push({n_cost, next});            }        }        ans = max(ans, dis_go[X] + dis_come[source]);    }    cout << ans;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1238&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
      <category term="computer science" scheme="http://DongyeolLee.github.io/categories/computer-science/"/>
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/"/>
    
      <category term="problems" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"/>
    
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/tags/algorithms/"/>
    
  </entry>
  
  <entry>
    <title>백준[1916] - 최소비용 구하기</title>
    <link href="http://DongyeolLee.github.io/2018/11/14/Al/1916/"/>
    <id>http://DongyeolLee.github.io/2018/11/14/Al/1916/</id>
    <published>2018-11-14T05:09:32.000Z</published>
    <updated>2019-04-30T07:24:41.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p><a href="https://www.acmicpc.net/problem/1916" target="_blank" rel="noopener"><strong><em>백준 1916 문제 보기</em></strong></a></p><h1 id="접근-방법"><a href="#접근-방법" class="headerlink" title="접근 방법"></a>접근 방법</h1><p>한 정점에서 모든 정점을 최소비용으로 가는 방법을 구하는 문제이므로 이는 다익스트라 알고리즘을 활용해 해결할 수 있다.</p><p>즉, 구하고자하는 마을과 버스 노선을 그래프로 그려 이를 활용해 우선순위 큐로 문제를 해결한다.</p><h1 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h1><pre><code class="cpp">#include &ltiostream&gt#include &ltvector>#include &ltutility>#include &ltqueue>#include &ltcstring>using namespace std;// N: 마을 수, M: 버스 노선 수, source: 출발, destination: 목적지, dis[]: 거리int N, M, source, destination, dis[1001];vector&ltvector&ltpair<int, int>>> graph;priority_queue&ltpair&ltint, int>> pq;int main() {    cin >> N;    cin >> M;    // 그래프의 노드는 마을이므로 사이즈 증가    graph.resize(N+1);    for(int i = 0; i < M; i ++) {        int from, to, cost;        cin >> from >> to >> cost;        // 현재 마을에서 다음 마을까지의 요소를 현재 마을 인덱스에 저장        graph[from].push_back(make_pair(to, cost));    }    cin >> source >> destination;    // 우선순위 큐에 출발지 정보 삽입    pq.push({0, source});    memset(dis, -1, sizeof(dis));    while(!pq.empty()) {        // 우선순위 큐는 기본적으로 max heap을 활용하므로 - 값을 취함         int cost = -pq.top().first;        int location = pq.top().second;        pq.pop();        // 이전 방문 기록이 있으면 무시        if(dis[location] != -1) {            continue;        }        dis[location] = cost;        for(int i = 0; i < graph[location].size(); i ++) {            int n_location = graph[location][i].first;            // 가장 작은 비용이 상위에 저장되어야 하므로 - 값            int n_cost = -graph[location][i].second - cost;            if(dis[n_location] != -1) {                continue;            }            pq.push({n_cost, n_location});        }    }    cout << dis[destination];    return 0;}</int,></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1916&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
      <category term="computer science" scheme="http://DongyeolLee.github.io/categories/computer-science/"/>
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/"/>
    
      <category term="problems" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"/>
    
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/tags/algorithms/"/>
    
  </entry>
  
  <entry>
    <title>stringstream을 활용하여 문자열 처리하기</title>
    <link href="http://DongyeolLee.github.io/2018/11/08/Tips/StringStream/"/>
    <id>http://DongyeolLee.github.io/2018/11/08/Tips/StringStream/</id>
    <published>2018-11-08T12:19:47.000Z</published>
    <updated>2019-04-30T07:24:41.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="들어가기"><a href="#들어가기" class="headerlink" title="들어가기"></a>들어가기</h1><p>cpp로 알고리즘 문제를 풀다보면 가끔 까다로운 input으로 시간이 오래 걸릴 경우가 있습니다.</p><p>그중 최근 겪었던 까다로운 input을 쉽게 해결하는 방법을 알아보겠습니다.</p><h1 id="본론"><a href="#본론" class="headerlink" title="본론"></a>본론</h1><p>문자열을 쉽게 핸들링하는 방법으로 <strong><code>stringstream</code></strong>이 있습니다. 이를 활용하여 입력받은 string input을 구분하여 저장할 수 있습니다.</p><p>예를 들어 다음과 같은 상황을 고려해보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 lee 3학년 19살</span><br><span class="line">2 kim 2학년 18살</span><br><span class="line">3 choi 1학년 17살</span><br></pre></td></tr></table></figure><p>예시와 같이 3명의 학생이 입력이 됩니다. 하지만 모든 입력은 띄어쓰기를 구분되어 번호, 이름, 학년, 나이가 입력됩니다. 이름과 학년, 나이의 길이 제한은 없습니다.</p><p>즉, 이름이 100자인 학생이 들어올수도 있고 나이가 100살인 학생이 들어올수 있습니다.</p><p>이럴 경우 단순히 input을 처리하기에는 다소 많은 시간을 들여야 합니다. 이때 유용하게 사용할 수 있는 방법이 바로 <strong><code>stringstream</code></strong>입니다.</p><p>이 역시 코드를 보며 확인해 보겠습니다.</p><pre><code class="cpp">#include &ltiostream>#include &ltsstream>using namespace std;int main() {    string input;    for(int i = 0; i < 3; i ++) {        getline(cin, input);        stringstream ss(input);        string v;        while((ss >> v)) {            cout << v << endl;        }        cout << endl;    }    return 0;}</code></pre><p>일단 입력받은 문자열을 통째로 input에 저장합니다. 이럴 경우 input에 저장되는 값은 아래와 같습니다.</p><p><img src="/images/Tips_Al/1/1.png" width="500"></p><p>input에 저장된 문자열을 이제 <strong><code>stringstream</code></strong>을 생성하며 문자열을 전달합니다.</p><p>이렇게 되면 ss에도 input 값과 같은 문자열이 가지고 있게 됩니다.</p><p><strong><code>stringstream</code></strong>에 저장된 값을 12번 줄에서 보이는 것 같이 내부적으로 다시 string 단위로 뽑아 다음과 같은 출력을 얻을 수 있습니다.</p><p><img src="/images/Tips_Al/1/2.png" width="300"></p><p>중간에 <strong><code>stringstream</code></strong>을 바꿔야 한다면 다음과 같이 사용하시면 됩니다. </p><pre><code class="cpp">ss.str("바꿔야 할 문자열");</code></pre><p><strong><code>stringstream</code></strong>을 사용하면서 한가지 주의할 점은 바로 값의 type입니다.</p><p>코드 예시에서 볼수 있듯이 <strong><code>stringstream</code></strong>에서 연산자를 활용하여 string type의 v에 값을 저장하고 있습니다.</p><p>하지만 이 type이 맞지 않는다면 <strong><code>stringstream</code></strong>은 값을 저장하지 않고 바로 종료합니다.</p><p><img src="/images/Tips_Al/1/3.png" width="400"></p><p><strong>즉, 위와 같은 input이 들어왔을 경우 해당 값을 저장할 변수 type이 int로 설정되어 있다면 출력 n의 바로 앞인 8까지 출력후 종료됩니다.</strong></p><h1 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h1><p>이번에 알게된 <strong><code>stringstream</code></strong>을 통해 모든 분들이 예상치 못한 input에 당황하는 일이 줄어들었으면 합니다… </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;들어가기&quot;&gt;&lt;a href=&quot;#들어가기&quot; class=&quot;headerlink&quot; title=&quot;들어가기&quot;&gt;&lt;/a&gt;들어가기&lt;/h1&gt;&lt;p&gt;cpp로 알고리즘 문제를 풀다보면 가끔 까다로운 input으로 시간이 오래 걸릴 경우가 있습니다.&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="computer science" scheme="http://DongyeolLee.github.io/categories/computer-science/"/>
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/"/>
    
      <category term="tips" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/tips/"/>
    
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/tags/algorithms/"/>
    
      <category term="tips" scheme="http://DongyeolLee.github.io/tags/tips/"/>
    
      <category term="cpp" scheme="http://DongyeolLee.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>백준[2644] - 촌수계산</title>
    <link href="http://DongyeolLee.github.io/2018/11/07/Al/2644/"/>
    <id>http://DongyeolLee.github.io/2018/11/07/Al/2644/</id>
    <published>2018-11-07T12:07:34.000Z</published>
    <updated>2019-04-30T07:24:41.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p><a href="https://www.acmicpc.net/problem/2644" target="_blank" rel="noopener"><strong><em>백준 2644 문제 보기</em></strong></a></p><h1 id="접근-방법"><a href="#접근-방법" class="headerlink" title="접근 방법"></a>접근 방법</h1><p>전형적인 bfs 완전 탐색으로 문제를 해결할 수 있다.</p><p>각 가족들의 촌수를 양방향 그래프로 벡터에 저장한 뒤, 시작 노드부터 완전 탐색을 시작한다.</p><h1 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h1><pre><code class="cpp">#include &ltiostream&gt#include &ltqueue>#include &ltvector>using namespace std;// 구조체 작성struct info {    // 촌수를 카운트    int rel_cnt;    // 나의 노드    int my_num;};int n, r1, r2, cnt;vector&ltvector&ltint>> rel(101);int visited[101];queue<info> q;int main() {    cin >> n;    cin >> r1 >> r2;    cin >> cnt;    for(int i = 0; i < cnt; i ++) {        int x, y;        cin >> x >> y;        // 촌수에 대한 양방향 그래프        rel[x].push_back(y);        rel[y].push_back(x);    }    // 나를 시작으로 완전탐색 시작    q.push({0, r1});    // 방문 체크    visited[r1] = 1;    while(!q.empty()) {        int rel_cnt = q.front().rel_cnt;        int my_num = q.front().my_num;        q.pop();        // 도착지점        if(my_num == r2) {            cout << rel_cnt;            return 0;        }        // 연결된 노드(가족)를 모두 검색        for(int i = 0; i < rel[my_num].size(); i ++) {            int next_rel = rel[my_num][i];            // 방문하지 않은 가족이 있다면            if(visited[next_rel] != 1) {                visited[next_rel] = 1;                q.push({rel_cnt + 1, next_rel});            }        }    }    cout << -1;    return 0;}</info></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2644&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
      <category term="computer science" scheme="http://DongyeolLee.github.io/categories/computer-science/"/>
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/"/>
    
      <category term="problems" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"/>
    
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/tags/algorithms/"/>
    
  </entry>
  
  <entry>
    <title>백준[16236] - 아기 상어</title>
    <link href="http://DongyeolLee.github.io/2018/10/24/Al/16236/"/>
    <id>http://DongyeolLee.github.io/2018/10/24/Al/16236/</id>
    <published>2018-10-23T16:23:34.000Z</published>
    <updated>2019-04-30T07:24:41.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p><a href="https://www.acmicpc.net/problem/16236" target="_blank" rel="noopener"><strong><em>백준 16236 문제 보기</em></strong></a></p><h1 id="접근-방법"><a href="#접근-방법" class="headerlink" title="접근 방법"></a>접근 방법</h1><p>bfs를 활용하는 문제다. 처음에는 어떻게 풀어야 할지 잘 생각이 나지 않았다. 문제가 이해가 가질 않아서..</p><p>차분히 다시 생각해보니 bfs로 풀면 N이 작기 때문에 가능할 것 같다는 생각이 들었다.</p><p>bfs를 사용하되 과연 어떤 식으로 해결할 수 있을까..</p><p>아기 상어가 자신보다 작은 길로만 가게끔 구현하고 다음 위치의 상어가 아기 상어와 사이즈가 같을 경우와 물고기 없이 길인 경우를 동일시 처리한다.</p><p>만약 작은 상어가 있어 잡아 먹는다면 벡터로 따로 관라하는 방법을 취했다.</p><p>자세한 내용은 코드 주석을 확인</p><h1 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h1><pre><code class="cpp">#include &ltiostream&gt#include &ltvector>#include &ltqueue>#include &ltcstring>#include &ltalgorithm>using namespace std;// 상어 구조체struct fish {    int r;    int c;    // 현재 사이즈를 표시    int size;    // 몇 마리를 잡아 먹었는지 표시    int eat;    // 이동한 시간을 표시    int time;};int N;int dr[4] = {-1, 0, 1, 0};int dc[4] = {0, 1, 0, -1};int map[21][21];int visited[21][21];queue&ltfish> q;vector&ltfish> v;// 문제 조건에 맞는 비교연산bool cmp(fish a, fish b) {    // 가장 짧은 시간    if (a.time &lt= b.time) {        // 시간이 같을 경우        if (a.time == b.time) {            // y값이 더 작은 순서            if (a.r &lt= b.r) {                // y값이 같다면                if (a.r == b.r) {                    // x값이 작은 순서로 정렬                    if (a.c < b.c) {                        return true;                    }                    return false;                }                return true;            }            return false;        }        return true;    }    return false;}int main() {    cin >> N;    // 이전 상어의 상태를 저장    fish ex;    for (int r = 0; r < N; r++) {        for (int c = 0; c < N; c++) {            cin >> map[r][c];            if (map[r][c] == 9) {                // 시작 위치를 설정                map[r][c] = 0;                // 물고기 초기화                ex = {r, c, 2, 0, 0};            }        }    }    // 시간 정보    int ans = 0;    while (1) {        v.clear();        memset(visited, 0, sizeof(visited));        visited[ex.r][ex.c] = 1;        q.push(ex);        while (!q.empty()) {            int r = q.front().r;            int c = q.front().c;            int size = q.front().size;            int eat = q.front().eat;            int time = q.front().time;            q.pop();            // 4방향으로 검사를 진행            for (int i = 0; i < 4; i++) {                int nr = r + dr[i];                int nc = c + dc[i];                if (nr >= 0 && nr < N && nc >= 0 && nc < N) {                    // 맵 사이즈가 유효하고 방문하지 않은 지역                    if (!visited[nr][nc]) {                        // 사이즈가 같은 상어이거나 길인 경우                        if (map[nr][nc] == 0 || map[nr][nc] == size) {                            // 방문 처리                            visited[nr][nc] = 1;                            // 시간만 추가하고 계속 작은 상어를 찾음                            q.push({nr, nc, size, eat, time + 1});                        }                         // 만약 작은 상어가 있다면                        else if (map[nr][nc] < size) {                            // 방문 처리                            visited[nr][nc] = 1;                            // 잡아 먹은 상어와 시간을 표시하고 벡터에 따로 저장                            v.push_back({nr, nc, size, eat + 1, time + 1});                        }                    }                }            }        }        // 만약 벡터가 비어있다면 잡아 먹을수 있는 상어가 없음        if (v.size() == 0) {            break;        }        // cmp 조건에 맞춰 정렬        sort(v.begin(), v.end(), cmp);        // 먹은 상어의 숫자가 현재 사이즈와 같다면 사이즈 증가        if (v[0].size == v[0].eat) {            v[0].size++;            v[0].eat = 0;        }        // 잡어 먹은 상어를 지움        map[v[0].r][v[0].c] = 0;        // 움직인 시간을 저장        ans += v[0].time;        // 시간을 초기화하고 다시 큐에 넣어 이전 과정을 반복        ex = {v[0].r, v[0].c, v[0].size, v[0].eat, 0};    }    cout << ans;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/16236&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
      <category term="computer science" scheme="http://DongyeolLee.github.io/categories/computer-science/"/>
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/"/>
    
      <category term="problems" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"/>
    
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/tags/algorithms/"/>
    
  </entry>
  
  <entry>
    <title>백준[9205] - 맥주 마시면서 걷기</title>
    <link href="http://DongyeolLee.github.io/2018/10/12/Al/9205/"/>
    <id>http://DongyeolLee.github.io/2018/10/12/Al/9205/</id>
    <published>2018-10-12T08:13:59.000Z</published>
    <updated>2019-04-30T07:24:41.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p><a href="https://www.acmicpc.net/problem/9205" target="_blank" rel="noopener"><strong><em>백준 9205 문제 보기</em></strong></a></p><h1 id="접근-방법"><a href="#접근-방법" class="headerlink" title="접근 방법"></a>접근 방법</h1><p>문제를 이해하기 힘들었다. 하지만 결론은 20병의 맥주를 다 마시기 전에 다른 편의점을 도착할 수 있는지의 여부, 그리고 도착지에 갈 수 있는지를 확인하면 된다.</p><ul><li>맥주 20개로 갈 수 있는 거리는 1000이다. 따라서 출발지로 부터 1000이내 편의점 또는 목적지가 있는지 검사한다.</li></ul><h1 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h1><pre><code class="cpp">#include &ltiostream&gt#include &ltvector>#include &ltutility>#include &ltcstring>#include &ltcmath>#include &ltalgorithm>using namespace std;int T, N;string ans;vector&ltpair&ltint, int>> dist;int visited[105];// 거리 측정bool get_distance(int x1, int y1, int x2, int y2) {    int diff = abs(x1 - x2) + abs(y1 - y2);    return (diff &lt= 1000)? true : false;}void dfs(int idx) {    if(idx == N + 1) {        ans = "happy";        return;    }    for(int i = 1; i < N + 2; i ++) {        if(!visited[i]) {            // 거리 확인            if(get_distance(dist[idx].first, dist[idx].second, dist[i].first, dist[i].second)) {                visited[i] = 1;                // 이동                dfs(i);            }        }    }}int main() {    cin >> T;    for(int t = 1; t &lt= T; t ++) {        cin >> N;        ans = "sad";        dist.clear();        memset(visited, 0, sizeof(visited));        for(int i = 0; i < N + 2; i ++) {            int num1, num2;            cin >> num1 >> num2;            dist.push_back({num1, num2});        }        dfs(0);        cout << ans << endl;    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/9205&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
      <category term="computer science" scheme="http://DongyeolLee.github.io/categories/computer-science/"/>
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/"/>
    
      <category term="problems" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"/>
    
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/tags/algorithms/"/>
    
  </entry>
  
  <entry>
    <title>백준[2668] - 숫자고르기</title>
    <link href="http://DongyeolLee.github.io/2018/10/09/Al/2668/"/>
    <id>http://DongyeolLee.github.io/2018/10/09/Al/2668/</id>
    <published>2018-10-09T13:19:53.000Z</published>
    <updated>2019-04-30T07:24:41.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p><a href="https://www.acmicpc.net/problem/2668" target="_blank" rel="noopener"><strong><em>백준 2668 문제 보기</em></strong></a></p><h1 id="접근-방법"><a href="#접근-방법" class="headerlink" title="접근 방법"></a>접근 방법</h1><p>문제에서 요구하는 조건을 만족하려면 주어진 숫자들이 사이클을 이루는지 확인하고 사이클 갯수를 출력하면 된다.</p><h1 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h1><pre><code class="cpp">#include &ltiostream&gt#include &ltalgorithm>#include &ltvector>#include &ltutility>#include &ltset>using namespace std;int N;int arr[101];int visited[101];vector&ltpair&ltint, int>> temp_arr;set<int> s_idx;void dfs(int idx) {    // 다음 방문할 곳    int next = arr[idx];    // 방문했다면 사이클이 존재    if(visited[next] == 1) {        // 사이클이 존재하는 idx만 따로 저장        for(int i = next; visited[i] != -1; i = arr[i]) {            temp_arr.push_back({idx, i});            idx = i;            visited[i] = -1;        }        return;    }    else if(visited[next] == -1 || visited[next] == 0) {        visited[next] = 1;        dfs(next);        visited[next] = -1;    }}int main() {    cin >> N;    // 1 ~ N까지 숫자    for(int i = 1; i &lt= N; i ++) {        // i는 1부터 시작        cin >> arr[i];    }    for(int i = 1; i &lt= N; i ++) {        temp_arr.clear();        // 방문 체크        visited[i] = 1;        // 사이클 확인        dfs(i);        visited[i] = -1;        // 중복 제거        for(int t = 0; t < temp_arr.size(); t ++) {            s_idx.insert(temp_arr[t].first);        }    }    cout << s_idx.size() << endl;    for (auto s1 = s_idx.begin(); s1 != s_idx.end(); s1++) {        cout << *s1 << endl;    }    return 0;}</int></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2668&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
      <category term="computer science" scheme="http://DongyeolLee.github.io/categories/computer-science/"/>
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/"/>
    
      <category term="problems" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"/>
    
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/tags/algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Command Pattern(커맨드 패턴)</title>
    <link href="http://DongyeolLee.github.io/2018/09/25/Design%20Pattern/CommandPattern/"/>
    <id>http://DongyeolLee.github.io/2018/09/25/Design Pattern/CommandPattern/</id>
    <published>2018-09-25T06:36:45.000Z</published>
    <updated>2019-04-30T07:24:41.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="들어가기"><a href="#들어가기" class="headerlink" title="들어가기"></a>들어가기</h1><p>이번 포스팅에서는 <strong><code>커맨드 패턴(Command Pattern)</code></strong> 에 대해서 알아보겠습니다.</p><h1 id="본론"><a href="#본론" class="headerlink" title="본론"></a>본론</h1><h2 id="1-커맨드-패턴이란-무엇인가"><a href="#1-커맨드-패턴이란-무엇인가" class="headerlink" title="1. 커맨드 패턴이란 무엇인가"></a>1. 커맨드 패턴이란 무엇인가</h2><p><strong><code>커맨드 패턴(Command Pattern)</code></strong>은 특정 행위(기능)을 캡슐화하여 클래스를 변경하지 않고 재사용할때 유용하게 사용합니다.</p><p>즉, 요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록 매서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴입니다.</p><p>말로는 많이 어려우니 밑에서 예시를 통해 <strong><code>커맨드 패턴(Command Pattern)</code></strong>을 사용하지 않았을때 발생하는 문제점과 <strong><code>커맨드 패턴(Command Pattern)</code></strong>을 사용했을때 얻는 이점을 다시 한번 확인해보겠습니다. </p><h2 id="2-왜-커맨드-패턴을-사용해야-하는가"><a href="#2-왜-커맨드-패턴을-사용해야-하는가" class="headerlink" title="2. 왜 커맨드 패턴을 사용해야 하는가"></a>2. 왜 커맨드 패턴을 사용해야 하는가</h2><p>한 가지 예를 들어겠습니다. 버튼이 두개 있는 리모컨이 있습니다. 하나는 Turn On, 다른 한 가지는 Turn Off 입니다. 하지만 이 리모컨은 만능 리모컨이기에 TV, 에어컨 등 모든 전자 기기를 끌수 있고 킬수 있다고 가정하겠습니다.</p><p>이때 어떤 전자 기기는 전원을 키고 끌때 내부적으로 모든 로직이 똑같을 수도 있고 다를 수도 있습니다. <strong>즉, 이전 코드를 재사용 할 수도 있고 완전히 새로 구현해야 할 수도 있습니다.</strong></p><p>이럴 경우 <strong><code>커맨드 패턴(Command Pattern)</code></strong>을 사용하면 기능 자체를 추상화하여 재사용성을 높이고 메서드를 직접 호출하지 않으면서 수정할 부분을 최소화 시킬수 있습니다.</p><h2 id="3-예시"><a href="#3-예시" class="headerlink" title="3. 예시"></a>3. 예시</h2><p><strong><code>커맨드 패턴(Command Pattern)</code></strong>의 필요성에서 보았듯이 만능 리모콘을 만들어보며 패턴을 적용하지 않았을 경우 문제점을 알아보겠습니다.</p><p>간략한 예시를 위해 turn on만 가정해서 코드를 작성하겠습니다.</p><h3 id="3-1-커맨드-패턴을-적용하지-않았을-경우"><a href="#3-1-커맨드-패턴을-적용하지-않았을-경우" class="headerlink" title="3.1 커맨드 패턴을 적용하지 않았을 경우"></a>3.1 커맨드 패턴을 적용하지 않았을 경우</h3><pre><code class="java">public class Lamp {    public void turnOn() {        System.out.println("Turn On");    }}public class Button {    private Lamp theLamp;    public Button(Lamp theLamp) {        this.theLamp = theLamp;    }    public void pressed() {        theLamp.turnOn();    }}public class Client {    public static void main(String[] args) {        Lamp lamp = new Lamp();        Button remote = new Button(lamp);        remote.pressed();    }}</code></pre><p>위에서 작성한 코드는 전등을 키는 간단한 코드입니다. 작동하는데는 문제가 없어 보입니다.</p><p>하지만 몇가지 문제점를 확인할 수 있습니다.</p><ul><li>같은 코드를 사용하면서 전등이 아닌 TV나 알람을 키는 기능을 추가할 경우</li><li>버튼을 누르는 횟수에 따라 다른 기능을 수행해야 할 경우</li></ul><p>첫 번째 문제점을 먼저 확인해보겠습니다. 위에 예시에서 볼수 있듯이 TV 클래스를 작성하는 것만으로 그치지 않고 기존 Button 클래스 코드를 수정해야 합니다. <strong>이는 이전 포스팅에서 확인했듯이 OCP에 위배됩니다.</strong></p><p>즉, 버튼을 눌렀을 때 지정된 기능만 고정적으로 수행하도록 만든 처음과 같은 설계는 기능이 추가될 때마다 여러 클래스를 수정해야하기에 OCP를 위반하는 설계입니다.</p><p>두 번째 경우의 문제점을 확인해보겠습니다. </p><p>예를 들어 버튼을 처음 눌렀을 때는 램프를 켜고 두 번 눌렀을 때는 알람을 동작하게 할 경우에 Button 클래스는 2가지 기능을 모두 구현할 수 있어야 합니다. </p><pre><code class="java">enum Mode {LAMP, ALARM};public class Lamp {  public void turnOn() {      System.out.println("Turn On");  }}public class Alarm {  public void start() {      System.out.println("Alarming");  }}public class Button {    private Lamp theLamp;    private Alarm theAlarm;    private Mode theMode;    public Button(Lamp theLamp) {        this.theLamp = theLamp;        this.theAlarm = theAlarm;    }    public void setMode(Mode mode) {        this.theMode = mode;    }    public void pressed() {        swhitch(theMode) {            case LAMP:                theLamp.turnOn();                break;            case ALARM:                theAlarm.start();                break;        }    }}</code></pre><p>이 경우 역시 버튼을 눌렀을 때의 기능을 변경하기 위해 다시 Button 클래스의 코드를 수정해야합니다.</p><p>즉, OCP를 위배할 뿐더러 Button 클래스를 재사용하기 어렵습니다.</p><h3 id="3-2-커맨드-패턴을-적용한-경우"><a href="#3-2-커맨드-패턴을-적용한-경우" class="headerlink" title="3.2 커맨드 패턴을 적용한 경우"></a>3.2 커맨드 패턴을 적용한 경우</h3><p>새로운 기능을 추가하거나 변경하더라도 Button 클래스를 그대로 사용하려면 Button 클래스에 pressed 메서드에서 구체적인 기능을 직접 구현하는 대신 버튼을 눌렀을 때 실현될 기능을 클래스 외부에서 제공받아 캡슐화하여 호출하는 방법을 사용할 수 있습니다.</p><p><img src="/images/DesignPattern/4/1.png" width="600"></p><p>클래스 다이어그램을 보면 turnOn 메서드나 start 메서드를 직접 호출하지 않고 추상화하여 호출하고 있습니다.</p><pre><code class="java">public interface Command {    public abstract void execute();}public class Alarm {    public void start() {        System.out.println("Alarming ... ");    }}public class Lamp {    public void turnOn() {        System.out.println("Lamp On");    }}public class AlarmOnCommand implements Command {    private Alarm theAlarm;    public AlarmOnCommand(Alarm theAlarm) {        this.theAlarm = theAlarm;    }    @Override    public void execute() {        theAlarm.start();    }}public class LampOnCommand implements Command {    private Lamp theLamp;    public LampOnCommand(Lamp theLamp) {        this.theLamp = theLamp;    }    @Override    public void execute() {        theLamp.turnOn();    }}public class Button {    private Command theCommand;    public Button(Command theCommand) {        setTheCommand(theCommand);    }    public void setTheCommand(Command theCommand) {        this.theCommand = theCommand;    }    public void pressed() {        theCommand.execute();    }}</code></pre><p>보시는 바와 같이 Command 인터페이스를 구현하는 LampOnCommand와 AlarmCommand 객체를 Button 객체에 설정하여 버튼을 눌렀을 때 필요한 임의의 기능은 Command 인터페이스를 구현한 클래스의 객체를 Button 객체에 설정해서 실행할 수 있습니다.</p><p>즉, 실행될 기능을 캡슐화함으로써 호출자(Invoker)와 실제 기능을 실행하는 수신자(Receiver) 클래스 사이의 의존성을 제거합니다. 따라서 실행될 기능의 변경에도 호출자 클래스를 수정 없이 그대로 사용할 수 있도록 해줍니다.</p><ul><li>Command : 실행될 기능을 execute 메서드로 선언함</li><li>ConcreteCommand : 실제로 실행되는 기능을 구현</li><li>Invoker : 기능의 실행을 요청하는 호출자(Button)</li><li>Receiver : Concrete Command의 기능을 실행하기 위해 사용하는 수신자 클래스</li></ul><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h1><p><strong><code>커맨드 패턴(Command Pattern)</code></strong>의 개념과 관련해 추가적인 질문이나 오류, 오타가 있을시 댓글로 남겨주세요.</p><h1 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h1><p>JAVA 객체지향 디자인패턴</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;들어가기&quot;&gt;&lt;a href=&quot;#들어가기&quot; class=&quot;headerlink&quot; title=&quot;들어가기&quot;&gt;&lt;/a&gt;들어가기&lt;/h1&gt;&lt;p&gt;이번 포스팅에서는 &lt;strong&gt;&lt;code&gt;커맨드 패턴(Command Pattern)&lt;/code&gt;&lt;/strong
      
    
    </summary>
    
      <category term="design pattern" scheme="http://DongyeolLee.github.io/categories/design-pattern/"/>
    
      <category term="java" scheme="http://DongyeolLee.github.io/categories/design-pattern/java/"/>
    
    
      <category term="java" scheme="http://DongyeolLee.github.io/tags/java/"/>
    
      <category term="design pattern" scheme="http://DongyeolLee.github.io/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>백준[1389] - 케빈 베이컨의 6단계 법칙</title>
    <link href="http://DongyeolLee.github.io/2018/09/25/Al/1389/"/>
    <id>http://DongyeolLee.github.io/2018/09/25/Al/1389/</id>
    <published>2018-09-24T16:02:03.000Z</published>
    <updated>2019-04-30T07:24:41.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p><a href="https://www.acmicpc.net/problem/1389" target="_blank" rel="noopener"><strong><em>백준 1389 문제 보기</em></strong></a></p><h1 id="접근-방법"><a href="#접근-방법" class="headerlink" title="접근 방법"></a>접근 방법</h1><p>유저의 숫자가 주어진다면 각 유저들간 친구 관계를 파악하기 위해 모든 유저를 상대로 dfs 탐색을 진행한다.</p><ul><li>유저 1과 나머지 유저들 간의 친구 관계를 계산하기 위해 유저 1 대상으로 연결 요소를 완전 탐색하고 거리차를 증가한다.  </li><li>각 친구들까지의 거리차를 cnt 배열에 따로 저장한다.</li><li>탐색이 완료되면 총 거리를 계산한다.</li><li>cnt 배열을 초기화하고 다음 유저에 대해서 위의 과정을 반복한다.</li></ul><h1 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h1><pre><code class="cpp">#include &ltiostream&gt#include &ltvector>#include &ltcstring>#include &ltalgorithm>using namespace std;int N, M, person = 101, ans = 987654321;int cnt[101];vector&ltvector&ltint>> relation(101);// diff: 지정된 친구로부터 거리차, num: 친구 번호void dfs(int diff, int num) {    // cnt[num]에 거리차를 저장    if(cnt[num] != 0) {        cnt[num] = min(diff, cnt[num]);    } else {        cnt[num] = diff;    }    // 연결된 친구 모두 탐색    for(int j = 0; j < relation[num].size(); j ++) {        int next = relation[num][j];        // 친구를 포함하지 않았거나 더 가까운 사이의 친구라면 탐색        if(cnt[next] == 0 || cnt[next] > diff + 1 ) {            dfs(diff + 1, next);        }    }}int main() {    cin >> N >> M;    for(int i = 0; i < M; i ++) {        int from, to;        cin >> from >> to;        // 양방향 저장        relation[from].push_back(to);        relation[to].push_back(from);    }    for(int i = 1; i &lt= N; i ++) {        // 친구들과의 거리차 초기화        memset(cnt, 0, sizeof(cnt));        for(int j = 0; j < relation[i].size(); j ++) {            dfs(1, relation[i][j]);        }        int temp = 0;        for(int j = 1; j &lt= N; j ++) {            if(j == i) {                continue;            }            temp += cnt[j];        }        // 최소인지 검사        if(ans > temp) {            ans = temp;            person = i;        }        else if(ans == temp) {            person = min(person, i);        }    }    cout << person;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1389&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
      <category term="computer science" scheme="http://DongyeolLee.github.io/categories/computer-science/"/>
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/"/>
    
      <category term="problems" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"/>
    
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/tags/algorithms/"/>
    
  </entry>
  
  <entry>
    <title>백준[6603] - 로또</title>
    <link href="http://DongyeolLee.github.io/2018/09/23/Al/6603/"/>
    <id>http://DongyeolLee.github.io/2018/09/23/Al/6603/</id>
    <published>2018-09-23T06:54:18.000Z</published>
    <updated>2019-04-30T07:24:41.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p><a href="https://www.acmicpc.net/problem/6603" target="_blank" rel="noopener"><strong><em>백준 6603 문제 보기</em></strong></a></p><h1 id="접근-방법"><a href="#접근-방법" class="headerlink" title="접근 방법"></a>접근 방법</h1><p>숫자가 주어지면 중복없이 6자리 숫자를 만들고 출력하면 된다.<br>ans 배열에 선택한 숫자를 저장한다. 숫자를 선택할때는 다음과 같은 규칙을 따른다.</p><ul><li>ans의 첫번째 숫자는 모든 숫자의 범위에서 선택한다.</li><li>ans의 두번째 숫자는 이전 선택한 수 보다 +1한 범위에서 숫자를 선택한다.<br> (ex. 숫자가 1 ~ 10까지 주어졌을때 첫번째 숫자로 3을 선택했다면 두번째 선택할 숫자의 범위를 4 ~ 10으로 한정한다.)</li><li>이후 3번째 숫자를 선택할때는 규칙 2를 반복한다.</li></ul><h1 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h1><pre><code class="cpp">#include &ltiostream&gt#include &ltvector>using namespace std;int K;int ans[6];vector&ltint> v;// depth: 숫자의 길이, num: 선택할 숫자void dfs(int depth, int num) {    // 6자리면 출력    if(depth == 6) {        for(int i = 0; i < 6; i ++) {            cout << ans[i] <<  " ";        }        cout << '\n';        return;    }    for(int start = num; start < K; start ++) {        ans[depth] = v[start];        dfs(depth + 1, start + 1);        ans[depth] = -1;    }}int main() {    while(1) {        cin >> K;        v.clear();        // 0이면 종료        if(K == 0)            break;        for(int i = 0; i < K ; i ++) {            int num;            cin >> num;            // 숫자를 모두 벡터에 저장            v.push_back(num);        }        dfs(0, 0);        cout << '\n';    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/6603&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
      <category term="computer science" scheme="http://DongyeolLee.github.io/categories/computer-science/"/>
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/"/>
    
      <category term="problems" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"/>
    
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/tags/algorithms/"/>
    
  </entry>
  
  <entry>
    <title>백준[1051] - 숫자 정사각형</title>
    <link href="http://DongyeolLee.github.io/2018/09/18/Al/1051/"/>
    <id>http://DongyeolLee.github.io/2018/09/18/Al/1051/</id>
    <published>2018-09-18T14:18:02.000Z</published>
    <updated>2019-04-30T07:24:41.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p><a href="https://www.acmicpc.net/problem/1051" target="_blank" rel="noopener"><strong><em>백준 1051 문제 보기</em></strong></a></p><h1 id="접근-방법"><a href="#접근-방법" class="headerlink" title="접근 방법"></a>접근 방법</h1><p>입력된 이차원 배열의 숫자들을 모두 순회하며 순차적으로 정사각형을 만들어 본다.</p><h1 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h1><pre><code class="cpp">#include &ltiostream&gt#include &ltalgorithm>using namespace std;int N, M, ans = 0;char map[51][51];int main() {    cin >> N >> M;    for(int r = 0; r < N; r ++) {        for(int c = 0; c < M; c ++) {            scanf(" %c", &map[r][c]);        }    }    // 입력된 사각형의 변 중에 작은 값을 저장    int num = min(N, M);    // 모든 점을 순회하며 정사각형을 조회    for(int r = 0; r < N; r ++) {        for(int c = 0; c < M; c ++) {            // 만들수 있는 가장 큰 정사각형까지 만듬            for(int len = 0; len < num; len ++) {                if(r + len < N && c + len < M) {                    char s1 = map[r][c];                    char s2 = map[r + len][c];                    char s3 = map[r][c + len];                    char s4 = map[r + len][c + len];                    if((s1 == s2) && (s3 == s4) && (s1 == s3) && (s1 == s4) && (s2 == s3) && (s2 == s4) && (s3 == s4)) {                        // 사이즈 저장                        ans = max(ans, (len + 1) * (len + 1));                    }                }            }        }    }    cout << ans;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1051&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
      <category term="computer science" scheme="http://DongyeolLee.github.io/categories/computer-science/"/>
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/"/>
    
      <category term="problems" scheme="http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"/>
    
    
      <category term="algorithms" scheme="http://DongyeolLee.github.io/tags/algorithms/"/>
    
  </entry>
  
</feed>
