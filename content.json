{"meta":{"title":"Dy:1992","subtitle":"Dy's 포크레인 삽질기","description":null,"author":"Dy","url":"http://DongyeolLee.github.io"},"pages":[],"posts":[{"title":"2018년도 LINE(라인) 채용 - 서류부터 최종면접까지 후기","slug":"Review/line","date":"2019-08-15T06:32:24.000Z","updated":"2019-08-15T08:42:11.126Z","comments":true,"path":"2019/08/15/Review/line/","link":"","permalink":"http://DongyeolLee.github.io/2019/08/15/Review/line/","excerpt":"","text":"들어가기지난 NHN(NHN 엔터테인먼트)에 이어 라인에 지원하면서 간략하게 전형 및 느낌점을 정리해본다. 서류 평가라인 역시 IT 회사답게 어마 무시한 내용을 적는 자기소개서는 아니었다. 단지 어떤 활동을 했는지, 프로젝트 진행 여부를 묻는 듯한 질문이 많았다. 문항은 다음과 같았다. 자신을 자유롭게 소개해 주세요.(제한 없음) 학교 수업이나 대외활동 등을 통해 경험한 프로젝트를 적어주세요. 프로젝트에서 맡았던 역할과 활용한 기술 및 개발 방식, 진행하면서 겪었던 어려움이나 이를 극복한 방법 등도 함께 설명해주세요.(제한 없음) LINE에서 왜 자신을 채용해야 하는지, 자신의 경쟁력에 대해 구체적으로 적어주세요.(제한 없음) 당시 개발 직군은 Server, Client, Game, Security로 지원이 가능했다. 당시 제일 어려웠던 문항이 개인적으로 1번 문항과 3번 문항이었다. 어떻게 작성할 수 있을까 고민이 많았다. 자기소개서 문항 1번에는 학부 시절 공부했던 내용과 ‘내가 왜 개발 분야에 흥미를 느끼게 됐는지’를 주로 피력했다. 그리고 3번 문항에는 입사 후 가질 마음가짐과 나의 장점을 주로 쓰는 것으로 마무리했다. 참고로 프로젝트를 적는 문항에는 내가 어떤 프로젝트를 했는지는 많이 작성하지 않았다. 프로젝트 개요는 최대한 단순하게 설명했다. 그보다 어떤 라이브러리를 썼고, 왜 그 라이브러리를 사용했는지, 또 어디서 많은 시간을 들여 개발했는지를 위주로 썼다. 온라인 필기 시험 시험은 토요일 오전 Goorm으로 테스트를 진행했다. 라인 온라인 시험은 알고리즘 + 전공 기반 문제였다 알고리즘 4~5문제 전공 필기가 20문제 내외였다. 전공 필기 문제는 0,X 문항과 모두 고르는 객관식이 섞여 있는 문제였고 알고리즘 역시 구현에서부터 탐색까지 다양하게 나왔다. 10시에 딱 맞춰 시험이 시작됐다. 근데 웃긴 게 Goorm으로 알고리즘 시험을 보던 중, 사이트가 폭발했다. 그래서 시험 20분? 만에 온라인 알고리즘 시험을 취소한다는 이메일을 받았다. 온라인 필기시험은 전공 점수로만 평가하고 알고리즘은 추후 오프라인 시험에서 다시 진행한다고 공지했다. 당시 사이트 문제로 알고리즘 시험을 진행할 수 없다고 했다. 이후 다시 시간에 맞춰 전공 시험을 봤는데 이 역시 상당히 어려웠다. 근데 라인은 찍으면 감점된다는 이야기가 있어 찍지도 못하고 울며 겨자 먹기로 아는 것만 열심히 풀었다. 워낙 어려워서 커트 라인이 어느 정도에서 형성될지도 감이 안 왔다. 정말 학부 시절 배운 모든 것을 물어보는 듯한 느낌이 강했다. 주로 네트워크, DB, OS, 컴퓨터 구조가 대부분이라 그 위주로 준비했으나 모르는 문제도 많았다. 전공 시험도 어려워 ‘망했다’라는 생각이 지배적이었다. 그냥 여기서 라인은 보내줘야겠다고 생각했다. 오프라인 필기 시험 합격 메일을 받고 많이 당황했다. 메일이 잘 못 왔다는 생각까지 했다. 내가 왜 붙었지 의아했지만, 기분은 좋았다. 근데 막상 다시 볼 시험을 생각하니 걱정이 이만저만 아니었다. 2주 정도 여유가 있어 이전에 준비했던 것처럼 주로 OS, 알고리즘, 컴퓨터 구조, 네트워크, DB 등을 공부하며 오프라인 시험을 준비했다. 시험은 역삼역 근처에 있는 멀티캠퍼스에서 진행됐다. 내가 도착했을 당시 나 말고 응시자가 상당히 많아 어차피 떨어질 거 편하게 보자는 생각을 가졌다. 먼저 저번에 취소된 알고리즘 시험부터 2시간 가량 봤던 거로 기억한다. 문제는 4문제였고 배점이 다 달랐던 거로 기억한다. 당연히 온라인으로 봤던 문제와는 다른 문제들이 출제됐고 유형은 약간 비슷했다. 이어서 1시간 정도 전공시험을 쳤다. 컴퓨터로 작성하는 시험이었고 문제도 10문제 정도였다. 여기서 살짝 당황한 게 전공 문제가 아닌 약간 실제 프로젝트를 진행하면서 겪을 수 있는 문제? 를 위주로 나왔던 것 같다. JAVA 관련 깊은 질문, 남이 작성한 코드를 보고 빈칸 채워 넣어 프로그램 작동시키기 같은 문제가 많았다. 당연히 모든 문제가 서술형이었고 모르면 찍지도 못하는 문제들이었다. 시험을 끝내고 나오면서 같이 본 친구들과 시험에 관해 이야기했다. 대체로 알고리즘은 비슷한 수준으로 풀었던 것 같다. 1 ~ 2.5 문제?? 정도가 우리들의 평균이었다. 근데 배점이 다 달라서 예상할 수가 없었다. 전공 시험은 전혀 내가 어느 정도 인지 감도 오지 않았지만 그래도 모르는 문제도 최대한 주워들은 지식으로 작성하려고 노력했다. 그래도 친구들보다 전공 시험은 뭔가 잘 본 듯한 느낌이었지만 안심할 수 없었다. 1차 면접 다행히 합격 통보를 받을 수 있었다. 서술형 같은 경우는 어떻게 채점을 다 했는지 모르겠지만 합격해서 다행이었다. 라인 1차 면접에 관해서는 아는 정보가 많이 없어 어떻게 준비를 해야 할지 걱정이 앞섰다. 일단 자소서 기반으로 면접을 준비하되, 기본적인 전공 질문을 받을 수 있기에 전공 공부도 같이 진행하기로 했다. 1차 면접은 라인 판교 오피스에서 본다고 안내 메일에 적혀있었다. 면접 시간보다 30분 먼저 도착해 대기실에 앉아 있으면서 긴장하지 않으려 노력했다. 면접은 명시된 대로 딱 50분 진행됐다. 뭔가 폭풍이 지나간 느낌이었다. 자소서에 적은 프로젝트를 기반으로 질문을 많이 받았다. 왜 이게 어려웠는지, 문제 해결은 어떻게 했는지, 그게 최선책이었는지, 지금 생각해볼 때의 다른 방법은 어떤 게 있을지 프로젝트 관련해서는 대부분 저런 질문이었다. 또 프로젝트 관련해서 응용 질문도 많았다. 제약 사항을 주고 이럴 경우 어떻게 해결할 수 있는지 물어봤다. 문제 해결력을 보려고 하는 건가? 정답인지는 모르겠지만 내가 생각하는 방안을 제시하면서 답변했다. 물론 중간중간 모르는 부분이 상당히 많았다. 근데 틀린 대답을 하는 것보다는 모르는 건 진짜 모르겠다고 답했다. 뭔가 깔끔하지는 않지만, 엄청나게 잘 본 느낌도 아닌 그런 면접이었다. 2차 면접 드디어 마지막 관문까지 왔다. 1차 면접을 준비했던 것처럼 2차 면접을 준비했다. 더 깊이 있게 공부하기보다는 1차 면접에서 답 못했던 내용을 정리해 준비했다. 2차 면접은 라인 서현 오피스에서 봤다. 집에서 서현까지 상당히 멀었지만 그래도 면접이 오후 4시정도여서 다행이었다. 그리고 기억하기로는 1차 면접 합격한 뒤 지원했던 분야인 Server에서 어디로 배치받고 싶은지 설문도 했다. 2차 면접 역시 50분 정도 이어졌고 1차와 비슷한 느낌이었다. 근데 뭔가 더 응용적인 질문도 많았다. 또 제약 상황을 많이 만들어 문제 해결력을 더 보는 듯한 느낌이었다. 1차 면접에서 답 못했던 부분을 다시 질문하고 나의 생각을 물어보기도 했다. 찾아보고 가길 잘했다. 근데 2차 면접의 전체적인 느낌은 너무 부정적이었다. 1차 면접보다 모르겠다고 답한 부분이 상당히 많았고 특히 전공 관련해서 깊게 물어볼 때 모르겠다고 답한 게 많아 아쉬웠다. 가장 당황했던 부분은 내가 사용한 언어에 있어 구동 방식에 문제점이 있었는데 그게 왜 문제일 것 같냐는 질문이었다. 너무 당황했다. 내가 대략 설명하고 잘 모르겠다고 하자 면접관이 그럼 우리 같이 추측해보자고 하면서 노트를 들이밀고 그림을 그리면서 설명해보라고 했다. 그냥 아는 부분만 대충 설명했다. 면접관 역시 뜨뜻미지근한 표정으로 알겠다고 한 뒤 넘어갔다. 라인은 면접이 매우 어려웠다. 다른 기업 면접보다 확실히 더 어렵게 느껴졌다.","categories":[{"name":"review","slug":"review","permalink":"http://DongyeolLee.github.io/categories/review/"},{"name":"job","slug":"review/job","permalink":"http://DongyeolLee.github.io/categories/review/job/"}],"tags":[{"name":"review","slug":"review","permalink":"http://DongyeolLee.github.io/tags/review/"},{"name":"recruiting","slug":"recruiting","permalink":"http://DongyeolLee.github.io/tags/recruiting/"},{"name":"job","slug":"job","permalink":"http://DongyeolLee.github.io/tags/job/"}]},{"title":"2018년도 NHN 채용 - 서류부터 최종면접까지 후기","slug":"Review/nhn","date":"2019-05-23T12:44:48.000Z","updated":"2019-08-25T12:47:20.820Z","comments":true,"path":"2019/05/23/Review/nhn/","link":"","permalink":"http://DongyeolLee.github.io/2019/05/23/Review/nhn/","excerpt":"","text":"들어가기지난 번 11번가 후기에 이어서 이번에는 NHN(NHN 엔터테인먼트)의 후기를 생각나는대로 써보려한다. 서류 평가NHN은 서류 평가가 그렇게 어렵지 않다고 어디서 주워 들은 것 같다. 실제로 주변 많은 사람들이 서류를 합격했다. 문항 역시 2개로 심플했다. 재학 중 가장 자신 있는 전공과목을 적고(최대 3가지), 그 이유를 설명해주세요.(제한 없음) 가장 자신있는 프로그래밍 언어를 사용하여 성취한 대표적인 프로젝트 또는 개발산출물 한 가지를 설명해주세요. 그리고 개발과정에서 가장 중요하게 생각한 것은 무엇인지 설명해주세요.(제한 없음) 정말 부담없이 자기소개서를 작성했던 걸로 기억한다. SW 개발 직군에 지원하면서 이전 자소서와 비슷한 문항이였기에 작성하는데는 크게 어려움이 없었다. 그리고 글자수 역시 그렇게 많이 채우지는 않고 800자, 1300자 정도 작성 후 제출했다. 코딩 테스트 누구나 걱정하는 온라인 코딩 테스트!! 후기도 많이 없고 자료도 없어서 다들 걱정하는 것 같았다. 시험 당시 문제는 4~5문제 였던 걸로 기억한다. 난이도 역시 뒤로 갈수록 까다롭고 오래 걸리는 문제들이 나왔다. 1번과 2번 문제는 비교적 쉬웠던 거로 기억한다. 구조체 정렬과 배열을 이용하는 문제 정도?? 3번은 구현하기 귀찮으면서 예외처리가 많았던 문제로 기억하며 완탐도 1문제 나왔다. 평소 알고리즘을 준비했다면 무난하게 4문제 정도는 풀었지 않았나 싶다. 근데 난 3문제 풀었나?? 시간도 3시간?? 정도 진행했다. 오프라인 필기 시험 NHN 오프라인 필기시험이 많이 어렵다는 후기를 보았기에 나름대로 열심히 준비했다. 운영체제, 네트워크, DB, 자료구조를 중점으로 공부했다. 또 실무적인 것보다는 전공에 관해서 많이 출제된다고 예고를 했기에 그 부분을 중점적으로 봤다. 판교역에 위치한 경기창조혁신센터?? 에서 시험을 봤다. 총 응시자는 약 900명 정도 됐다. 이 사람들을 뚫고 내가 면접을 갈 수 있을까 살짝 겁도 났지만 그래도 시험 보는 데 집중했다. 정말 좁은 책상에 앉아서 문제를 풀었고 2시간 정도 진행했다. 문제는 객관식 + 주관식으로 나왔으며 정말 대학 시험처럼 나왔다. 조금 어려운 용어나 내용 같은 것은 먼저 예시를 주고 풀게 했으며 영어 레퍼런스를 읽고 문제를 해결하는 유형도 있었다. ‘와 엄청 어렵다.’ 이 정도 수준은 아니었으나 헷갈리고 정확하게 모르겠는 문제투성이였다. 객관식에서 주관식 순으로 문제를 풀었고 객관식 약 19문제 중 5문제 정도 찍었던 것 같다. 주관식도 약 소 문제 포함 20문제 정도였는데 약 60% 정도 풀고 나머지는 그냥 느낌에 맡겼다. 시간이 부족하진 않았지만 그렇다고 남지도 않았다. 시험이 끝나고 같이 간 친구들이랑 서로 적은 답을 비교하고 공유하고 설명하면서 갔는데 답이 다 달라서 조금 많이 불안했다. 1차 면접 친구 8명이 같이 필기시험을 봤는데 나만 살아남았다. 뭔가 뿌듯하기도 했는데 1차 면접에서 다시 코딩 테스트를 본다고 해서 살짝 걱정됐다. 1차 면접은 NHN 사옥에서 진행됐고 여기는 복장 제한이 없었다. 또 면접을 보기 위해 아침 9시까지 가야 했는데 도착하니 후드티를 나눠주며 입으라고 했다. 다들 똑같은 옷을 입고 면접을 진행했다. 9시 30분??정도부터 면접 일정이 시작된다. 먼저 알고리즘 문제 풀기를 약 2시간에서 3시간 정도 진행하고 이후 조별로 움직이며 면접 절차를 진행했다. 알고리즘 문제는 온라인 코딩 테스트보다 살짝 더 난도가 있는 듯했다. 사실 난 풀지 못했다. 코딩 테스트가 끝나고 바로 점심을 다 같이 먹는데 입맛도 없었다. 이건 진짜 떨어졌다는 생각이 앞서 밥이 안 들어갔다. 점심 식사가 끝나면 1시 정도부터 회사 사옥 투어 &gt; 오전에 풀었던 코딩 테스트 코드 리뷰 면접 &gt; 기술 면접 &gt; NHN 선배 직원과의 대화가 진행되고 각 일정은 조별로 다르게 진행된다. 나는 사옥 투어 &gt; 선배 NHN 직원과의 대화 &gt; 기술 면접 &gt; 코드 리뷰 순으로 진행되는 조에 편성됐고 먼저 가볍게 사옥 투어를 하면서 긴장을 풀었다. 사옥 투어를 하면서 NHN의 좋은 점을 인사팀에서 잘 설명해줬다. 인사팀이 건물 지하에서 커피도 사주면서 편안한 분위기에서 면접자들과 대화를 했다. 선배 직원과의 대화 시간에는 그냥 궁금한 것들 다 물어보면 대답해주는 시간이었다. 누군가 연봉이 얼마냐, 여기는 보너스 얼마 주냐 이런 걸 물어봤는데 그냥 아무렇지도 않게 대답해주셨다. 여기서부터가 진짜다. 기술 면접의 비중이 가장 크다고 들었기에 오전에 망했던 것을 여기서 만회해야만 했다. 면접관 2명이 앉아 있었고 들어가니 1분 자기소개 이런 것도 없이 쓱 종이 하나를 들이밀었다. 대충 읽어보니 이것도 알고리즘이었다. 읽어보고 손으로 코딩하라고 했고 손 코딩 도중에 약간 이상한 방향으로 가거나 틀린 방향으로 가는 것 같으면 계속 힌트를 던져주셨다. 느끼기에는 어떻게 해결하는지 감이 안 오더라도 면접관들과 커뮤니케이션을 진행하면서 해결해 나아가는 능력을 많이 평가하는 것 같았다. 1시간 정도의 면접 시간 중 25분?? 이지나 손 코딩을 제출했다. “빨리 풀었나?? 된 건가??” 이런 생각을 했지만 아니었다. 다른 문제 하나가 또 있었고 그것은 진짜 수학 문제였다. 고등 수학의 문제 유형은 아니었고 쉬우면서도 어렵다고 느낄 수 있는 문제였으며 규칙성을 찾는 수학 문제였다. 이 역시 면접관들과 대화를 해 나가며 해결하려고 노력했다. 문제를 풀던 중 시간이 다 돼서 면접관이 이 문제는 어떤 문제였는지 설명해주셨고 지금 어디까지 내가 풀었는지 알려주셨다. 그냥 느낌에는 반 정도 풀었던 것 같다. 기술 면접이 끝나고 나와서 다른 면접자들한테 잘 봤는지 물어봤는데 다들 나랑 비슷한 상황이었다. 그리고 마지막으로 오전에 알고리즘을 풀고 제출했던 코드의 코드 리뷰가 남아있었다. 이는 면접관 2명이 면접자 3명의 코드를 보면서 동시에 진행됐다. 한 명당 약 10분 정도 생각한 알고리즘과 어떤 방식으로 풀려고 했는지 설명했다. 나는 문제를 풀지도 못했고 코드가 정상적으로 돌아가지도 않았기에 면접관들한테 내가 생각한 알고리즘은 무엇이고 어떤 자료 구조를 선택헀고 지금 이 코드가 왜 동작하지 않는 것 같은지를 설명했다. 또 개선 방향까지 설명하니 딱 10분 정도가 지났다. 2차 면접 2차 면접은 1차 면접과 달리 짧은 시간 내에 끝났다. 다대다 면접이 진행됐고 면접관 2명, 면접자 3명이었다. 면접에 들어가기 전 30분 정도 4개의 전공 문제를 풀고 면접에 들어갔다. 답이 있는 문제도 있었고 생각을 묻는 문제도 있었다. 2차 면접은 기술과 인성 7 대 3 정도로 진행됐다. 먼저 기술 면접은 풀었던 문제를 화이트보드에 작성하면서 답을 설명하고 왜 그렇게 생각하는지 설명하는 식으로 진행됐다. 답이 있는 문제이지만 틀려도 크게 뭐라 하지 않았다. 면접관이 계속 답을 유도하고 생각을 물어보기 때문에 그냥 면접관의 질문에 대답하다 보면 답이 떠오른다. 즉, 문제를 풀 때는 모를 수도 있지만, 면접관들과 대화를 하다 보면 내가 작성한 답은 이런 오류가 있었다는 것을 깨닫고 수정할 수 있게 된다. 나 역시 틀렸지만 계속 대화를 하면서 작성했던 답의 오류를 발견하고 어떻게 수정할 수 있을지 설명했더니 면접관이 고개를 끄덕였다. 기술 면접이 끝나면 그 자리에서 바로 인성 면접이 진행되는데 이건 정말 다른 회사랑 똑같이 진행된다. 지원동기, 하고 싶은 일 등등 솔직히 1차 면접에서 떨어질 줄 알았지만 어쩌다 보니 내가 2차 면접까지 보고 있었다.","categories":[{"name":"review","slug":"review","permalink":"http://DongyeolLee.github.io/categories/review/"},{"name":"job","slug":"review/job","permalink":"http://DongyeolLee.github.io/categories/review/job/"}],"tags":[{"name":"review","slug":"review","permalink":"http://DongyeolLee.github.io/tags/review/"},{"name":"recruiting","slug":"recruiting","permalink":"http://DongyeolLee.github.io/tags/recruiting/"},{"name":"job","slug":"job","permalink":"http://DongyeolLee.github.io/tags/job/"}]},{"title":"2018년도 11번가 채용 - 서류부터 최종면접까지 후기","slug":"Review/11st","date":"2019-05-21T12:24:11.000Z","updated":"2019-08-25T12:42:38.090Z","comments":true,"path":"2019/05/21/Review/11st/","link":"","permalink":"http://DongyeolLee.github.io/2019/05/21/Review/11st/","excerpt":"","text":"들어가기지금에 와서야 작년(2018) 하반기에 했던 취업 준비 과정을 정리하는 것이 이상한 것 같다. 하지만 이번 정리?? 후기??로 인해 조금이나마 정보를 얻으려는 분들께 도움이 됐으면 한다. 서류 평가11번가 서비스 개발 분야에 지원했다. 역시 sk 회사답게 자기소개서에 써야 하는 내용과 문항이 예사롭지 않았다. 문항들은 다음과 같았다. 본인의 개발 역량을 보여줄 수 있는 대표적 프로젝트 1가지에 대해 구체적으로 기술하고, 다룰수 있는 프로그래밍언어나 기술에 대해 적어주세요.(2000) 지원분야와 관련되어 경험한 활동을 적어주세요.(2000자) 지원분야와 관련성은 없으나 관심을 갖고 있는 영역과 이것을 향상시켜온 경험에 대해 적어주세요.(2000자) 향후 11번가에 입사하게 되면 하고 싶은 업무 영역과 궁극적 본인의 Career Goal은 무엇이며 이유는 무엇인지 적어주세요.(2000자) 총 8000자라니… 아직 그때 상황을 기억한다. 상당히 쓰기 싫어서 미루고 미루다가 결국 이전 자소서를 복사해 붙여넣어서 냈던 걸로… 글자수도 완벽하게 채우지 못했다.대략 1400자, 1900자, 1600자, 900자 정도 썼던 것 같다. 전체적으로 토 나오는 분량이었지만 최대한 관련 경험을 쓰려고 노력했다. 1번 문항에는 스타트업 인턴 당시 수행했던 프로젝트를 이야기하면서 삽질했던 내용을 상세히 썻다. 결국 ‘별거 아니었는데 이런 실수를 했더라’는 느낌으로 썼다. 그리고 내가 왜 그런 실수를 했는지 이로써 얻은 경험은 무엇인지를 적었다. 2번 문항에는 2가지 이야기를 풀어 썼다. 먼저 연합 동아리 활동을 하며 해커톤에 참가한 경험을 썼다. 다른 이야기로 개인 프로젝트를 만들었던 이야기를 쓰면서 내가 왜 개인 프로젝트를 진행했는지를 서술했다. 3번 문항에는 내가 기술 블로그를 시작한 이유와 이로써 얻은 긍정적인 효과를 자기소개서에 담아냈다. 마지막 문항에는 11번가에서 무슨 업무를 수행하고 싶은지 그 업무를 수행하기 위해 어떤 노력을 했는지 어필했다. 더 나아가 해당 업무를 수행하여 어떻게 11번가 기여할 수 있는지를 적었다. 코딩 테스트 특이하게 서류를 제출하고 나면 이메일로 코딩 테스트를 볼 수 있는 URL을 보내줬다. 이메일을 받고 1일?? 3일?? 이내에 코딩 테스트를 제출해야 했다. 문제는 총 4문제로 2시간의 시간이 주어졌다. 문제는 그렇게 어렵지 않았다. 문제가 영어라 당황만 하지 않으면 누구나 풀 수 있는 그런 수준이다. 배열을 sorting 하는 문제, 배열에서 몇 번째 요소를 찾는 문제 약간 이런 형식의 문제가 주를 이뤘다. 그리고 특이하게 SQL을 묻는 문제가 1개 있었는데 이 역시 그렇게 난도가 있다고 생각하지는 않았다. 코딩 테스트를 제출하고 나면 바로 코딩 테스트 점수를 보여준다. 근데 이 결과가 그렇게 합격 여부의 큰 비중을 차지하지 않는 것 같았다. 누구는 100점을 맞고 떨어지는 반면 누구는 50점을 받았는데 서류 합격한 사람들도 있었다. SKCT 좀 걱정을 많이 했던 인·적성 문제였지만 10일? 정도 되는 시간에 2권 정도를 풀고 갔다. 영역당 약 20문제 정도 된다. 이 중 시간 내에 13개는 풀자는 마인드로 시험장에 갔지만, 실전은 그것보다 못한 것 같다. 평균 11문제? 10문제? 정도 풀었다. 실제 문제 난이도는 시중에서 구매한 책이 훨씬 더 어려웠지만 뭔가 모르게 긴장을 해서 그런지 생각보다 많이 풀지는 못했다. 아침 일찍부터 동국대학교로 가서 시험을 보는 만큼 문제를 풀다가 집중력을 잃을 수도 있다. 또, 기억하기로는 개인용품은 최소한으로 사용했던 것 같다. 시계도 사용 못 하고 감독관이 계속 시간을 알려준다. 1차 면접 편안한 복장으로 면접을 보러 갔다. 진짜 편하게 니트를 입고 갔는데.. 주변이 다 양복이었다. 뭔가 망한 느낌이 살짝 났지만 당황하지 않은 척했다. 1차 면접에 들어가기 전 50분가량 문제를 풀고 들어간다. 2가지 종류의 문제가 있고 이 중 하나를 선택하면 그에 관한 3~4가지 문제가 있었다. 그리고 약간 특이한 점이 있었는데 문제를 푸는 동안 핸드폰으로 검색이 가능했다. 하지만 문제에 대한 답을 1도 모른 채 검색으로 답만 찾으려고 한다면 시간이 부족했을 것 같다. 상당히 포괄적인 것을 물어보고 어디까지 아는지 확인하는 듯한 문제??? 약간 인터넷을 설명해봐라. 이런 느낌이다. 이걸 전공과 연결해서 답안을 작성해야 한다. 참고로 문제지는 다시 제출해야 했으므로 나는 문제를 요약해 차례대로 답안지에 적었다. 50분이 지나면 바로 면접으로 들어간다. 2:1 면접으로 진행하고 그렇게 압박하는 분위기는 아니다. 간단한 아이스브레이킹이 끝난 뒤 바로 풀었던 문제를 설명해보라고 한다. 어떤 면접자는 답은 적었는데 문제가 기억나지 않아 당황했다고 하니 미리 문제를 적어간 나는 뭔가 운이 좋았다. 40분 내외의 면접 중 10분 정도를 어떻게 문제를 풀었는지 또 내가 생각하는 답은 무엇인지를 그림을 그리면서 설명했다. 뭔가 설명을 잘했는지 면접관이 이 문제 말고 혹시 선택하지 않았던 다른 문제를 기억하고 있는지 물었고 그 문제에 관해 추상적으로라도 좋으니 설명해보라고 했다. 그 문제는 실무 경험이 있으면 유리한 문제여서 아는 범위내에서 설명하니 살짝 미소를 보였다. 해당 문제 설명을 마치면 정말 자소서 기반으로 질문을 하고 답을 하는 면접이였다. 기술적인 질문이 50% 였고 이 동아리는 무엇인지 왜 11번가에 지원했는지와 같은 질문이 50% 였다. 2차 면접 1차 면접과 달리 문제도 풀지 않고 그냥 앉아 있다가 바로 들어간다. 임원 면접이라고 해서 기술 관련 질문은 물어보지 않을 것 같았지만 예상은 빗나갔다. 이 역시 2대1 면접이었는데 1명이 기술 임뭔 다른 한 분은 그냥 임원이었다. 기술 임원이 계속 웃으면서 기술적인 질문을 던졌고 대답을 못 하는 것 같으면 힌트를 던져주셨다. 힌트를 듣고 정답을 이야기하면 계속 추임새로 ‘아시네요’, ‘잘하시네요’ 등 계속 칭찬을 해주며 편하게 해주려는 것 같았다. 2차 면접 역시 압박은 하나도 없었고 그냥 동네 아저씨랑 이야기하는 느낌이 들었다. 2차 면접은 기술 질문과 인성 질문이 60 대 40 정도였던 것 같다. 한 가지 당황했던 점이 기술면접관이 내 개인 기술 블로그에 들어와 특정 포스팅에 대해 질문을 던졌다. 진짜 들어와서 볼 줄은 몰랐는데… 대충 대답은 했지만 엄청나게 당황했다. 그리고 또 임원 면접에서 느낀 점은 2명 임원 모두 나의 자소서와 포트폴리오를 전날 확인한 것 같았다. 세세한 부분까지 알고 있었고 질문 또한 겉핥기 수준으로 대충 물어보지 않았다.","categories":[{"name":"review","slug":"review","permalink":"http://DongyeolLee.github.io/categories/review/"},{"name":"job","slug":"review/job","permalink":"http://DongyeolLee.github.io/categories/review/job/"}],"tags":[{"name":"review","slug":"review","permalink":"http://DongyeolLee.github.io/tags/review/"},{"name":"recruiting","slug":"recruiting","permalink":"http://DongyeolLee.github.io/tags/recruiting/"},{"name":"job","slug":"job","permalink":"http://DongyeolLee.github.io/tags/job/"}]},{"title":"자바 8 - lambda(람다) 더 알아보기","slug":"JAVA/lambda-more","date":"2019-04-30T07:42:42.000Z","updated":"2019-07-22T07:42:38.505Z","comments":true,"path":"2019/04/30/JAVA/lambda-more/","link":"","permalink":"http://DongyeolLee.github.io/2019/04/30/JAVA/lambda-more/","excerpt":"","text":"들어가기지난 포스트에서는 람다(lambda)가 왜 사용되면 편리한지 또 어떻게 사용될 수 있을지에 대해 아주 간단하게 알아보았습니다.이번 포스트에서는 람다(lambda)를 다시 한 번 정리하고 조금 더 심화된 내용을 알아보려고 합니다. 람다란 무엇인가람다 표현식은 메서드로 전달할 수 있는 익명 함수를 간단하게 표현한 것입니다. 람다 표현식은 익명 함수와 비슷하게 이름은 없지만, 파라미터, 바디, 반환 형식, 예외 리스트를 가질 수 있습니다.즉, 보통의 메서드와는 달리 이름이 없으므로 익명이라 표현하고 특정 메서드에 종속되지 않은 독립적인 것이므로 메서드가 아닌 함수라고 부릅니다.하지만 람다가 기술적으로 자바8 이전의 자바로 할 수 없었던 일을 제공하는 것은 아닙니다. 다만 람다는 동작 파라미터 형식의 코드를 더 쉽게 구현하고 보기 쉬운 코드를 작성하는데 큰 도움이 됩니다. 12345Comparator&lt;Apple&gt; byWeight = new Comparator&lt;apple&gt;() &#123; public int compare(Apple a1, Apple a2) &#123; return a1.getWeight().compareTo(a2.getWeight()); &#125;&#125; 위와 같은 코드를 람다를 이용하면 훨씬 간단한 코드로 작성할 수 있습니다. 1Comparator&lt;Apple&gt; byWeight = (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()); 즉, compare 메서드의 바디를 직접 전달하는 것처럼 코드를 전달할 수 있으면 이전 코드에 비해 훨씬 가독성 또한 높아졌습니다.확인한 것처럼 람다 표현식의 기본 문법은 간단합니다. 12345678910// 유효() -&gt; &#123;&#125;// 유효() -&gt; \"Raoul\"// 유효() -&gt; &#123;return \"Lee\";&#125;// 유효하지 않음(Integer i) -&gt; return \"Alan\" + i;// 유효하지 않음(String s) -&gt; &#123;\"Iron Man\"&#125; (parameters) -&gt; expression 또는 (parameters) -&gt; {statement;} 형식으로 람다 표현식을 작성할 수 있습니다. 어디에, 어떻게 람다를 사용할까함수형 인터페이스함수형 인터페이스는 오직 하나의 추상 메서드를 지정하는 인터페이스 입니다. 1234567891011121314// java.util.Comparatorpublic interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2);&#125;// java.lang.Runnablepublic interface Runnable &#123; void run();&#125;// java.util.concurrent.Callablepublic interface Callable&lt;V&gt; &#123; V call();&#125; 과연 이런 함수형 인터페이스로 무엇을 할 수 있을까요? 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있으므로 전체 표현식을 함수형 인터페이스의 인스턴스로 취급할 수 있습니다.또, 함수형 인터페이스보다는 덜 깔끔하지만 익명 내부 클래스로도 같은 기능을 구현할 수 있습니다. 다음과 같은 코드는 모두 올바른 코드입니다. 12345678910111213141516// 람다 사용Runnable r1 = () -&gt; System.out.println(\"Hello\");// 익명 클래스 사용Runnable r2 = new Runnable() &#123; public void run() &#123; System.out.println(\"Hello 2\"); &#125;&#125;public static void process(Runnable r) &#123; r.run();&#125;process(r1);process(r2);process(() -&gt; System.out.println(\"Hello 3\")); 함수 디스크립터람다 표현식의 시그니처를 서술하는 메서드를 함수 디스크립터라고 부릅니다. 예를 들어 Runnable 인터페이스의 유일한 추상 메서드 run은 인수와 반환값이 없으므로 Runnable 인터페이스는 인수와 반환값이 없는 시그니처로 생각할 수 있습니다.즉, Runnable 인터페이스의 run은 () -&gt; void과 같이 표현될 수 있습니다. 그리고 이에 대응하는 람다의 함수 디스크립터 역시 () -&gt; void로 표현되어야 합니다. 함수형 인터페이스 사용Predicate java.util.function.Predicate&lt; T &gt; 인터페이스는 test라는 추상메서드를 정의하며 test는 제네릭 형식의 t의 객체를 인수로 받아 Boolean을 반환합니다. 즉, 따로 Predicate를 만들 필요없이 필요에 따라 바로 Predicate 인터페이스를 사용할 수 있습니다. 1234567891011121314151617 @FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; boolean test(T t);&#125; public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p) &#123; List&lt;T&gt; results = new ArrayList&lt;&gt;(); for(T s : list) &#123; if(p.test(s)) &#123; results.add(s); &#125; &#125; return results;&#125;Predicate&lt;String&gt; nonEmptyStringPredicate = (String s) -&gt; !s.isEmpty();List&lt;String&gt; nonEmpty = filter(listOfString, nonEmptyStringPredicate) Consumerjava.util.function.Consumer&lt; T &gt; 인터페이스는 제네릭 형식 T 객체를 받아서 void를 반환하는 accept라는 추상 메서드를 정의합니다. T 형식의 객체를 인수로 받아서 어떤 동작을 수행하고 싶을 때 Consumer 인터페이스를 사용할 수 있습니다. 123456789101112@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t);&#125;public static &lt;T&gt; void forEach(List&lt;T&gt; list, Consumer&lt;T&gt; c) &#123; for(T i : list) &#123; c.accept(i); &#125;&#125;List&lt;Integer&gt; i = map(Arrays.asList(1, 2, 3, 4, 5), (Integer i) -&gt; System.out.println(i)); Functionjava.util.function.Function&lt; T, R &gt; 인터페이스는 제네릭 형식 T를 인수로 받아서 제네릭 형식 R 객체를 반환하는 apply라는 추상 메서드를 정의하며 이를 활용하여 입력을 출력으로 매핑하는 형식으로 사용할 수 있습니다. 123456789101112131415@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; R apply(T t);&#125;public static &lt;T, R&gt; List&lt;R&gt; map(List&lt;T&gt; list, Function&lt;T, R&gt; f) &#123; List&lt;R&gt; = result = new ArrayList&lt;&gt;(); for(T s : list) &#123; result.add(f.apply(s)); &#125; return result;&#125;// 4, 2, 3List&lt;Integer&gt; i = map(Array.asList(\"test\", \"dy\", \"lee\"), (String s) -&gt; s.length()); 기본형 특화자바에는 기본형과 참조형이 존재하지만 제네릭 파라미터에는 참조형만 사용할 수 있습니다. 이에 따라 자바에서는 기본형을 참조형으로 변환할 수 있는 기능을 제공하고 이 기능을 박싱이라고 부릅니다.또 이와 반대로 참조형을 기본형으로 변환하는 작업을 언박싱이라고 부릅니다. 더 나아가 자바에서는 박싱과 언박싱이 자동으로 이루어지는 오토 박싱이라는 기능도 제공합니다. 12345List&lt;Integer&gt; list = new ArrayList&lt;&gt;();for(int i = 300; i &lt; 400; i ++) &#123; list.add(i);&#125; 예시와 같은 코드는 동작하는데는 무리가 없지만 기본형이 참조형으로 변환하는 과정에서 어쩔수 없는 비용이 소모됩니다. 박싱한 값은 기본형을 감싸는 래퍼이며 힙에 저장됩니다. 따라서 박싱한 값은 메모리를 더 소비하며 기본형을 가져올 때도 메모리를 탐색하는 과정이 필요합니다.자바 8에서는 오토박싱 동작을 피할 수 있도록 특별한 버전의 함수형 인터페이스를 제공합니다. 예를 들어 아래 예제에서 IntPredicate는 1000이라는 값을 박싱하지 않지만, Predicate&lt; Integer &gt;는 1000이라는 값을 Integer로 박싱합니다. 1234567891011public interface IntPredicate &#123; boolean test(int t);&#125;// 박싱 없음IntPredicate evenNumbers = (int i) -&gt; i % 2 == 0;evenNumbers.test(1000);// 박싱Predicate&lt;Integer&gt; oddNumbers = (Integer i) -&gt; i % 2 == 1;oddNumbers.test(1000); 마치며자바 8에서 중요한 요소인 람다의 정리를 마치겠습니다. 질문은 언제든지 자유롭게 달아주시면 찾아서라도 답 달아보도록 노력할게요~","categories":[{"name":"programming","slug":"programming","permalink":"http://DongyeolLee.github.io/categories/programming/"},{"name":"java","slug":"programming/java","permalink":"http://DongyeolLee.github.io/categories/programming/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://DongyeolLee.github.io/tags/java/"},{"name":"lambda","slug":"lambda","permalink":"http://DongyeolLee.github.io/tags/lambda/"}]},{"title":"자바 8 - lambda(람다) 함수","slug":"JAVA/lambda","date":"2019-04-14T05:15:55.000Z","updated":"2019-04-30T07:24:41.162Z","comments":true,"path":"2019/04/14/JAVA/lambda/","link":"","permalink":"http://DongyeolLee.github.io/2019/04/14/JAVA/lambda/","excerpt":"","text":"들어가기어떤 상황에서 일을 하든 소비자 요구사항은 항상 바뀔 가능성이 높습니다. 따라서 변화하는 요구사항은 소프트웨어에서는 피할 수 없는 문제입니다.이런 상황에서 조금 더 가독성있게 편리하게 사용할 수 있는 것이 Lambda(람다)라는 자바 8에서 추가된 기능이라고 할 수 있습니다. lambda를 이해하기 전 우리는 먼저 시시각각 변하는 사용자 요구사항에 어떻게 대응해야 할까 생각을 해보아야 합니다. 새로 추가되거나 변경되는 기능이 쉽게 구현 가능하며 장기적인 관점에서는 유지 보수가 쉬워야 합니다. 동작 파라미터화동작 파라미터화를 이용하면 자주 바뀌는 요구사항을 효과적으로 대응할 수 있습니다. 동작 파라미터화란 아직은 어떻게 실행할 것인지 결정하지 않은 코드 블록을 의미합니다.글로만 보려하니 잘 이해가 가지 않을 수도 있습니다. 한번 예시를 살펴보겠습니다. 사과가 담긴 리스트에서 녹색 사과만 필터링 하는 기능을 구현하는 코드를 한번 보겠습니다. public class filterGreenApples { public static List filterGreenApples(List inventory) { List result = new ArrayList(); for (Apple apple : inventory) { if (\"green\".equals(apple.getColor()) { result.add(apple); } } return result; } } 위와 같은 코드에서 과연 초록 사과 뿐만이 아닌 빨간 사과도 필터링 하고 싶으면 어떤 식으로 코드를 수정해야 할까요?물론 코드 자체를 복사해서 “green” 부분만 “red”로 수정해도 문제는 없습니다. 하지만 나중에 다양한 색으로 필터링 하기는 어려운 관계로 조금 더 변화에 적절하게 바꿔 보겠습니다. public class filterApplesByColor { public static List filterApplesByColor(List inventory, String color) { List result = new ArrayList(); for(Apple apple : inventory) { if (apple.getColor().equals(color)) { result.add(apple); } } return result; } } 이제 모든 색의 사과를 필터링 할 수 있게 됐습니다. 하지만 더 나아가 특정 색을 가진 사과를 다시 무게로 필터링을 하려면 어떻게 수정할 수 있을까요? 여러가지 방법이 있을 수 있겠지만 가장 쉽게 생각할 수 있는 방법은 다음과 같습니다. public class filterApplesByWeight { // 특정 무게보다 무거운 사과만 담기 public static List filterApplesByWeight(List inventory, int weight) { List result = new ArrayList(); for(Apple apple : inventory) { if (apple.getWeight() > weight) { result.add(apple); } } return result; } } 지금까지 세개의 예시 코드를 보았습니다. 무엇가 느껴지시지 않으신가요? 검색 조건이 추가될 때마다 파라미터가 증가한다거나 또 색으로만 검색하고 싶은 경우는 별도의 중복된 함수를 따로 둬야 한다는 문제가 있습니다.어떤 식으로 변경을 하면 조금 더 유연하게 변경이 가능할까요? 먼저 검색 조건을 추상화 해보겠습니다. public interface ApplePredicate { boolean test (Apple apple); } public class filterApplesWithPredicate { public static List filterApplesWithPredicate(List inventory, ApplePredicate p) { List result = new ArrayList(); for(Apple apple : inventory) { if(p.test(apple)) { result.add(apple); } } return result; } public class AppleHeavyWeightPredicate implements ApplePredicate { @Override public boolean test(Apple apple) { return apple.getWeight() > 150; } } } 위와 같은 코드는 어떤가요? 전략 패턴을 사용하여 메서드가 다양한 동작을 받아서 내부적으로 수행할 수 있게되어 훨씬 유연한 코드로 변화하였습니다. ApplePredicate를 적절하게 구현하는 클래스를 만들면 다양한 요구사항에 맞게 기능을 추가할 수 있습니다.즉, 우리가 전달한 ApplePredicate 객체에 의해 filterApplesWithPredicate 메서드의 동작을 파라미터화 한 것입니다. 자! 오래 기다리셨습니다. 이제 lambda(람다)를 이야기 할때가 된 것 같습니다. 바로 직전 본 코드에서 filter 함수를 어떤 식으로 호출할 수 있을까요?아마 다음과 같이 호출할 수 있습니다. public class FilteringApples { public static void main(String...args) { List inventory = Arrays.asList(new Apple(90, \"green\"), new Apple(200, \"red\"), new Apple(90, \"red\")); List heavyApples = filterApplesWithPredicate(inventory, new AppleHeavyWeightPredicate); } } 또 실제로 AppleHeavyWeightPredicate 메서드를 활용하지 않고 익명 함수로 처리할 수도 있습니다. public class FilteringApples { public static void main(String...args) { List inventory = Arrays.asList(new Apple(90, \"green\"), new Apple(200, \"red\"), new Apple(90, \"red\")); List heavyApples = filterApplesWithPredicate(inventory, new ApplePredicate() { @Override public boolean test(Apple apple) { return apple.getWeight() > 150; } }); } } 하지만 다음과 같은 익명 클래스에서도 다소 고치고 싶은 부분이 있습니다. 바로 중복되는 부분의 코드입니다. 익명 클래스로 ApplePredicate()를 넘겨 줄 때마다 명시적으로 public boolean test까지 표현해야해 여전히 많은 공간을 차지 합니다.또, 익명 클래스에 익숙하지 않으면 사용하기 어렵다는 문제도 발생할 수 있습니다. 이런 코드의 장황함과 익숙하지 않음을 해결해 줄 수 있는 방법이 바로 lambda(람다)입니다. 즉, lambda(람다)는 한눈에 이해할 수 있는 코드를 구현하는 데 많은 도움을 줄 수 있습니다.명시적으로 익명 클래스처럼 객체를 만들고 새로운 동작을 정의하는 메서드를 구현하는데는 변하지 않지만 훨씬 가독성이 뛰어난 것을 확인할 수 있습니다. 이제 lambda(람다)를 활용하여 앞에서 본 예제가 어떻게 변화했는지 확인 해보겠습니다. public class FilteringApples { public static void main(String...args) { List inventory = Arrays.asList(new Apple(90, \"green\"), new Apple(200, \"red\"), new Apple(90, \"red\")); List heavyApples = filterApplesWithPredicate(inventory, // 람다 표현식 (Apple apple) -> apple.getWeight() > 150); } } 이전 보다 훨씬 코드가 간결해지지 않았나요? 코드가 간결해지면서 가독성 또한 많이 높아졌습니다. 즉, lambda(람다)는 코드의 장황성을 배제하고 프로그래머로 하여금 훨씬 좋은 코드를 짤 수 있도록 많이 사용되고 있습니다.다시 한번 정리하자면 lambda(람다)는 익명 클래스처럼 이름이 없는 함수면서 메서드를 간결하고 장황하지 않게 인수로 전달할 수 있는 코드 블록를 의미합니다. 마치며lambda(람다)를 설명하기에는 다소 부족한 점이 많이 있었을 것이라 생각됩니다. 틀린 부분이 있거나 이해가 잘 가지 않는 부분이 있다면 언제든지 comment 달아주세요~이번은 겉핥기식으로 정리를 해보았지만 이후 조금 더 심화된 내용의 lambda(람다)를 정리해볼까합니다.","categories":[{"name":"programming","slug":"programming","permalink":"http://DongyeolLee.github.io/categories/programming/"},{"name":"java","slug":"programming/java","permalink":"http://DongyeolLee.github.io/categories/programming/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://DongyeolLee.github.io/tags/java/"},{"name":"lambda","slug":"lambda","permalink":"http://DongyeolLee.github.io/tags/lambda/"}]},{"title":"백준[1759] - 암호 만들기","slug":"Al/1759","date":"2018-12-03T16:51:13.000Z","updated":"2019-04-30T07:24:41.153Z","comments":true,"path":"2018/12/04/Al/1759/","link":"","permalink":"http://DongyeolLee.github.io/2018/12/04/Al/1759/","excerpt":"","text":"문제백준 1759 문제 보기 접근 방법이번 문제는 백 트래킹을 활용해 문제를 풀 수 있다. 입력 받은 문자열을 오름 차순으로 정렬한 뒤 백 트래킹을 실시 한다. 조합을 통해 만들어 낸 문자열의 길이가 최종 길이와 같다면 문자열 중복을 set을 활용해 피한다. 코드#include &ltiostream&gt #include &ltvector> #include &ltstring> #include &ltalgorithm> #include &ltset> using namespace std; int L, C; vector&ltchar> c_arr; set&ltstring> se; void back_tracking(int idx, int cnt, string s) { // 문자열 길이가 최종 길이와 같다면 if(cnt == L) { // 모음 갯수, 자음 갯수 int chk1 = 0, chk2 = 0; // 알파벳 중복 체크 int visited[27] = {0, }; for(int i = 0; i < s.length(); i ++) { // 모음인 경우 if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') { chk1 ++; } // 자음인 경우 else { // 중복 자음이 아닌 경우 카운트 증가 if(!visited[s[i]-'0'-48]) chk2 ++; } } // 모음이 하나 이상이고 서로 다른 자음이 2개이상 사용하면 set에 저장 if(chk1 >= 1 && chk2 >= 2) se.insert(s); return; } for(int i = idx; i < C; i ++) { // 문자를 선택한 경우 back_tracking(i + 1, cnt + 1, s + c_arr[i]); // 선택하지 않고 지나친 경우 back_tracking(i + 1, cnt, s); } } int main() { cin >> L >> C; for(int i = 0; i < C; i ++) { char c; cin >> c; c_arr.push_back(c); } // 오름 차순으로 정렬 sort(c_arr.begin(), c_arr.end()); // 백 트래킹 시작 back_tracking(0, 0, \"\"); // set에 저장된 문자열 출력 for(auto it = se.begin(); it != se.end(); it++) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1261] - 알고스팟","slug":"Al/1261","date":"2018-11-27T06:12:05.000Z","updated":"2019-04-30T07:24:41.147Z","comments":true,"path":"2018/11/27/Al/1261/","link":"","permalink":"http://DongyeolLee.github.io/2018/11/27/Al/1261/","excerpt":"","text":"문제백준 1261 문제 보기 접근 방법문제의 정답은 벽을 최소로 부수면서 도착지에 도착하게끔 구현해야한다. bfs로도 풀수 있을 것 같긴하나 시간 초과가 발생할 수도 있을것 같다. 따라서 다익스트라 알고리즘을 사용했다. 벽을 부수는 갯수를 해당 좌표까지 이동하는 비용으로 생각하고 문제를 풀었다. 코드#include &ltiostream&gt #include &ltcstring> #include &ltqueue> using namespace std; int r, c; int map[101][101]; int broken[101][101]; int dr[4] = {-1, 0, 1, 0}; int dc[4] = {0, 1, 0, -1}; priority_queue&ltpair&ltint, pair&ltint, int>>> pq; int main() { cin >> c >> r; // 벽을 부순 갯수를 나타내는 broken 지도 memset(broken, -1, sizeof(broken)); for(int i = 0; i < r; i ++) { for(int j = 0; j < c; j ++) { // 숫자 하나씩 입력 받으며 map에 그림 scanf(\" %1d\", &map[i][j]); } } // 우선 순위 큐에 {벽을 부순 숫자, {좌표1, 좌표2}} // 즉, (좌표1, 좌표2)까지 이동하기 위해 부순 벽돌수를 저장 pq.push({0, {0, 0}}); while(!pq.empty()) { int broken_cnt = -pq.top().first; int rr = pq.top().second.first; int cc = pq.top().second.second; pq.pop(); // 이미 해당 경로를 통과했을 경우 if(broken[rr][cc] != -1) { continue; } // 부순 벽돌 수 저장 broken[rr][cc] = broken_cnt; // 위, 오른쪽, 아래, 왼쪽 for(int i = 0; i < 4; i ++) { int nr = rr + dr[i]; int nc = cc + dc[i]; // 범위 안에 존재하고 if(nr >= 0 && nc >= 0 && nr < r && nc < c) { // 다음 목적지를 방문한적이 없으면 if(broken[nr][nc] == -1) { // 다음 목적지가 벽돌이라면 if(map[nr][nc] == 1) { pq.push({-(broken_cnt + 1), {nr, nc}}); } // 벽돌 없는 빈방이라면 else { pq.push({-broken_cnt, {nr, nc}}); } } } } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1238] - 파티","slug":"Al/1238","date":"2018-11-16T05:20:50.000Z","updated":"2019-04-30T07:24:41.147Z","comments":true,"path":"2018/11/16/Al/1238/","link":"","permalink":"http://DongyeolLee.github.io/2018/11/16/Al/1238/","excerpt":"","text":"문제백준 1238 문제 보기 접근 방법다익스트라 알고리즘을 사용하되 다시 각자의 마을로 복귀해야 하므로 다익스트라 알고리즘을 한번 더 사용한다. dis_go 배열에는 갈때의 비용을 저장하고 dis_come 배열에는 다시 돌아올때의 비용을 저장한다. 코드#include &ltiostream&gt #include &ltvector> #include &ltqueue> #include &ltalgorithm> #include &ltutility> #include &ltcstring> using namespace std; int N, M, X, ans = -1, dis_go[1001], dis_come[1001]; vector&ltvector&ltpair&ltint, int>>> graph; priority_queue&ltpair&ltint, int>> pq; int main() { // 학생, 도로 숫자, 도착 마을 cin >> N >> M >> X; // 마을 수 만큼 그래프를 증가 graph.resize(M+1); for(int i = 0; i < M; i ++) { int from, to, time; cin >> from >> to >> time; // 그래프를 그림 graph[from].push_back({to, time}); } // 모든 마을에서 도착지점으로 가야하므로 반복문 사용 for(int i = 1; i &lt= N; i ++) { // 출발지 설정 int source = i; // 우선순위 큐를 초기화(나에게 오는 비용은 0) pq.push({0, source}); // 모든 비용을 -1로 처리 memset(dis_go, -1, sizeof(dis_go)); while(!pq.empty()) { int here = pq.top().second; int cost = -pq.top().first; pq.pop(); // 방문한 적이 있다면 무시 if(dis_go[here] != -1) { continue; } // 해당 마을까지의 비용을 저장 dis_go[here] = cost; // 현재 마을로 부터 연결된 지점을 탐색 for(int n = 0; n < graph[here].size(); n ++) { int next = graph[here][n].first; int n_cost = -graph[here][n].second - cost; // 방문한 적이 있다면 무시 if(dis_go[next] != -1) { continue; } // 새로운 마을이라면 우선 순위큐에 삽입 pq.push({n_cost, next}); } } // 원래 마을로 복귀해야 하므로 도착지점을 출발지점으로 설정 pq.push({0, X}); memset(dis_come, -1, sizeof(dis_come)); while(!pq.empty()) { int here = pq.top().second; int cost = -pq.top().first; pq.pop(); if(dis_come[here] != -1) { continue; } dis_come[here] = cost; for(int n = 0; n < graph[here].size(); n ++) { int next = graph[here][n].first; int n_cost = -graph[here][n].second - cost; if(dis_come[next] != -1) { continue; } pq.push({n_cost, next}); } } ans = max(ans, dis_go[X] + dis_come[source]); } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1916] - 최소비용 구하기","slug":"Al/1916","date":"2018-11-14T05:09:32.000Z","updated":"2019-04-30T07:24:41.154Z","comments":true,"path":"2018/11/14/Al/1916/","link":"","permalink":"http://DongyeolLee.github.io/2018/11/14/Al/1916/","excerpt":"","text":"문제백준 1916 문제 보기 접근 방법한 정점에서 모든 정점을 최소비용으로 가는 방법을 구하는 문제이므로 이는 다익스트라 알고리즘을 활용해 해결할 수 있다. 즉, 구하고자하는 마을과 버스 노선을 그래프로 그려 이를 활용해 우선순위 큐로 문제를 해결한다. 코드#include &ltiostream&gt #include &ltvector> #include &ltutility> #include &ltqueue> #include &ltcstring> using namespace std; // N: 마을 수, M: 버스 노선 수, source: 출발, destination: 목적지, dis[]: 거리 int N, M, source, destination, dis[1001]; vector&ltvector&ltpair>> graph; priority_queue&ltpair&ltint, int>> pq; int main() { cin >> N; cin >> M; // 그래프의 노드는 마을이므로 사이즈 증가 graph.resize(N+1); for(int i = 0; i < M; i ++) { int from, to, cost; cin >> from >> to >> cost; // 현재 마을에서 다음 마을까지의 요소를 현재 마을 인덱스에 저장 graph[from].push_back(make_pair(to, cost)); } cin >> source >> destination; // 우선순위 큐에 출발지 정보 삽입 pq.push({0, source}); memset(dis, -1, sizeof(dis)); while(!pq.empty()) { // 우선순위 큐는 기본적으로 max heap을 활용하므로 - 값을 취함 int cost = -pq.top().first; int location = pq.top().second; pq.pop(); // 이전 방문 기록이 있으면 무시 if(dis[location] != -1) { continue; } dis[location] = cost; for(int i = 0; i < graph[location].size(); i ++) { int n_location = graph[location][i].first; // 가장 작은 비용이 상위에 저장되어야 하므로 - 값 int n_cost = -graph[location][i].second - cost; if(dis[n_location] != -1) { continue; } pq.push({n_cost, n_location}); } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"stringstream을 활용하여 문자열 처리하기","slug":"Tips_Al/StringStream","date":"2018-11-08T12:19:47.000Z","updated":"2019-04-30T07:24:41.167Z","comments":true,"path":"2018/11/08/Tips_Al/StringStream/","link":"","permalink":"http://DongyeolLee.github.io/2018/11/08/Tips_Al/StringStream/","excerpt":"","text":"들어가기cpp로 알고리즘 문제를 풀다보면 가끔 까다로운 input으로 시간이 오래 걸릴 경우가 있습니다. 그중 최근 겪었던 까다로운 input을 쉽게 해결하는 방법을 알아보겠습니다. 본론문자열을 쉽게 핸들링하는 방법으로 stringstream이 있습니다. 이를 활용하여 입력받은 string input을 구분하여 저장할 수 있습니다. 예를 들어 다음과 같은 상황을 고려해보겠습니다. 1231 lee 3학년 19살2 kim 2학년 18살3 choi 1학년 17살 예시와 같이 3명의 학생이 입력이 됩니다. 하지만 모든 입력은 띄어쓰기를 구분되어 번호, 이름, 학년, 나이가 입력됩니다. 이름과 학년, 나이의 길이 제한은 없습니다. 즉, 이름이 100자인 학생이 들어올수도 있고 나이가 100살인 학생이 들어올수 있습니다. 이럴 경우 단순히 input을 처리하기에는 다소 많은 시간을 들여야 합니다. 이때 유용하게 사용할 수 있는 방법이 바로 stringstream입니다. 이 역시 코드를 보며 확인해 보겠습니다. #include &ltiostream> #include &ltsstream> using namespace std; int main() { string input; for(int i = 0; i < 3; i ++) { getline(cin, input); stringstream ss(input); string v; while((ss >> v)) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"tips","slug":"computer-science/algorithms/tips","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/tips/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"},{"name":"tips","slug":"tips","permalink":"http://DongyeolLee.github.io/tags/tips/"},{"name":"cpp","slug":"cpp","permalink":"http://DongyeolLee.github.io/tags/cpp/"}]},{"title":"백준[2644] - 촌수계산","slug":"Al/2644","date":"2018-11-07T12:07:34.000Z","updated":"2019-04-30T07:24:41.157Z","comments":true,"path":"2018/11/07/Al/2644/","link":"","permalink":"http://DongyeolLee.github.io/2018/11/07/Al/2644/","excerpt":"","text":"문제백준 2644 문제 보기 접근 방법전형적인 bfs 완전 탐색으로 문제를 해결할 수 있다. 각 가족들의 촌수를 양방향 그래프로 벡터에 저장한 뒤, 시작 노드부터 완전 탐색을 시작한다. 코드#include &ltiostream&gt #include &ltqueue> #include &ltvector> using namespace std; // 구조체 작성 struct info { // 촌수를 카운트 int rel_cnt; // 나의 노드 int my_num; }; int n, r1, r2, cnt; vector&ltvector&ltint>> rel(101); int visited[101]; queue q; int main() { cin >> n; cin >> r1 >> r2; cin >> cnt; for(int i = 0; i < cnt; i ++) { int x, y; cin >> x >> y; // 촌수에 대한 양방향 그래프 rel[x].push_back(y); rel[y].push_back(x); } // 나를 시작으로 완전탐색 시작 q.push({0, r1}); // 방문 체크 visited[r1] = 1; while(!q.empty()) { int rel_cnt = q.front().rel_cnt; int my_num = q.front().my_num; q.pop(); // 도착지점 if(my_num == r2) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[16236] - 아기 상어","slug":"Al/16236","date":"2018-10-23T16:23:34.000Z","updated":"2019-04-30T07:24:41.152Z","comments":true,"path":"2018/10/24/Al/16236/","link":"","permalink":"http://DongyeolLee.github.io/2018/10/24/Al/16236/","excerpt":"","text":"문제백준 16236 문제 보기 접근 방법bfs를 활용하는 문제다. 처음에는 어떻게 풀어야 할지 잘 생각이 나지 않았다. 문제가 이해가 가질 않아서.. 차분히 다시 생각해보니 bfs로 풀면 N이 작기 때문에 가능할 것 같다는 생각이 들었다. bfs를 사용하되 과연 어떤 식으로 해결할 수 있을까.. 아기 상어가 자신보다 작은 길로만 가게끔 구현하고 다음 위치의 상어가 아기 상어와 사이즈가 같을 경우와 물고기 없이 길인 경우를 동일시 처리한다. 만약 작은 상어가 있어 잡아 먹는다면 벡터로 따로 관라하는 방법을 취했다. 자세한 내용은 코드 주석을 확인 코드#include &ltiostream&gt #include &ltvector> #include &ltqueue> #include &ltcstring> #include &ltalgorithm> using namespace std; // 상어 구조체 struct fish { int r; int c; // 현재 사이즈를 표시 int size; // 몇 마리를 잡아 먹었는지 표시 int eat; // 이동한 시간을 표시 int time; }; int N; int dr[4] = {-1, 0, 1, 0}; int dc[4] = {0, 1, 0, -1}; int map[21][21]; int visited[21][21]; queue&ltfish> q; vector&ltfish> v; // 문제 조건에 맞는 비교연산 bool cmp(fish a, fish b) { // 가장 짧은 시간 if (a.time &lt= b.time) { // 시간이 같을 경우 if (a.time == b.time) { // y값이 더 작은 순서 if (a.r &lt= b.r) { // y값이 같다면 if (a.r == b.r) { // x값이 작은 순서로 정렬 if (a.c < b.c) { return true; } return false; } return true; } return false; } return true; } return false; } int main() { cin >> N; // 이전 상어의 상태를 저장 fish ex; for (int r = 0; r < N; r++) { for (int c = 0; c < N; c++) { cin >> map[r][c]; if (map[r][c] == 9) { // 시작 위치를 설정 map[r][c] = 0; // 물고기 초기화 ex = {r, c, 2, 0, 0}; } } } // 시간 정보 int ans = 0; while (1) { v.clear(); memset(visited, 0, sizeof(visited)); visited[ex.r][ex.c] = 1; q.push(ex); while (!q.empty()) { int r = q.front().r; int c = q.front().c; int size = q.front().size; int eat = q.front().eat; int time = q.front().time; q.pop(); // 4방향으로 검사를 진행 for (int i = 0; i < 4; i++) { int nr = r + dr[i]; int nc = c + dc[i]; if (nr >= 0 && nr < N && nc >= 0 && nc < N) { // 맵 사이즈가 유효하고 방문하지 않은 지역 if (!visited[nr][nc]) { // 사이즈가 같은 상어이거나 길인 경우 if (map[nr][nc] == 0 || map[nr][nc] == size) { // 방문 처리 visited[nr][nc] = 1; // 시간만 추가하고 계속 작은 상어를 찾음 q.push({nr, nc, size, eat, time + 1}); } // 만약 작은 상어가 있다면 else if (map[nr][nc] < size) { // 방문 처리 visited[nr][nc] = 1; // 잡아 먹은 상어와 시간을 표시하고 벡터에 따로 저장 v.push_back({nr, nc, size, eat + 1, time + 1}); } } } } } // 만약 벡터가 비어있다면 잡아 먹을수 있는 상어가 없음 if (v.size() == 0) { break; } // cmp 조건에 맞춰 정렬 sort(v.begin(), v.end(), cmp); // 먹은 상어의 숫자가 현재 사이즈와 같다면 사이즈 증가 if (v[0].size == v[0].eat) { v[0].size++; v[0].eat = 0; } // 잡어 먹은 상어를 지움 map[v[0].r][v[0].c] = 0; // 움직인 시간을 저장 ans += v[0].time; // 시간을 초기화하고 다시 큐에 넣어 이전 과정을 반복 ex = {v[0].r, v[0].c, v[0].size, v[0].eat, 0}; } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[9205] - 맥주 마시면서 걷기","slug":"Al/9205","date":"2018-10-12T08:13:59.000Z","updated":"2019-04-30T07:24:41.159Z","comments":true,"path":"2018/10/12/Al/9205/","link":"","permalink":"http://DongyeolLee.github.io/2018/10/12/Al/9205/","excerpt":"","text":"문제백준 9205 문제 보기 접근 방법문제를 이해하기 힘들었다. 하지만 결론은 20병의 맥주를 다 마시기 전에 다른 편의점을 도착할 수 있는지의 여부, 그리고 도착지에 갈 수 있는지를 확인하면 된다. 맥주 20개로 갈 수 있는 거리는 1000이다. 따라서 출발지로 부터 1000이내 편의점 또는 목적지가 있는지 검사한다. 코드#include &ltiostream&gt #include &ltvector> #include &ltutility> #include &ltcstring> #include &ltcmath> #include &ltalgorithm> using namespace std; int T, N; string ans; vector&ltpair&ltint, int>> dist; int visited[105]; // 거리 측정 bool get_distance(int x1, int y1, int x2, int y2) { int diff = abs(x1 - x2) + abs(y1 - y2); return (diff &lt= 1000)? true : false; } void dfs(int idx) { if(idx == N + 1) { ans = \"happy\"; return; } for(int i = 1; i < N + 2; i ++) { if(!visited[i]) { // 거리 확인 if(get_distance(dist[idx].first, dist[idx].second, dist[i].first, dist[i].second)) { visited[i] = 1; // 이동 dfs(i); } } } } int main() { cin >> T; for(int t = 1; t &lt= T; t ++) { cin >> N; ans = \"sad\"; dist.clear(); memset(visited, 0, sizeof(visited)); for(int i = 0; i < N + 2; i ++) { int num1, num2; cin >> num1 >> num2; dist.push_back({num1, num2}); } dfs(0); cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[2668] - 숫자고르기","slug":"Al/2668","date":"2018-10-09T13:19:53.000Z","updated":"2019-04-30T07:24:41.157Z","comments":true,"path":"2018/10/09/Al/2668/","link":"","permalink":"http://DongyeolLee.github.io/2018/10/09/Al/2668/","excerpt":"","text":"문제백준 2668 문제 보기 접근 방법문제에서 요구하는 조건을 만족하려면 주어진 숫자들이 사이클을 이루는지 확인하고 사이클 갯수를 출력하면 된다. 코드#include &ltiostream&gt #include &ltalgorithm> #include &ltvector> #include &ltutility> #include &ltset> using namespace std; int N; int arr[101]; int visited[101]; vector&ltpair&ltint, int>> temp_arr; set s_idx; void dfs(int idx) { // 다음 방문할 곳 int next = arr[idx]; // 방문했다면 사이클이 존재 if(visited[next] == 1) { // 사이클이 존재하는 idx만 따로 저장 for(int i = next; visited[i] != -1; i = arr[i]) { temp_arr.push_back({idx, i}); idx = i; visited[i] = -1; } return; } else if(visited[next] == -1 || visited[next] == 0) { visited[next] = 1; dfs(next); visited[next] = -1; } } int main() { cin >> N; // 1 ~ N까지 숫자 for(int i = 1; i &lt= N; i ++) { // i는 1부터 시작 cin >> arr[i]; } for(int i = 1; i &lt= N; i ++) { temp_arr.clear(); // 방문 체크 visited[i] = 1; // 사이클 확인 dfs(i); visited[i] = -1; // 중복 제거 for(int t = 0; t < temp_arr.size(); t ++) { s_idx.insert(temp_arr[t].first); } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"Command Pattern(커맨드 패턴)","slug":"Design Pattern/CommandPattern","date":"2018-09-25T06:36:45.000Z","updated":"2019-04-30T07:24:41.161Z","comments":true,"path":"2018/09/25/Design Pattern/CommandPattern/","link":"","permalink":"http://DongyeolLee.github.io/2018/09/25/Design Pattern/CommandPattern/","excerpt":"","text":"들어가기이번 포스팅에서는 커맨드 패턴(Command Pattern) 에 대해서 알아보겠습니다. 본론1. 커맨드 패턴이란 무엇인가커맨드 패턴(Command Pattern)은 특정 행위(기능)을 캡슐화하여 클래스를 변경하지 않고 재사용할때 유용하게 사용합니다. 즉, 요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록 매서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴입니다. 말로는 많이 어려우니 밑에서 예시를 통해 커맨드 패턴(Command Pattern)을 사용하지 않았을때 발생하는 문제점과 커맨드 패턴(Command Pattern)을 사용했을때 얻는 이점을 다시 한번 확인해보겠습니다. 2. 왜 커맨드 패턴을 사용해야 하는가한 가지 예를 들어겠습니다. 버튼이 두개 있는 리모컨이 있습니다. 하나는 Turn On, 다른 한 가지는 Turn Off 입니다. 하지만 이 리모컨은 만능 리모컨이기에 TV, 에어컨 등 모든 전자 기기를 끌수 있고 킬수 있다고 가정하겠습니다. 이때 어떤 전자 기기는 전원을 키고 끌때 내부적으로 모든 로직이 똑같을 수도 있고 다를 수도 있습니다. 즉, 이전 코드를 재사용 할 수도 있고 완전히 새로 구현해야 할 수도 있습니다. 이럴 경우 커맨드 패턴(Command Pattern)을 사용하면 기능 자체를 추상화하여 재사용성을 높이고 메서드를 직접 호출하지 않으면서 수정할 부분을 최소화 시킬수 있습니다. 3. 예시커맨드 패턴(Command Pattern)의 필요성에서 보았듯이 만능 리모콘을 만들어보며 패턴을 적용하지 않았을 경우 문제점을 알아보겠습니다. 간략한 예시를 위해 turn on만 가정해서 코드를 작성하겠습니다. 3.1 커맨드 패턴을 적용하지 않았을 경우public class Lamp { public void turnOn() { System.out.println(\"Turn On\"); } } public class Button { private Lamp theLamp; public Button(Lamp theLamp) { this.theLamp = theLamp; } public void pressed() { theLamp.turnOn(); } } public class Client { public static void main(String[] args) { Lamp lamp = new Lamp(); Button remote = new Button(lamp); remote.pressed(); } } 위에서 작성한 코드는 전등을 키는 간단한 코드입니다. 작동하는데는 문제가 없어 보입니다. 하지만 몇가지 문제점를 확인할 수 있습니다. 같은 코드를 사용하면서 전등이 아닌 TV나 알람을 키는 기능을 추가할 경우 버튼을 누르는 횟수에 따라 다른 기능을 수행해야 할 경우 첫 번째 문제점을 먼저 확인해보겠습니다. 위에 예시에서 볼수 있듯이 TV 클래스를 작성하는 것만으로 그치지 않고 기존 Button 클래스 코드를 수정해야 합니다. 이는 이전 포스팅에서 확인했듯이 OCP에 위배됩니다. 즉, 버튼을 눌렀을 때 지정된 기능만 고정적으로 수행하도록 만든 처음과 같은 설계는 기능이 추가될 때마다 여러 클래스를 수정해야하기에 OCP를 위반하는 설계입니다. 두 번째 경우의 문제점을 확인해보겠습니다. 예를 들어 버튼을 처음 눌렀을 때는 램프를 켜고 두 번 눌렀을 때는 알람을 동작하게 할 경우에 Button 클래스는 2가지 기능을 모두 구현할 수 있어야 합니다. enum Mode {LAMP, ALARM}; public class Lamp { public void turnOn() { System.out.println(\"Turn On\"); } } public class Alarm { public void start() { System.out.println(\"Alarming\"); } } public class Button { private Lamp theLamp; private Alarm theAlarm; private Mode theMode; public Button(Lamp theLamp) { this.theLamp = theLamp; this.theAlarm = theAlarm; } public void setMode(Mode mode) { this.theMode = mode; } public void pressed() { swhitch(theMode) { case LAMP: theLamp.turnOn(); break; case ALARM: theAlarm.start(); break; } } } 이 경우 역시 버튼을 눌렀을 때의 기능을 변경하기 위해 다시 Button 클래스의 코드를 수정해야합니다. 즉, OCP를 위배할 뿐더러 Button 클래스를 재사용하기 어렵습니다. 3.2 커맨드 패턴을 적용한 경우새로운 기능을 추가하거나 변경하더라도 Button 클래스를 그대로 사용하려면 Button 클래스에 pressed 메서드에서 구체적인 기능을 직접 구현하는 대신 버튼을 눌렀을 때 실현될 기능을 클래스 외부에서 제공받아 캡슐화하여 호출하는 방법을 사용할 수 있습니다. 클래스 다이어그램을 보면 turnOn 메서드나 start 메서드를 직접 호출하지 않고 추상화하여 호출하고 있습니다. public interface Command { public abstract void execute(); } public class Alarm { public void start() { System.out.println(\"Alarming ... \"); } } public class Lamp { public void turnOn() { System.out.println(\"Lamp On\"); } } public class AlarmOnCommand implements Command { private Alarm theAlarm; public AlarmOnCommand(Alarm theAlarm) { this.theAlarm = theAlarm; } @Override public void execute() { theAlarm.start(); } } public class LampOnCommand implements Command { private Lamp theLamp; public LampOnCommand(Lamp theLamp) { this.theLamp = theLamp; } @Override public void execute() { theLamp.turnOn(); } } public class Button { private Command theCommand; public Button(Command theCommand) { setTheCommand(theCommand); } public void setTheCommand(Command theCommand) { this.theCommand = theCommand; } public void pressed() { theCommand.execute(); } } 보시는 바와 같이 Command 인터페이스를 구현하는 LampOnCommand와 AlarmCommand 객체를 Button 객체에 설정하여 버튼을 눌렀을 때 필요한 임의의 기능은 Command 인터페이스를 구현한 클래스의 객체를 Button 객체에 설정해서 실행할 수 있습니다. 즉, 실행될 기능을 캡슐화함으로써 호출자(Invoker)와 실제 기능을 실행하는 수신자(Receiver) 클래스 사이의 의존성을 제거합니다. 따라서 실행될 기능의 변경에도 호출자 클래스를 수정 없이 그대로 사용할 수 있도록 해줍니다. Command : 실행될 기능을 execute 메서드로 선언함 ConcreteCommand : 실제로 실행되는 기능을 구현 Invoker : 기능의 실행을 요청하는 호출자(Button) Receiver : Concrete Command의 기능을 실행하기 위해 사용하는 수신자 클래스 마치며커맨드 패턴(Command Pattern)의 개념과 관련해 추가적인 질문이나 오류, 오타가 있을시 댓글로 남겨주세요. 출처JAVA 객체지향 디자인패턴","categories":[{"name":"design pattern","slug":"design-pattern","permalink":"http://DongyeolLee.github.io/categories/design-pattern/"},{"name":"java","slug":"design-pattern/java","permalink":"http://DongyeolLee.github.io/categories/design-pattern/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://DongyeolLee.github.io/tags/java/"},{"name":"design pattern","slug":"design-pattern","permalink":"http://DongyeolLee.github.io/tags/design-pattern/"}]},{"title":"백준[1389] - 케빈 베이컨의 6단계 법칙","slug":"Al/1389","date":"2018-09-24T16:02:03.000Z","updated":"2019-04-30T07:24:41.149Z","comments":true,"path":"2018/09/25/Al/1389/","link":"","permalink":"http://DongyeolLee.github.io/2018/09/25/Al/1389/","excerpt":"","text":"문제백준 1389 문제 보기 접근 방법유저의 숫자가 주어진다면 각 유저들간 친구 관계를 파악하기 위해 모든 유저를 상대로 dfs 탐색을 진행한다. 유저 1과 나머지 유저들 간의 친구 관계를 계산하기 위해 유저 1 대상으로 연결 요소를 완전 탐색하고 거리차를 증가한다. 각 친구들까지의 거리차를 cnt 배열에 따로 저장한다. 탐색이 완료되면 총 거리를 계산한다. cnt 배열을 초기화하고 다음 유저에 대해서 위의 과정을 반복한다. 코드#include &ltiostream&gt #include &ltvector> #include &ltcstring> #include &ltalgorithm> using namespace std; int N, M, person = 101, ans = 987654321; int cnt[101]; vector&ltvector&ltint>> relation(101); // diff: 지정된 친구로부터 거리차, num: 친구 번호 void dfs(int diff, int num) { // cnt[num]에 거리차를 저장 if(cnt[num] != 0) { cnt[num] = min(diff, cnt[num]); } else { cnt[num] = diff; } // 연결된 친구 모두 탐색 for(int j = 0; j < relation[num].size(); j ++) { int next = relation[num][j]; // 친구를 포함하지 않았거나 더 가까운 사이의 친구라면 탐색 if(cnt[next] == 0 || cnt[next] > diff + 1 ) { dfs(diff + 1, next); } } } int main() { cin >> N >> M; for(int i = 0; i < M; i ++) { int from, to; cin >> from >> to; // 양방향 저장 relation[from].push_back(to); relation[to].push_back(from); } for(int i = 1; i &lt= N; i ++) { // 친구들과의 거리차 초기화 memset(cnt, 0, sizeof(cnt)); for(int j = 0; j < relation[i].size(); j ++) { dfs(1, relation[i][j]); } int temp = 0; for(int j = 1; j &lt= N; j ++) { if(j == i) { continue; } temp += cnt[j]; } // 최소인지 검사 if(ans > temp) { ans = temp; person = i; } else if(ans == temp) { person = min(person, i); } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[6603] - 로또","slug":"Al/6603","date":"2018-09-23T06:54:18.000Z","updated":"2019-04-30T07:24:41.158Z","comments":true,"path":"2018/09/23/Al/6603/","link":"","permalink":"http://DongyeolLee.github.io/2018/09/23/Al/6603/","excerpt":"","text":"문제백준 6603 문제 보기 접근 방법숫자가 주어지면 중복없이 6자리 숫자를 만들고 출력하면 된다.ans 배열에 선택한 숫자를 저장한다. 숫자를 선택할때는 다음과 같은 규칙을 따른다. ans의 첫번째 숫자는 모든 숫자의 범위에서 선택한다. ans의 두번째 숫자는 이전 선택한 수 보다 +1한 범위에서 숫자를 선택한다. (ex. 숫자가 1 ~ 10까지 주어졌을때 첫번째 숫자로 3을 선택했다면 두번째 선택할 숫자의 범위를 4 ~ 10으로 한정한다.) 이후 3번째 숫자를 선택할때는 규칙 2를 반복한다. 코드#include &ltiostream&gt #include &ltvector> using namespace std; int K; int ans[6]; vector&ltint> v; // depth: 숫자의 길이, num: 선택할 숫자 void dfs(int depth, int num) { // 6자리면 출력 if(depth == 6) { for(int i = 0; i < 6; i ++) { cout > num; // 숫자를 모두 벡터에 저장 v.push_back(num); } dfs(0, 0); cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1051] - 숫자 정사각형","slug":"Al/1051","date":"2018-09-18T14:18:02.000Z","updated":"2019-04-30T07:24:41.144Z","comments":true,"path":"2018/09/18/Al/1051/","link":"","permalink":"http://DongyeolLee.github.io/2018/09/18/Al/1051/","excerpt":"","text":"문제백준 1051 문제 보기 접근 방법입력된 이차원 배열의 숫자들을 모두 순회하며 순차적으로 정사각형을 만들어 본다. 코드#include &ltiostream&gt #include &ltalgorithm> using namespace std; int N, M, ans = 0; char map[51][51]; int main() { cin >> N >> M; for(int r = 0; r < N; r ++) { for(int c = 0; c < M; c ++) { scanf(\" %c\", &map[r][c]); } } // 입력된 사각형의 변 중에 작은 값을 저장 int num = min(N, M); // 모든 점을 순회하며 정사각형을 조회 for(int r = 0; r < N; r ++) { for(int c = 0; c < M; c ++) { // 만들수 있는 가장 큰 정사각형까지 만듬 for(int len = 0; len < num; len ++) { if(r + len < N && c + len < M) { char s1 = map[r][c]; char s2 = map[r + len][c]; char s3 = map[r][c + len]; char s4 = map[r + len][c + len]; if((s1 == s2) && (s3 == s4) && (s1 == s3) && (s1 == s4) && (s2 == s3) && (s2 == s4) && (s3 == s4)) { // 사이즈 저장 ans = max(ans, (len + 1) * (len + 1)); } } } } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[9517] - 아이 러브 크로아티아","slug":"Al/9517","date":"2018-09-09T19:15:00.000Z","updated":"2019-04-30T07:24:41.160Z","comments":true,"path":"2018/09/10/Al/9517/","link":"","permalink":"http://DongyeolLee.github.io/2018/09/10/Al/9517/","excerpt":"","text":"문제백준 9517 문제 보기 접근 방법단순한 구현 문제이다. 문제에서 요구하는 조건에 맞춰 구현을 하면 정답을 출력할 수 있다. 코드#include &ltiostream&gt #include &ltvector> using namespace std; int K, N, T, remain_time = 210; char Z; vector&ltpair&ltint, char>> arr; int main() { cin >> K >> N; for(int i = 0; i < N; i ++) { cin >> T >> Z; arr.push_back({ T, Z }); } for(int i = 0; i < arr.size(); i ++) { int time = arr[i].first; char ans = arr[i].second; if(ans == 'T') { remain_time -= time; if(remain_time < 0) { int num = K % 8 == 0? 8 : K % 8; cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1600] - 말이 되고픈 원숭이","slug":"Al/1600","date":"2018-09-08T11:40:40.000Z","updated":"2019-04-30T07:24:41.152Z","comments":true,"path":"2018/09/08/Al/1600/","link":"","permalink":"http://DongyeolLee.github.io/2018/09/08/Al/1600/","excerpt":"","text":"문제백준 1600 문제 보기 접근 방법bfs를 활용해 문제를 풀면 되지만 주의해야할 점은 바로 원숭이가 말 움직임 횟수에 따라 같은 좌표라도 결과가 다를수 있다는 점이다. 코드#include &ltiostream&gt #include &ltqueue> using namespace std; struct info { int r; int c; // 말 움직임 사용 횟수 int cnt; int ans; }; bool flag = false; int K, W, H; int map[201][201]; int visited[201][201][31]; // 말 움직임 int dr[8] = {-1, -2, -2, -1, 1, 2, 2, 1}; int dc[8] = {-2, -1, 1, 2, 2, 1, -1, -2}; // 위, 오른쪽, 아래, 왼쪽 int dr2[4] = {-1, 0, 1, 0}; int dc2[4] = {0, 1, 0, -1}; queue&ltinfo> q; int main() { cin >> K >> W >> H; for(int r = 0; r < H; r ++) { for(int c = 0; c < W; c ++) { cin >> map[r][c]; } } // r, c, 말 움직임 횟수 visited[0][0][0] = 1; q.push({0, 0, 0, 0}); while(!q.empty()) { int r = q.front().r; int c = q.front().c; int cnt = q.front().cnt; int ans = q.front().ans; q.pop(); // 도착지라면 정답 출력 if(r == H - 1 && c == W - 1) { flag = true; cout = 0 && nr < H && nc >= 0 && nc < W) { if(!map[nr][nc] && !visited[nr][nc][cnt + 1]) { visited[nr][nc][cnt + 1] = 1; q.push({nr, nc, cnt + 1, ans + 1}); } } } } // 위, 오른쪽, 아래, 왼쪽 이동 for(int i = 0; i < 4; i ++) { int nr = r + dr2[i]; int nc = c + dc2[i]; if(nr >= 0 && nr < H && nc >= 0 && nc < W) { if(!map[nr][nc] && !visited[nr][nc][cnt]){ visited[nr][nc][cnt] = 1; q.push({nr, nc, cnt, ans + 1}); } } } } if(!flag) cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[2580] - 스도쿠","slug":"Al/2580","date":"2018-09-03T14:12:10.000Z","updated":"2019-04-30T07:24:41.156Z","comments":true,"path":"2018/09/03/Al/2580/","link":"","permalink":"http://DongyeolLee.github.io/2018/09/03/Al/2580/","excerpt":"","text":"문제백준 2580 문제 보기 접근 방법백트래킹을 활용해서 문제를 풀수 있다. 입력받은 값들 중 빈 좌표를 따로 저장 첫번째 저장된 좌표에 1~9까지 숫자를 대입하여 현재 스도쿠를 만족하는지 검사 만족한다면 다음 좌표에서 1~9까지 숫자를 대입하고 검사를 반복 코드#include &ltiostream&gt #include &ltvector> #include &ltutility> #include &ltcstdlib> using namespace std; int sudoku[9][9]; vector&ltpair&ltint, int>> arr; // 똑같은 숫자가 있는지 세로 검사 bool chk_vertical(int c, int num) { for(int r = 0; r < 9; r ++) { if(sudoku[r][c] == num) { return false; } } return true; } // 가로 검사 bool chk_horizontal(int r, int num) { for(int c = 0; c < 9; c ++) { if(sudoku[r][c] == num) { return false; } } return true; } // 3*3 네모난 모양 검사 bool chk_square(int r, int c, int num) { r = r / 3; c = c / 3; for(int rr = r * 3; rr < (r * 3) + 3; rr ++) { for(int cc = c * 3 ; cc < (c * 3) + 3; cc ++) { if(sudoku[rr][cc] == num) { return false; } } } return true; } void dfs(int idx) { // 모든 좌표에 숫자를 넣었다면 정답 출력 if(idx == arr.size()) { for(int i = 0; i < 9; i ++) { for(int j = 0; j < 9; j ++) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1339] - 단어 수학","slug":"Al/1339","date":"2018-09-03T07:46:16.000Z","updated":"2019-04-30T07:24:41.148Z","comments":true,"path":"2018/09/03/Al/1339/","link":"","permalink":"http://DongyeolLee.github.io/2018/09/03/Al/1339/","excerpt":"","text":"문제백준 1339 문제 보기 접근 방법여러 풀이 방법이 존재하지만 나는 모든 알파벳 조합을 만들고 수를 대입하는 방법으로 문제를 풀었다. 먼저, set을 활용해 중복없이 알파벳을 저장한다. set에 저장된 알파벳을 벡터에 저장한뒤 오름 차순으로 정렬한다. next_permutaion을 활용해 모든 조합을 만들어본다. 코드#include &ltiostream&gt #include &ltvector> #include &ltset> #include &ltcmath> #include &ltalgorithm> using namespace std; int N, ans = 0; vector&ltchar> t; vector&ltstring> st; set&ltchar> s; int arr[150]; // A == 65 int main() { cin >> N; for(int i = 0; i < N; i ++) { string temp; cin >> temp; // 문자열 저장 st.push_back(temp); // 알파벳을 중복없이 저장 for(int j = 0; j < temp.size(); j ++) { s.insert(temp[j]); } } // 알파벳을 벡터에 저장 for(auto i = s.begin(); i != s.end(); i ++) { char c = *i; t.push_back(c); } // 오름차순 정렬 sort(t.begin(), t.end()); do { // 앞에서부터 하나씩 선택 for(int i = 0, j = 9; i < t.size(); i ++, j --) { arr[t[i] - '0'] = j; } int sum = 0, tmp = 0; for(int i = 0; i < N; i ++, tmp = 0) { for(int j = 0; j < st[i].size(); j ++, tmp *= 10) { tmp += arr[st[i][j] - '0']; } sum += (tmp/10); } ans = max(ans, sum); } while(next_permutation(t.begin(), t.end())); cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1018] - 체스판 다시 칠하기","slug":"Al/1018","date":"2018-08-28T03:57:22.000Z","updated":"2019-04-30T07:24:41.143Z","comments":true,"path":"2018/08/28/Al/1018/","link":"","permalink":"http://DongyeolLee.github.io/2018/08/28/Al/1018/","excerpt":"","text":"문제백준 1018 문제 보기 접근 방법각 (0, 0)부터 (N - 7, M - 7)까지 8 * 8의 죄판을 그릴 수 있다. 각 점을 돌면서 B, W를 한번씩 수행하고 정답을 출력한다. 코드#include &ltiostream&gt #include &ltcstring> using namespace std; int N, M; int map[51][51]; int map_copied[51][51]; int check[51][51]; int dr[4] = {-1, 0, 1, 0}; int dc[4] = {0, 1, 0, -1}; int sr, sc; int cnt, ans = 987654321; void brute(int r, int c, int num) { // 현재 좌표가 가져야할 색이 아니면 if(map_copied[r][c] != num) { // 색을 바꾸고 map_copied[r][c] = num; // 카운트 증가 cnt ++; } // 방문 체크 check[r][c] = 1; // 4방향 검사 for(int i = 0; i < 4; i ++) { int nextR = r + dr[i]; int nextC = c + dc[i]; if(nextR >= sr && nextC >= sc && nextC < sc + 8 && nextR < sr + 8){ if(!check[nextR][nextC]) { // 다음 색은 현재 색과 무조건 대치 brute(nextR, nextC, -num); } } } } int main() { cin >> N >> M; for(int i = 0; i < N; i ++) { for(int j = 0; j < M; j ++) { char temp; scanf(\" %c\", &temp); if(temp == 'W') { // 흰색이라면 1 저장 map[i][j] = 1; } else { // 검정이라면 -1 저장 map[i][j] = -1; } } } // 8 * 8 모든 범위 계산 for(int i = 0; i < N - 7; i ++) { for(int j = 0; j < M - 7; j ++) { // map 복사 memcpy(map_copied, map, sizeof(map)); // 방문 여부 초기화 memset(check, 0, sizeof(check)); // 시작 위치 저장, 카운트 초기화 sr = i, sc = j, cnt = 0; // 검정색부터 완전 탐색 시작 brute(i, j, -1); // 최소 저장 ans = min(ans, cnt); memcpy(map_copied, map, sizeof(map)); memset(check, 0, sizeof(check)); cnt = 0; brute(i, j, 1); ans = min(ans, cnt); } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"합병 정렬(Merge sort)","slug":"Datastructure/MergeSort","date":"2018-08-21T20:42:34.000Z","updated":"2019-04-30T07:24:41.160Z","comments":true,"path":"2018/08/22/Datastructure/MergeSort/","link":"","permalink":"http://DongyeolLee.github.io/2018/08/22/Datastructure/MergeSort/","excerpt":"","text":"#들어가기이번 포스팅에서는 합병 정렬(merge sort)에 대해 알아보겠습니다. #합병 정렬(merge sort)합병 정렬(merge sort)은 분할 정복법을 활용한 sort 방법입니다. 분할 정복법은 익히 들어본바와 같이 다음과 같습니다. 분할 : 해결하고자 하는 문제를 작은 크기의 동일한 문제들로 분할 정복 : 각각의 작은 문제를 순환적으로 해결 합병 : 작은 문제의 해를 합하여(merge) 원래 문제에 대한 해를 구함 그렇다면 이 분할정복법을 어떻게 활용해서 합병 정렬(merge sort)을 할수 있을까요? 데이터가 저장된 배열을 절반으로 나눔 각각을 순환적으로 정렬 정렬된 분할된 리스트를 전체 배열로 합침 문자로 표현하니 조금 난해한 느낌이 있어 다시 그림으로 보겠습니다. 맨 밑에 있는 숫자들이 정렬을 해야하는 숫자들 입니다. 즉, 5-2-4-7-1-3-2-6이 있는 배열을 최대한 작게 나눈 다음 다시 합치는 과정을 그림에서 확인할 수 있습니다. 이제 수도 코드로 간단하게 표현해보겠습니다. mergeSort(A[], p, r) { // A[p...r]을 정렬 if(p < r) then { q &lt- (p+r)/2 // 중간 지점을 찾음 mergeSort(A, p, q); // 앞 부분 정렬 mergeSort(A, q+1, r); // 뒷 부분 정렬 merge(A, p, q, r) // 합병 } } void merge(int data[], int p, int q, int r) { int i = p, j = q+1, k=p; int tmp[data.length()]; while(i &lt= q && j &lt= r) { if(data[i] &lt= data[j]) tmp[k++] = data[i++]; else tmp[k++] = data[j++]; } while(i &lt= q) tmp[k++] = data[i++]; while(j &lt= r) tmp[k++] = data[j++]; for(int i = p; i &lt= r; i ++) data[i] = tmp[i]; } 보시는 것과 같이 합병 정렬(merge sort)은 추가적인 배열(tmp)이 필요합니다. 합병 정렬(merge sort)의 시간 복잡도를 확인해본다면 O(nlogn) 입니다. 이는 합병 정렬(merge sort)가 어떻게 동작하는가를 생각해본다면 쉽게 나올수 있습니다. 즉, 길이가 N인 배열을 계속 반으로 나누는 작업을 진행(O(logn))하면서 합병(O(N))을 수행하기 때문 시간 복잡도는 O(nlogn) 입니다. #마치며이로써 합병 정렬(merge sort)의 정리를 마치겠습니다. #참조부경대학교 권오흠 교수님 강의 | 2015년 1학기","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"concepts","slug":"computer-science/algorithms/concepts","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/concepts/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"},{"name":"sort","slug":"sort","permalink":"http://DongyeolLee.github.io/tags/sort/"},{"name":"merge sort","slug":"merge-sort","permalink":"http://DongyeolLee.github.io/tags/merge-sort/"}]},{"title":"백준[1325] - 효율적인 해킹","slug":"Al/1325","date":"2018-08-21T10:48:18.000Z","updated":"2019-04-30T07:24:41.147Z","comments":true,"path":"2018/08/21/Al/1325/","link":"","permalink":"http://DongyeolLee.github.io/2018/08/21/Al/1325/","excerpt":"","text":"문제백준 1325 문제 보기 접근 방법각 컴퓨터들은 연결된 그래프로 표현할 수 있다. 즉, 연결된 그래프 관계에서 최대 깊이 값을 찾아 정답을 출력하면 된다. 코드#include &ltiostream&gt #include &ltvector> #include &ltcstring> #include &ltalgorithm> using namespace std; int N, M, cnt; int ans[10001]; int hacked[10001]; vector&ltvector&ltint>> rel(10001); void dfs(int com) { if(hacked[com]) return; hacked[com] = 1; cnt ++; for(int i = 0; i < rel[com].size(); i ++) { dfs(rel[com][i]); } } int main() { // 컴퓨터, 연관 관계 cin >> N >> M; for(int i = 0; i < M; i ++) { int from, to; cin >> from >> to; // 해킹되면 피해 받는 컴퓨터 배열 rel[to].push_back(from); } // i번째 해킹 for(int i = 1; i &lt= N; i ++) { cnt = 0; memset(hacked, 0, sizeof(hacked)); dfs(i); ans[i] = cnt; } int max = -1; for(int i = 1; i &lt= N; i ++) { if(ans[i] > max) { max = ans[i]; } } for(int i = 1; i &lt= N; i ++) { if(max == ans[i]) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"State Pattern(스테이트 패턴)","slug":"Design Pattern/StatePattern","date":"2018-08-16T10:39:03.000Z","updated":"2019-04-30T07:24:41.162Z","comments":true,"path":"2018/08/16/Design Pattern/StatePattern/","link":"","permalink":"http://DongyeolLee.github.io/2018/08/16/Design Pattern/StatePattern/","excerpt":"","text":"들어가기이번 포스팅에서는 스테이트 패턴(State Pattern)에 대해서 알아보겠습니다. 본론스테이트 패턴(State Pattern)을 이용하면 객체의 내부 상태가 바뀜에 따라서 객체의 행동을 바꿀 수 있습니다. 마치 객체의 클래스가 바뀌는 것과 같은 결과를 얻을 수 있습니다. 하나의 예시로 형광들을 만들어 보겠습니다. 형광등을 만들려면 우선 형광등의 행위(기능)를 분석할 필요가 있습니다. On 스위치를 누를 경우, 불이 켜짐 Off 스위치를 누를 경우, 불이 꺼짐 만약 이미 형광등이 켜져있는 상태에서 On 스위치를 누른다면 그대로 켜져있고, Off도 마찬가지로 꺼져있는 상태에서 눌러도 형광등에는 변화가 없을것 입니다. 실제 이를 코드로 작성하기는 그렇게 어렵지 않습니다. public class Light { private static int ON = 0; private static int OFF = 1; private int state; // 현재 형광등의 상태 public Light() { state = OFF; // 초기 형광등은 OFF } public void on_button_pushed() { if(state == ON) { System.out.println(\"already ON state\"); } else { // 형광등이 꺼져있는 상태 System.out.println(\"Light ON\"); state = ON; } } public void off_button_pushed() { if(state == OFF) { System.out.println(\"already OFF state\"); } else { // 형광등이 켜져있는 상태 System.out.println(\"Light OFF\"); state = OFF; } } } public class Client { public static void main(String[] args) { Light light = new light(); light.off(); light.on(); light.off(); } } 하지만 다음과 같이 작성한 코드는 문제점을 가지고 있습니다. 형광등에 새로운 상태가 추가된다면 ?? 즉, OFF와 ON뿐만이 아니라 새롭게 취침등(SLEEPING)이 추가된다면 if ~ else 구문의 수정이 불가피합니다. OFF 상태에서는 SLEEPING으로 갈수 없고 ON 상태에서 on_button을 한번 다시 누른다면 SLEEPING 상태로 넘어가는 것을 가정으로 코드를 작성하겠습니다. public class Light { // 이전과 동일 private static int SLEEPING = 2; // 취침등 추가 public void on_button_pushed() { if(state == ON) { System.out.println(\"sleeping mode\"); state = SLEEPING; } else if(state == SLEEPING) { // 상태 추가에 따른 if문 추가 System.out.println(\"Light On\"); state = ON; } else { // 형광등이 꺼져있는 상태 System.out.println(\"Light ON\"); state = ON; } } } 지금은 간단한 상태를 가지는 조건문이지만, 조건문이 복잡해 상태 변화가 숨어 있는 경우 상태 변화가 어떻게 이루어지는지 이해하기 어렵고 새로운 상태 추가에 맞춰 모든 메서드를 수정해야합니다. 그럼 어떻게 문제를 해결할 수 있을까요? 이때 사용하는 패턴이 스테이트 패턴(State Pattern)입니다. 이번 예 역시 무엇이 변하는가를 찾아야 합니다. 따라서 변하는 것을 찾아 캡슐화를 해줘야합니다. 목표는 현재 시스템이 어떤 상태에 있는지와 상관없게 구성하고 상태 변화에도 독립적이도록 코드를 수정하는 것입니다. 이를 위해서 형광등이 가질수 있는 상태를 클래스로 분리해 캡슐화합니다. 또한 상태에 의존적인 행위들(버튼)도 같이 두어 특정상태에 따른 행위를 구현합니다. 위의 다이어그램은 형광등 만들기를 스테이트 패턴(State Pattern)을 사용하여 설계한 것입니다. 어떻습니까? 이전에 봤던 스트래티지 패턴이랑 비슷하지 않나요? 스테이트 패턴(State Pattern)은 거의 스트래티지 패턴과 유사하다고 볼수 있습니다. 다만, 상태를 가지고 있어 그 상태에 따라 동작하는 방식이 달라집니다. 또, 외부에서 변화를 주는 것이 아닌 Light 클래스가 변화에 중심이 있다는 것이 차이점입니다. 다시 위에서 그린 다이어그램을 토대로 코드로 옮겨보겠습니다. Light.java public class Light { private State state; public Light() { state = new OFF(); } public void setState(State state) { this.state = state; } public void on_button_pushed() { state.on_button_pushed(this); } public void off_button_pushed() { state.off_button_pushed(this); } } State.java public interface State { public void on_button_pushed(Light light); public void off_button_pushed(Light light); } ON.java public class ON implements State { @Override public void on_button_pushed(Light light) { System.out.println(\"already ON\"); } @Override public void off_button_pushed(Light light) { System.out.println(\"Light OFF\"); light.setState(new OFF()); } } OFF.java public class OFF implements State { @Override public void on_button_pushed(Light light) { System.out.println(\"Light ON\"); light.setState(new ON()); } @Override public void off_button_pushed(Light light) { System.out.println(\"already OFF\"); } } 위와 같은 코드는 시스템이 어떤 상태에 있는지와 무관하게 동작합니다. Light 클래스는 새로운 상태가 추가된다고해도 기존의 동작 방식이 바뀌지 않습니다. 정리하자면 스테이트 패턴(State Pattern)은 위에서 잠시 언급했던 것과 같이 상태에 따라 동작방식을 다르게 하는 패턴입니다. 어떤 행위를 수행할때 상태에 행위를 위임하는 방식입니다. 이를 위해, 스테이트 패턴(State Pattern)은 각 상태를 클래스로 분리하고 클래스에서 수행하는 행위들을 메서드로 구현하는 것입니다. 마치며스테이트 패턴(State Pattern)에 대해 알아보았습니다. 추가적인 질문은 댓글로 남겨주세요. 출처JAVA 객체지향 디자인패턴","categories":[{"name":"design pattern","slug":"design-pattern","permalink":"http://DongyeolLee.github.io/categories/design-pattern/"},{"name":"java","slug":"design-pattern/java","permalink":"http://DongyeolLee.github.io/categories/design-pattern/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://DongyeolLee.github.io/tags/java/"},{"name":"design pattern","slug":"design-pattern","permalink":"http://DongyeolLee.github.io/tags/design-pattern/"}]},{"title":"백준[15685] - 드래곤 커브","slug":"Al/15685","date":"2018-08-13T18:35:36.000Z","updated":"2019-04-30T07:24:41.152Z","comments":true,"path":"2018/08/14/Al/15685/","link":"","permalink":"http://DongyeolLee.github.io/2018/08/14/Al/15685/","excerpt":"","text":"문제백준 15685 문제 보기 접근 방법구현 문제로 주어진 조건을 잘 코드로 만들면 된다. 핵심은 이전 세대의 진행 방향의 역순을 취하여 새로운 방향을 만드는데 있다. 코드#include &ltiostream&gt #include &ltvector> using namespace std; int map[101][101]; int N, x, y, d, g; vector&ltint> directions; int getDir(int dir) { if(dir == 0) { return 1; } else if(dir == 1) { return 2; } else if(dir == 2) { return 3; } else { return 0; } } int main() { cin >> N; for(int i = 0; i < N; i ++) { cin >> x >> y >> d >> g; // 초기화 directions.clear(); // 첫 진행 방향 저장 directions.push_back(d); // 드래곤 커브 그리기 while(g--) { // 저장된 방향을 역순으로 꺼냄 for(int a = directions.size() - 1; a >= 0; a --) { // 이전 방향에서 90도 꺽인 값 저장 int dir = directions[a]; directions.push_back(getDir(dir)); } } // 입력된 좌표 저장 map[x][y] = 1; // 나머지 좌표를 그림 for(int j = 0; j < directions.size(); j ++) { int dir = directions[j]; if(dir == 0) { x++; } else if(dir == 1) { y--; } else if(dir == 2) { x--; } else { y++; } map[x][y] = 1; } } int result = 0; for (int i = 0; i < 100; i++) { for (int j = 0; j < 100; j++) { if (map[i][j] && map[i][j + 1] && map[i + 1][j] && map[i + 1][j + 1]) { result++; } } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[2573] - 빙산","slug":"Al/2573","date":"2018-08-13T18:35:22.000Z","updated":"2019-04-30T07:24:41.156Z","comments":true,"path":"2018/08/14/Al/2573/","link":"","permalink":"http://DongyeolLee.github.io/2018/08/14/Al/2573/","excerpt":"","text":"문제백준 2573 문제 보기 접근 방법빙산을 주변으로 4방향을 검사한 뒤 각 면이 몇개의 바다에 둘러 쌓여 있는지 모두 확인한다. 그리고 완전 탐색을 이용해 빙산이 분리됐는지 체크한다. 코드#include &ltiostream&gt #include &ltvector> #include &ltcstring> using namespace std; int r, c; int map[301][301]; int visited[301][301]; int map_copied[301][301]; vector&ltpair&ltint, int>> ice; int dr[4] = {-1, 0, 1, 0}; int dc[4] = {0, 1, 0, -1}; void dfs(int rr, int cc) { for(int a = 0; a < 4; a ++) { int nextR = rr + dr[a]; int nextC = cc + dc[a]; if(nextC >= 0 && nextR >= 0 && nextC < c && nextR < r) { if(map[nextR][nextC] > 0 && visited[nextR][nextC] != 1) { visited[nextR][nextC] = 1; dfs(nextR, nextC); } } } } int main() { cin >> r >> c; for(int i = 0; i < r; i ++) { for(int j = 0; j < c; j ++) { cin >> map[i][j]; if(map[i][j] > 0) { // 빙산의 좌표 저장 ice.push_back({i, j}); } } } // 년수 초기화 int year = 0; while(1) { memset(map_copied, 0, sizeof(map_copied)); memset(visited, 0, sizeof(visited)); year ++; for(int i = 0; i < ice.size(); i ++) { int rr = ice[i].first; int cc = ice[i].second; int cnt = 0; // 빙산이 존재한다면 if(map[rr][cc] > 0) { // 4방향으로 바다가 존재하는지 검사 for(int a = 0; a < 4; a ++) { int nextR = rr + dr[a]; int nextC = cc + dc[a]; if(nextC >= 0 && nextR >= 0 && nextC < c && nextR < r) { if(map[nextR][nextC] == 0) { cnt ++; } } } } // 1년후 빙산의 높이 int num = map[rr][cc] - cnt; if(num > 0) map_copied[rr][cc] = num; else map_copied[rr][cc] = 0; } // 기존 맵에 감소한 빙산 높이를 저장 memcpy(map, map_copied, sizeof(map_copied)); int ans = 0; // 검사 for(int i = 0; i < r; i ++) { for(int j = 0; j < c; j ++) { if(map[i][j] > 0 && visited[i][j] != 1) { visited[i][j] = 1; dfs(i, j); ans ++; } } } if(ans > 1) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[2589] - 보물섬","slug":"Al/2589","date":"2018-08-13T18:35:14.000Z","updated":"2019-04-30T07:24:41.156Z","comments":true,"path":"2018/08/14/Al/2589/","link":"","permalink":"http://DongyeolLee.github.io/2018/08/14/Al/2589/","excerpt":"","text":"문제백준 2589 문제 보기 접근 방법모든 땅에서 bfs를 진행하고 그 중에서 가장 큰 값을 찾는다. 코드#include &ltiostream&gt #include &ltalgorithm> #include &ltcstring> #include &ltqueue> using namespace std; struct location { int r; int c; int cnt; }; int r, c, ans = -1; char arr[51][51]; int visited[51][51]; int dr[4] = {-1 , 0, 1, 0}; int dc[4] = {0, 1, 0, -1}; queue&ltlocation> q; int main() { scanf(\"%d %d\\n\", &r, &c); for(int i = 0; i < r; i ++) { for(int j = 0; j < c; j ++) { scanf(\"%c\", &arr[i][j]); } getchar(); } for(int i = 0; i < r; i ++) { for(int j = 0; j < c; j ++) { if(arr[i][j] == 'L') { memset(visited, 0, sizeof(visited)); visited[i][j] = 1; q.push({i, j, 0}); while(!q.empty()) { int rr = q.front().r; int cc = q.front().c; int cnt = q.front().cnt; ans = max(ans, cnt); q.pop(); for(int a = 0; a < 4; a ++) { int nextR = rr + dr[a]; int nextC = cc + dc[a]; if(nextC >= 0 && nextR >= 0 && nextC < c && nextR < r) { if(arr[nextR][nextC] == 'L' && visited[nextR][nextC] != 1) { visited[nextR][nextC] = 1; q.push({nextR, nextC, cnt + 1}); } } } } } } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"Singleton Pattern(싱글톤 패턴)","slug":"Design Pattern/SingletonPattern","date":"2018-08-12T16:19:18.000Z","updated":"2019-04-30T07:24:41.161Z","comments":true,"path":"2018/08/13/Design Pattern/SingletonPattern/","link":"","permalink":"http://DongyeolLee.github.io/2018/08/13/Design Pattern/SingletonPattern/","excerpt":"","text":"들어가기이번 포스팅에서는 디자인 패턴에서 유명한 싱글톤 패턴(Singleton Pattern) 에 대해서 알아보겠습니다. 본론싱글톤 패턴(Singleton Pattern) 은 특정 클래스에 대해 객체 인스턴스가 하나만 만들어질 수 있도록 해주는 패턴입니다. 간단하게 말하면, 싱글톤 패턴(Singleton Pattern) 은 어떤 상황에서든 해당 객체의 인스턴스는 하나만 존재해야하고 이를 사용하기 위해서는 새롭게 인스턴스를 생성하는 것이 아닌 이미 생성된 인스턴스를 사용해야합니다. 그렇다면 이런 싱글톤 패턴(Singleton Pattern) 의 객체를 어떻게 만들수 있을까요? 1. 고전적인 방법public class Singleton { private static Singleton s; private Singleton() {} public static Singleton getInstance() { if(s == null) { s = new Singleton(); } return s; } } 위에 보인 예시는 아주 고전적인 방법의 예시입니다. 객체를 생성할 수 있는 생성자를 private로 캡슐화했습니다. 즉, 싱글톤 (Singleton Pattern) 객체를 만들기 위해서는 직접 생성자를 호출하는 방식이 아닌 class 내부의 getInstance 메서드를 활용해야만 합니다. 그리고 getInstance 메서드는 이미 인스턴스가 존재하는지 확인한 후 존재한다면 기존의 인스턴스를 반환하고 아니면 인스턴스를 생성한뒤 반환합니다. 인스턴스를 프로그램 시작과 동시에 생성하는 것이 아니라 상황에 따라 필요할때 getInstance 메서드를 호출하고 생성해 사용하고 있으며 이와 같은 방식을 Lazy Loading(지연 로딩) 이라고 부릅니다. 하지만 고전적인 방법 multi-threaded(다중 스레드) 환경에서 문제를 야기합니다. 다음과 같은 상황을 한번 생각해봅시다. Singleton 인스턴스가 아직 생성되지 않은 초기 상황에서 스레드 1이 getInstance를 호출해 if문을 실행 만약 스레드 1이 생성자를 호출해 인스턴스를 만들기 전에 거의 비슷한 시점에 스레드 2도 if문을 실행 인스턴스가 2개가 생성 2. synchrozied 사용multi-threaded(다중 스레드)환경에서 싱글톤 패턴(Singleton Pattern)를 활용하기 위해서는 앞서 예시에서 봤던 것처럼 동기화가 필수입니다. 그리고 자바를 공부해보신 여러분이라면 synchronized라는 동기화 처리 방법을 알고 계실겁니다. public class Singleton { private static Singleton s; private Singleton() {} public static synchronized Singleton getInstance() { if(s == null) { s = new Singleton(); } return s; } } synchronized를 사용한다면 getInstance 메서드는 스레드간에 동기화가 처리되어 동시에 접근할 수 없게 됩니다. 즉, 두 스레드가 동시에 getInstance에 접근하여 인스턴스를 동시 생성할 수 없게 됩니다. 이렇게해서 프로그램 상에서 하나의 유일 인스턴스를 생성했습니다. 문제없이 잘 생성됩니다. 하지만 synchronized를 사용하면서 또 다른 문제가 발생합니다. 바로 여러분들고 알고 계시는 속도 문제입니다. synchronized를 사용하면서 getInstance를 실행할때 마다 속도가 급격하게 감소합니다. 3. synchrozied 사용 - 정적 초기화synchronized의 사용으로 급격하게 떨어진 속도를 조금이나마 올리기 위해 인스턴스 자체를 getInstance로 생성하는 것이 아닌 클래스가 로딩될때 jvm에서 인스턴스로 생성하는 방식입니다. public class Singleton { private static Singleton s = new Singleton(); private Singleton() {} public static synchronized Singleton getInstance() { return s; } } 보이는 것과 같이 getIntance에서는 인스턴스를 생성하지 않습니다. 하지만 이 방법도 문제점을 가지고 있습니다. 만약 getInstance 자체가 또 다른 자원을 많이 필요로 하면 속도가 느려지는 것을 막을수 없습니다. 다른 문제점은 인스턴스 자체가 필요할때 메모리에 올려 사용하지 않고 프로그램 시작서부터 메모리를 사용한다는 문제가 있습니다. 4. synchrozied 사용 - DCL(Double-Checking Locking)DCL(Double-Checking Locking) 을 사용하면 Lazy Loading을 할 수 있는 동시에 synchronized 역시 효율적으로 사용할 수 있습니다. public class Singleton { private volatile static Singleton s; private Singleton() {} public static Singleton getInstance() { if(s == null) { synchronized(Singleton.class) { if(s == null) { s = new Singleton(); } } } return s; } } 인스턴스가 생성되지 않았다면 생성될 때 최초 한 번만 동기화를 진행한 뒤 인스턴스를 생성합니다. 다만 DCL은 Multi-processor가 shared-memory를 사용하면서 문제가 발생하기 쉽다고 합니다. 따라서 안정성이 불안하다면 이 방법은 사용하지 않는 것이 좋습니다. 또, 멀티코어 환경에서 하나의 CPU를 제외하고는 다른 CPU가 lock이 걸리게 됩니다. 5. Demand Holder Idiompublic class Singleton { private Singleton() {} private static class LazyHolder { static final Singleton s = new Singleton(); } public static Singleton getInstance() { return LazyHolder.s; } } 이 방법은 중첩 클래스를 이용한 Holder를 사용하는 방법입니다. getInstance 메서드가 호출되기 전까지는 인스턴스가 생성되지 않습니다. Lazy Loading을 활용해 메모리 측면에서도 유리하고 synchronized를 사용하지 않아 성능면에서도 우수합니다. Demand Holder Idiom 방식은 현재 가장 널리 쓰이는 방법 중 하나 입니다. 싱글톤 패턴과 정적 클래스실제로 굳이 싱글톤 패턴(Singleton Pattern)을 사용하지 않고 정적 메서드로만 이루어진 정적 클래스를 사용해도 비슷한 효과를 만들수 있습니다. 하지만 싱글톤 패턴(Singleton Pattern)을 이용하는 방법과 가장 차이가 나는 점은 객체를 생성하지 않고 메서드만 이용한다는 점입니다. 마치며오늘은싱글톤 패턴(Singleton Pattern)에 대해 알아봤습니다. 싱글톤 패턴(Singleton Pattern)의 개념과 관련해 추가적인 질문이나 오류, 오타가 있을시 댓글로 남겨주세요. 출처JAVA 객체지향 디자인패턴","categories":[{"name":"design pattern","slug":"design-pattern","permalink":"http://DongyeolLee.github.io/categories/design-pattern/"},{"name":"java","slug":"design-pattern/java","permalink":"http://DongyeolLee.github.io/categories/design-pattern/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://DongyeolLee.github.io/tags/java/"},{"name":"design pattern","slug":"design-pattern","permalink":"http://DongyeolLee.github.io/tags/design-pattern/"}]},{"title":"백준[9471] - 피사노 주기","slug":"Al/9471","date":"2018-08-09T13:14:16.000Z","updated":"2019-04-30T07:24:41.159Z","comments":true,"path":"2018/08/09/Al/9471/","link":"","permalink":"http://DongyeolLee.github.io/2018/08/09/Al/9471/","excerpt":"","text":"문제백준 9471 문제 보기 접근 방법피보나치 수열을 특정 값으로 나눈 나머지가 주기를 이룬다는 피사노 주기를 구현하는 문제이다. 배열을 사용하면 간단하게 풀수 있지만 데이터의 범위가 너무 많아 배열은 사용할 수 없다.새롭게 생각한 방법은 피보나치 수열을 계속 구하되 n-2와 n-1이 수열의 시작인 0과 1일 경우 주기가 시작되는 위치라는 점을 활용했다. 코드#include &ltiostream&gt using namespace std; int T, m, m1, m2, cnt; int main() { int n; cin >> n; while (n--) { cin >> T >> m; m1 = 0; m2 = 1; cnt = 0; while(1) { if(m1 == 0 && m2 == 1 && cnt != 0) { break; } int temp = m1; m1 = m2; m2 = (temp + m1) % m; cnt ++; } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"Strategy Pattern(스트래티지 패턴)","slug":"Design Pattern/StrategyPattern","date":"2018-08-05T16:54:44.000Z","updated":"2019-04-30T07:24:41.162Z","comments":true,"path":"2018/08/06/Design Pattern/StrategyPattern/","link":"","permalink":"http://DongyeolLee.github.io/2018/08/06/Design Pattern/StrategyPattern/","excerpt":"","text":"들어가기이번 포스팅에서는 흔히 스트래티지 패턴(Strategy Pattern)으로 불리는 전략 패턴 에 대해서 알아보겠습니다. 본론먼저 본격적인 설명에 앞서 하나의 예시를 보겠습니다. 우리는 앞으로 두가지 타입의 로봇을 만들 예정입니다. 걸어다니고 미사일로 공격하는 태권V와 날아다니며 주먹으로 공격하는 아톰이라는 로봇입니다. 가장 쉽게 생각할 수 있는 방법은 Robot이라는 추상 클래스를 만들고 이를 상속하는 각각의 로봇을 만들어 로봇 타입에 맞는 방법으로 메서드를 재정의하는 방법입니다. 즉, 밑에 보여지는 다이어그램 같은 방법입니다. 다시 이 다이어그램을 코드로 옮겨보겠습니다. Robot.java public abstract class Robot { private String name; public Robot(String name) { this.name = name; } public String getName() { return name; } public abstract void attack(); public abstract void move(); } TaekwonV.java public class TaekwonV extends Robot { public TaekwonV(String name) { super(name); } @Override public void attack() { System.out.println(\"Missile Attack\"); } @Override public void move() { System.out.println(\"Walk\"); } } Atom.java public class Atom extends Robot { public Atom(String name) { super(name); } @Override public void attack() { System.out.println(\"Punch Attack\"); } @Override public void move() { System.out.println(\"Fly\"); } } Main.java public class Main { public static void main(String[] args) { Robot taekwonV = new TaekwonV(\"TaewonV\"); Robot atom = new Atom(\"atom\"); System.out.println(taekwonV.getName()); taekwonV.attack(); taekwonV.move(); System.out.println(\"-------------------------------------------------------\"); System.out.println(atom.getName()); atom.attack(); atom.move(); } } Main.java를 실행하여 출력물을 확인하면 우리가 구현하고자하는 로봇 타입을 다음과 같이 출력합니다. 하지만 위와 같은 설계는 문제점을 야기할 수 있는 설계입니다. 어떤점이 문제일까요? 만약 Atom과 완전 똑같은 기능을 수행하는 다른 로봇인 Mazinger를 추가하려면 어떻해야 할까요? 클래스를 하나 더 만들어 Robot 클래스를 상속하고 기능을 Atom과 똑같이 구현하면 문제는 해결됩니다. 여기서 특정 기능을 똑같이 필요로 하는 다른 로봇들이 많이 추가된다면 위와 같은 설계는 코드 중복을 야기합니다. 또 이에 따라 해당 기능이 오류가 있어 수정했다면 모든 중복된 코드를 일관성 있게 변경해야합니다. 과연 어떻게 위와 같은 문제를 해결할 수 있을까요?? 다른 로봇에 의해 자주 사용되고 수정되는 attack와 move 메서드를 추상화해 문제를 해결할 수 있습니다. 그럼 이전 다이어그램과 비교할때 어떻게 바뀌었을까요? 다소 복잡해지긴 했지만 무엇이 변화될것인지를 찾은 후에 이를 캡슐화한 과정입니다. 이와 같은 설계는 로봇 객체와는 상관없이 향후 등장할 이동방식과 공격방식의 변화뿐만 아니라 현재 변화도 잘 처리할 수 있게 만든 설계입니다. 변경점을 바탕으로 다시 코드를 수정해보겠습니다. AttackStrategy.java public interface AttackStrategy { public void attack(); } missileattack.java public class missileattack implements AttackStrategy { @Override public void attack() { System.out.println(\"Missile Attack\"); } } punchattack.java public class punchattack implements AttackStrategy { @Override public void attack() { System.out.println(\"Punch Attack\"); } } MoveStrategy.java public interface MoveStrategy { public void move(); } flymove.java public class flymove implements MoveStrategy { @Override public void move() { System.out.println(\"Fly\"); } } walkmove.java public class walkmove implements MoveStrategy { @Override public void move() { System.out.println(\"Walk\"); } } Robot.java public abstract class Robot { private String name; private MoveStrategy mv; private AttackStrategy at; public Robot(String name) { this.name = name; } public String getName() { return name; } public void move() { mv.move(); } public void attack() { at.attack(); } public void setMove(MoveStrategy move) { this.mv = move; } public void setAttack(AttackStrategy attack) { this.at = attack; } } Atom.java public class Atom extends Robot { public Atom(String name) { super(name); } } TaekwonV.java public class TaekwonV extends Robot { public TaekwonV(String name) { super(name); } } Main.java public class Main { public static void main(String[] args) { Robot taekwonV = new TaekwonV(\"TaewonV\"); taekwonV.setAttack(new missileattack()); taekwonV.setMove(new walkmove()); Robot atom = new Atom(\"atom\"); atom.setAttack(new punchattack()); atom.setMove(new flymove()); System.out.println(taekwonV.getName()); taekwonV.attack(); taekwonV.move(); System.out.println(\"-------------------------------------------------------\"); System.out.println(atom.getName()); atom.attack(); atom.move(); } } 새롭게 설계한 로봇은 이전 설계했던 로봇과 똑같은 결과값을 출력합니다. 하지만 이전 코드와 비교해 볼때 앞으로 발생할 코드의 중복을 줄일수 있게 되었고 또 현재 로봇들의 기능을 손쉽게 변경할수있게 됐습니다. 스트래티지 패턴(Strategy Pattern), 전략 패턴은 이와 같이 전략을 쉽게 바꿀 수 있도록 해주는 디자인 패턴입니다. 여기에서 전략이란 어떤 목적을 달성하기 위해 일을 수행하는 방식, 비즈니스 규칙, 문제를 해결하는 알고리즘 등으로 이해할 수 있습니다. 즉, 스트래티지 패턴(Strategy Pattern), 전략 패턴은 같은 문제를 해결하는 여러 알고리즘이 클래스 별로 캡슐화되어 있고 이들이 필요할 때 교체할 수 있도록 함으로써 동일한 문제를 다른 알고리즘으로 해결할 수 있게 하는 디자인 패턴입니다. 마치며스트래티지 패턴(Strategy Pattern), 전략 패턴의 개념과 관련해 추가적인 질문이나 오류, 오타가 있을시 댓글로 남겨주세요. 출처JAVA 객체지향 디자인패턴","categories":[{"name":"design pattern","slug":"design-pattern","permalink":"http://DongyeolLee.github.io/categories/design-pattern/"},{"name":"java","slug":"design-pattern/java","permalink":"http://DongyeolLee.github.io/categories/design-pattern/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://DongyeolLee.github.io/tags/java/"},{"name":"design pattern","slug":"design-pattern","permalink":"http://DongyeolLee.github.io/tags/design-pattern/"}]},{"title":"백준[10826] - 피보나치 수4","slug":"Al/10826","date":"2018-08-05T16:39:34.000Z","updated":"2019-04-30T07:24:41.144Z","comments":true,"path":"2018/08/06/Al/10826/","link":"","permalink":"http://DongyeolLee.github.io/2018/08/06/Al/10826/","excerpt":"","text":"문제백준 10826 문제 보기 접근 방법일반적인 피보나치 수열의 문제를 풀듯이 dp를 활용해 문제를 풀수는 있다. 하지만 이는 약 1500번째 언저리 피보나치 수까지만 유효하다. 왜냐하면 1500 번째 근처 수열에서 long long의 범위를 넘어간다.문제에서의 N은 10000이고 해당 수까지의 수열을 구해야 한다. 따라서 문자열을 활용해 직접 덧셈을 진행한다. 코드#include &ltiostream&gt #include &ltcstring> #include &ltalgorithm> using namespace std; string dp[10001]; int n; string calc(string s, string s2) { string ret; int len, len2; int a, b, carry_before, carry_now; len = s.length(); len2 = s2.length(); carry_now = 0; if (len < len2) { for (int i = 0; i < len2 - len; i++) { s.insert(s.begin(), '0'); } len = len2; } else if (len2 < len) { for (int i = 0; i < len - len2; i++) { s2.insert(s2.begin(), '0'); } } for (int i = len - 1; 0 &lt= i; i--) { a = s[i] - '0'; b = s2[i] - '0'; carry_before = carry_now; if (a + b + carry_before < 10) { carry_now = 0; ret += (a + b + carry_before) + '0'; } else { carry_now = 1; ret += (a + b + carry_before - 10) + '0'; if (i == 0 && carry_now == 1) ret += '1'; } } reverse(ret.begin(), ret.end()); return ret; } int main() { cin >> n; dp[0] = '0'; dp[1] = '1'; for (int i = 2; i &lt= n; i++) { dp[i] = calc(dp[i - 1], dp[i - 2]); } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[2749] - 피보나치 수3","slug":"Al/2749","date":"2018-07-31T01:43:25.000Z","updated":"2019-04-30T07:24:41.157Z","comments":true,"path":"2018/07/31/Al/2749/","link":"","permalink":"http://DongyeolLee.github.io/2018/07/31/Al/2749/","excerpt":"","text":"문제백준 2749 문제 보기 접근 방법피보나치 수열을 푸는 방식은 여러가지가 존재한다. 재귀를 활용하여 O(N^2)으로 푸는 방법, dp를 활용해 O(N)으로 푸는 방법이 많이 알려진 방식이다.하지만 이번 문제는 입력이 10^18이라는 거대한 숫자이므로 저 두 가지 방법 모두 해답은 아니다.여러가지 방법을 찾다가 피보나치 수열을 특정 수로 나눌때 주기가 존재한다는 pisano의 주기라는 방법을 알게되 이 방식을 적용해 풀었다. 코드#include &ltiostream&gt using namespace std; long long N; long long dp[1500010]; int main() { cin >> N; dp[0] = 0; dp[1] = 1; dp[2] = 1; if(N &lt= 2) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"객체지향 설계 5대 원칙 - SOLID 원칙","slug":"Design Pattern/SOLID","date":"2018-07-21T02:31:05.000Z","updated":"2019-04-30T07:24:41.161Z","comments":true,"path":"2018/07/21/Design Pattern/SOLID/","link":"","permalink":"http://DongyeolLee.github.io/2018/07/21/Design Pattern/SOLID/","excerpt":"","text":"들어가기SOLID(SRP, OCP, LSP, ISP, DIP)의 개념을 정리하고 이해해보겠습니다. 본론단일 책임 원칙SOLID의 첫 번째 원칙으로 단일 책임 원칙(Single Responsibiliy Principle)이 있습니다. 이는 말 그대로 객체는 단 하나의 책임만 가져야 한다는 의미입니다. 그렇다면 여기서 의미하는 책임이란 무엇일까요? 이는 객체가 해야하는 것 또는 가장 대표되는 기능으로 객체 자신만이 수행할 수 있는 기능을 의미합니다. public class Student { // 수강 과목 보기 public void getCourses() {...} // 새로운 과목 등록 public void setCourses() {...} // 데이터 베이스에 성적 저장 public void saveGrade() {...} // 데이터베이스에서 성적 조회 public void loadGrade() {...} // 성적표 출력 public void printOnReportCard() {...} // 출석부 출력 public void printOnAttendanceBook() {...} } 위의 예시를 한번 확인해봅시다. Student 클래스는 너무나 많은 책임을 수행해야합니다. 데이터베이스에 성적을 저장하거나 확인 또는 성적표와 출석부를 출력하는 일은 Student 클래스가 아닌 다른 클래스가 더 잘할 수 있는 여지가 있습니다. 즉, Student가 가장 잘 할수 있는 책임은 수강 과목을 등록하고 조회하는 일입니다. 예시처럼 클래스가 작성되었다고 한다면 예측하지 못한 변경 사항이 발생했을때 유연하고 확장성있게 시스템을 변경할 수가 없습니다. 한번 상상을 해보겠습니다. 성적표와 출석부 이외의 다른 형식으로 학생정보를 출력하는 경우. 성적 스키마가 변경되었을 경우. 이러한 사항은 모두 실질적으로 학생 클래스의 핵심기능과는 상관없지만 클래스를 수정해야하는 이유가 됩니다. 또한 책임이 많아 질수록 코드끼리의 결합성이 올라갑니다. 예를 들어 수강 과목을 조회하는 코드와 데이터베이스에서 학생 정보를 가져오는 코드 중 어딘가가 연결될 수도 있고, 수강 과목을 추가하는 코드와 데이터베이스에 학생 정보를 갱신하는 코드가 연결될 수 있습니다. 따라서 이런 여러 책임을 수행하는 Student 클래스는단 하나의 책임만 수행하도록 변경해야합니다. 다음과 같이 Student 클래스는 학생 고유의 역할을 수행하고 나머지 변경이 잦은 책임들은 따로 클래스로 분리하여 데이터베이스의 스키마가 변경되더라도 Student 클래스에는 영향을 끼치지 않도록 해야합니다. 개방 폐쇄 원칙개방 폐쇄 원칙(Open Closed Principle)은 기능의 추가에는 열려 있으면서 수정에는 닫혀있어야한다는 뜻입니다. 즉, 기존의 코드 변경을 최소화하면서 새로운 기능을 추가하고 수정한다는 의미입니다. 그림처럼 성적표와 출석부를 출력하는 클래스가 설계되어있다고 가정해봅시다. 만약 여기서 Client를 이용해 도서대출 현황을 출력하고 싶다면 어떻게 설계하시겠습니까? 따로 도서대출 클래스를 만들어 Client와 연결하면 될것이라 생각됩니다. 하지만 이는 Client의 코드를 수정할 가능성이 있어 OCP 원칙을 위반합니다. 즉, 애초에 Client 클래스는 수정을 하지 않고 기능을 추가할 수 있게 설계해야했습니다. 과연 어떻게 설계를 해야했을까요? 기존 설계를 위의 그림처럼 진행했다면 조금 더 변화에 유연하게 대처 가능했을 것입니다. Client는 어떤 새로운 출력물이 추가되어도 변경되지 않습니다. 리스코프 치환 원칙리스코프 치환 원칙(Liskov Substitution Principle)을 만족하면 부모 클래스의 인스턴스 대신에 자식 클래스의 인스턴스로 대체해도 프로그램이 정상적으로 동작해야함을 의미합니다. 위와 같은 예시는 LSP가 성립된다고 볼수 있습니다. 원숭이 인스턴스는 포유류와 원숭이 둘다 성립됨으로 리스코프 치환 원칙(Liskov Substitution Principle)이 성립됩니다. 이번에는 코드로 한번 확인해보겠습니다. public class Bag { private int price; public void setPrice(int price) { this.price = price; }; public void getPrice() { return price; }; } public class DiscountedBag extends Bag { private double discountRate; public void setDiscount(double discountRate) { this.discountRate = discountRate; }; public void applyDiscount(int price) { super.setPrice(price - (int)(discountRate * price)) }; } 위의 코드는 모두 같은 값을 출력합니다. 또, b3과 b4 인스턴스를 자식 객체의 인스턴스로 바꾸어도 정상 작동이 됩니다. 이는 상속관계가 LSP를 위반하지 않았음을 의미합니다. 하지만 위의 코드에서 DiscountedBag 클래스에서 Bag 클래스의 메서드를 재정의하는 순간 LSP를 만족하지 않습니다. 즉, LSP를 만족시키는 간단한 방법은 재정의를 하지 않는것 입니다. 의존 역전 원칙의존 역전 원칙(Dependency Inversion Principle)은 객체 사이에 도움을 주고 받으며 발생하는 의존 관계에 있어 일종의 가이드 라인을 제시합니다. DIP는 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변하는 것보다 변화가 없는 것에 의존하라는 원칙입니다. 변하기 어려운 것??? 즉, 추상 클래스 또는 인터페이스에 의존하라는 의미입니다. 변하기 쉬운 것에 의존한다면 해당 클래스가 변화할때마다 그 클래스에 의존하는 다른 클래스 또한 수정해야하는 일이 일어납니다. 이에따라 변하기 쉬운 클래스를 추상화하는 인터페이스에 의존하는것이 DIP가 성립하는 설계입니다. 인터페이스 분리 원칙인터페이스 분리 원칙(Interface Segregation Principle)은 클라이언트 입장에서 자신이 이용하지 않는 기능에는 영향을 받지 않아야한다는 의미입니다. 그림과 같은 설계는 프린터만 요구하는 클라이언트가 복합기의 팩스 기능의 변경으로 인해 발생하는 문제에 영향을 받을 수 있습니다. 즉, ISP를 다르게 설명하면 말 그대로 인터페이스를 클라이언트에 특화되도록 분리시키는 설계입니다. 그림처럼 코드를 작성하면 클라이언트 객체들마다 관심을 갖는 메서드만 있는 인터페이스만을 제공받습니다. 이렇게 설계하면 클라이언트 입장에서는 쓰지 않는 메서드에 생긴 변화로 인한 영향을 받지 않습니다 마치며SOLID의 개념과 관련해 추가적인 질문이나 오류, 오타가 있을시 댓글로 남겨주세요. 출처JAVA 객체지향 디자인패턴","categories":[{"name":"design pattern","slug":"design-pattern","permalink":"http://DongyeolLee.github.io/categories/design-pattern/"},{"name":"java","slug":"design-pattern/java","permalink":"http://DongyeolLee.github.io/categories/design-pattern/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://DongyeolLee.github.io/tags/java/"},{"name":"design pattern","slug":"design-pattern","permalink":"http://DongyeolLee.github.io/tags/design-pattern/"}]},{"title":"백준[10830] - 행렬 제곱","slug":"Al/10830","date":"2018-07-21T00:54:05.000Z","updated":"2019-04-30T07:24:41.144Z","comments":true,"path":"2018/07/21/Al/10830/","link":"","permalink":"http://DongyeolLee.github.io/2018/07/21/Al/10830/","excerpt":"","text":"문제백준 10830 문제 보기 접근 방법분할 정복으로 풀긴했지만 뭔가 삽질을 좀 많이한 문제다. 원인은 입력값을 제대로 신경쓰지 않았기때문이다.1000으로 행렬이 들어올 경우 제곱되는 B의 값이 1이라면 출력은 0으로 나와야하지만 1000으로 그대로 출력해 삽질 좀 했다.풀이 과정은 지수 법칙을 이용했다. B가 너무 크므로 행렬의 곱을 B번 진행한다면 당연히 시간초과가 난다. 따라서 A^8 == (A^4)^2 == ((A^2)^2)^2 이와 같은 속성을 이용해 문제를 해결할 수 있었다. 코드#include &ltiostream&gt #include &ltvector&gt using namespace std; int N; long long B; int arr[6][6]; vector&ltvector&ltint>> mul(long long sq) { vector&ltvector&ltint>> ans(N, vector&ltint>(N)); vector&ltvector&ltint>> c(N, vector&ltint>(N)); // 제곱수가 1 if(sq == 1) { for(int i = 0; i < N; i ++) { for(int j = 0; j < N; j ++) { c[i][j] = arr[i][j] % 1000; } } return c; // 제곱수가 짝수 } else if(sq%2 == 0) { // 현재 제곱수의 2로 나눈 숫자를 c에 저장 c = mul(sq/2); // 행렬 c*c 진행 for(int i = 0; i < N; i ++) { for(int j = 0; j < N; j ++) { for (int k = 0; k < N; k ++) { ans[i][j] += c[i][k] * c[k][j]; } ans[i][j] %= 1000; } } return ans; // 제곱수가 홀수 } else { c = mul(sq-1); // 행령 c*arr 진행 for (int i = 0; i < N; i ++) { for (int j = 0; j < N; j ++) { for (int k = 0; k < N; k ++) { ans[i][j] += c[i][k] * arr[k][j]; } ans[i][j] %= 1000; } } return ans; } } int main() { cin >> N >> B; vector&ltvector&ltint>> ans(N, vector&ltint>(N)); for(int i = 0; i < N; i ++) { for (int j = 0; j < N; j ++) { cin >> arr[i][j]; } } ans = mul(B); for(int i = 0; i < N; i ++) { for (int j = 0; j < N; j ++) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[2470] - 두 용액","slug":"Al/2470","date":"2018-07-20T12:22:17.000Z","updated":"2019-04-30T07:24:41.155Z","comments":true,"path":"2018/07/20/Al/2470/","link":"","permalink":"http://DongyeolLee.github.io/2018/07/20/Al/2470/","excerpt":"","text":"문제백준 2470 문제 보기 접근 방법처음에는 문제를 풀기위한 접근 방법을 생각하기 쉽지않았다. 입력된 숫자중 2개를 조합해여 0에 가장 가깝게 출력해야했다. 즉, 음수 또는 양수에 상관없이 0에만 가까우면 된다.그래서 생각해낸 방법이 정렬을 할때 음수와 양수를 고려하지 않고 정렬을 한뒤, 이웃한 숫자끼리 빼서 가장 작은 절대값을 출력하면 되지않을까 생각했다. 코드#include &ltiostream&gt #include &ltalgorithm&gt #include &ltvector&gt using namespace std; int N; vector arr; int temp, minA = 987654321, minB = 987654321; long long ans = 3000000000; bool compare(long long a, long long b) { return abs(a) < abs(b); } int main() { cin >> N; for (int i = 0; i < N; i++) { cin >> temp; arr.push_back(temp); } // 절대값을 기준으로 오름차순 정렬 sort(arr.begin(), arr.end(), compare); for (int i = 0; i < N - 1; i++) { // 이웃한 숫자가 최소라면 if (abs(arr[i] + arr[i + 1]) < ans) { ans = abs(arr[i] + arr[i + 1]); minA = arr[i]; minB = arr[i + 1]; } } if (minA < minB) cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1629] - 곱셉","slug":"Al/1629","date":"2018-07-16T10:47:53.000Z","updated":"2019-04-30T07:24:41.152Z","comments":true,"path":"2018/07/16/Al/1629/","link":"","permalink":"http://DongyeolLee.github.io/2018/07/16/Al/1629/","excerpt":"","text":"문제백준 1629 문제 보기 접근 방법모듈러의 분배 법칙을 이용하면 문제를 쉽게 풀수 있을것 같았다. 하지만 A와 B의 범위가 너무 커 O(N)으로 풀기에는 역부족이다. 따라서 지수 법칙을 같이 이용하여 O(logN)으로 문제를 해결했다. 지수가 짝수 : B/2로 분할 정복 지수가 홀수 : B-1로 분할 정복 코드#include &ltiostream&gt using namespace std; long long A, B, C; long long cal(long long A, long long B) { if(B == 0) return 1; if(B == 1) return A % C; if(B % 2 == 0) { long long temp = cal(A, B / 2); return (temp * temp) % C; } else { return (A * cal(A, B - 1) % C); } } int main() { cin >> A >> B >> C; cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1012] - 유기농 배추","slug":"Al/1012","date":"2018-07-09T02:35:41.000Z","updated":"2019-04-30T07:24:41.143Z","comments":true,"path":"2018/07/09/Al/1012/","link":"","permalink":"http://DongyeolLee.github.io/2018/07/09/Al/1012/","excerpt":"","text":"문제백준 1012 문제 보기 접근 방법dfs 방식을 활용하면 문제를 해결할 수 있다. 배추가 존재한다면 인접한 곳에 배추가 있는지 확인하는 방식으로 문제를 풀수 있다. 코드#include &ltiostream&gt #include &ltcstring> using namespace std; int T, M, N, K; int map[51][51]; int visited[51][51]; // 북, 동, 남, 서 (시계 방향) int dr[4] = {-1, 0, 1, 0}; int dc[4] = {0, 1, 0, -1}; int dfs(int r, int c) { // 좌표에서 시계방향으로 검사 for(int i = 0; i < 4; i ++) { int nextR = r + dr[i]; int nextC = c + dc[i]; // map 안에 존재하는 범위 if(nextC >= 0 && nextR >= 0 && nextC < N && nextR < M) { // 배추가 존재하고 방문하지 않았다면 if(map[nextR][nextC] && !visited[nextR][nextC]) { // 방문 체크 visited[nextR][nextC] = 1; // 다음 좌표 dfs(nextR, nextC); } } } return 0; } int main() { cin >> T; while(T--) { memset(map, 0, sizeof(map)); memset(visited, 0, sizeof(visited)); cin >> M >> N >> K; for(int i = 0; i < K; i ++) { int r, c; cin >> r >> c; map[r][c] = 1; } int ans = 0; for(int i = 0; i < M; i ++) { for(int j = 0; j < N; j ++) { if(map[i][j] && !visited[i][j]) { visited[i][j] = 1; dfs(i, j); ans ++; } } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[7562] - 나이트의 이동","slug":"Al/7562","date":"2018-07-09T02:35:33.000Z","updated":"2019-04-30T07:24:41.158Z","comments":true,"path":"2018/07/09/Al/7562/","link":"","permalink":"http://DongyeolLee.github.io/2018/07/09/Al/7562/","excerpt":"","text":"문제백준 7562 문제 보기 접근 방법주어진 점에서 도착지까지 몇 번만에 이동할 수 있는지 출력하는 문제로 bfs로 해결 가능하다. 한번에 움직일 수 있는 좌표 차이를 계산해 배열에 저장 이를 활용해 방문 여부를 체크하며 완전 탐색을 진행 도착지면 정답 출력 코드#include &ltiostream&gt #include &ltcstring> #include &ltqueue> using namespace std; int I, T; int map[301][301]; int visited[301][301]; int dr[8] = {-1, -2, -2, -1, 1, 2, 2, 1}; int dc[8] = {-2, -1, 1, 2, 2, 1, -1, -2}; struct location { // row int cr; // column int cc; // count int cnt; }; queue&ltlocation> q; int main() { cin >> T; while(T--) { int desR, desC, r, c; // map과 visted 배열 초기화 memset(map, 0, sizeof(map)); memset(visited, 0, sizeof(visited)); // 큐가 비워져 있는지 확인 while(!q.empty()){ q.pop(); } cin >> I; cin >> r >> c >> desR >> desC; location loc; loc.cr = r; loc.cc = c; loc.cnt = 0; // 방문체크 visited[r][c] = 1; q.push(loc); while(!q.empty()) { int r = q.front().cr; int c = q.front().cc; int cnt = q.front().cnt; q.pop(); // 도착 지점 확인 if(r == desR && c == desC) { cout = 0 && nextC < I && nextR < I) { // 방문하지 않았다면 if(!visited[nextR][nextC]) { visited[nextR][nextC] = 1; q.push({nextR, nextC, cnt + 1}); } } } } } return 0; }","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[2667] - 단지번호붙이기","slug":"Al/2667","date":"2018-07-09T02:34:58.000Z","updated":"2019-04-30T07:24:41.157Z","comments":true,"path":"2018/07/09/Al/2667/","link":"","permalink":"http://DongyeolLee.github.io/2018/07/09/Al/2667/","excerpt":"","text":"문제백준 2667 문제 보기 접근 방법dfs를 활용해 인접한 곳에 아파트가 있는지 확인하고 그 갯수를 세면 된다. 코드#include &ltiostream&gt #include &ltvector> #include &ltalgorithm> using namespace std; int N, cnt; int apartments[26][26]; int visited[26][26]; int dr[4] = {-1, 0, 1, 0}; int dc[4] = {0, 1, 0, -1}; vector&ltint> arr; int dfs(int r, int c) { for(int i = 0; i < 4; i ++) { int nextR = r + dr[i]; int nextC = c + dc[i]; // 아파트가 존재하고 해당 아파트에 방문하지 않음 if(nextR >= 0 && nextC >= 0 && nextC < N && nextR < N && !visited[nextR][nextC] && apartments[nextR][nextC] == 1) { // 방문 처리 visited[nextR][nextC] = 1; // 아파트 갯수 추가 cnt ++; dfs(nextR, nextC); } } return 0; } int main() { cin >> N; for(int i = 0; i < N; i ++) { for(int j = 0; j < N; j ++) { // 1자리씩 읽음 scanf(\"%1d\", &apartments[i][j]); } } int ans = 0; for(int i = 0; i < N; i ++) { for(int j = 0; j < N; j ++) { if(!visited[i][j] && apartments[i][j] == 1) { visited[i][j] = 1; // 단지 추가 ans ++; // 아파트 숫자 증가 cnt ++; dfs(i, j); // 아파트 숫자 배열에 저장 arr.push_back(cnt); cnt = 0; } } } // 오름차순 정렬 sort(arr.begin(), arr.end()); cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[7569] - 토마토2","slug":"Al/7569","date":"2018-07-05T01:09:47.000Z","updated":"2019-04-30T07:24:41.159Z","comments":true,"path":"2018/07/05/Al/7569/","link":"","permalink":"http://DongyeolLee.github.io/2018/07/05/Al/7569/","excerpt":"","text":"문제백준 7569 문제 보기 접근 방법7576번 문제와 동일하지만 다른 점은 아래와 위까지 진행된다는 점이다. 이전 토마토 문제와 같이 bfs를 활용하되 토마토 배열을 3차원으로 활용하여 위, 아래면까지 검사를 진행한다. 코드#include &ltiostream&gt #include &ltqueue> #include &ltalgorithm> using namespace std; int M, N, H; int map[105][105][105]; int rr[4] = {-1 , 0, 1, 0}; int cc[4] = {0, 1, 0, -1}; struct tomato { int r; int c; int h; int cnt; }; queue&lttomato> q; int main() { cin >> M >> N >> H; for(int h = 0; h < H; h++) { for(int i = 0; i < N; i ++){ for(int j = 0; j < M; j ++) { cin >> map[i][j][h]; // 토마토가 있는 위치를 큐에 넣음 if(map[i][j][h] == 1) { q.push({i, j, h, 0}); } } } } int ans = -1; while(!q.empty()) { int r = q.front().r; int c = q.front().c; int h = q.front().h; int cnt = q.front().cnt; // 가장 큰값을 유지 ans = max(ans, cnt); q.pop(); // 북, 동, 남, 서 방향의 토마토 for(int i = 0; i < 4; i ++) { int nextR = r + rr[i]; int nextC = c + cc[i]; if(nextR >= 0 && nextC >= 0 && nextC < M && nextR < N && map[nextR][nextC][h] == 0) { map[nextR][nextC][h] = 1; q.push({nextR, nextC, h, cnt + 1}); } } int up = h + 1; int down = h - 1; // 윗 상자 토마토 if(up < H) { if(map[r][c][up] == 0) { map[r][c][up] = 1; q.push({r, c, up, cnt + 1}); } } // 아랫 상자 토마토 if(down >= 0) { if(map[r][c][down] == 0) { map[r][c][down] = 1; q.push({r, c, down, cnt + 1}); } } } // 익지않은 토마토 검사 for(int h = 0; h < H; h++) { for (int i = 0; i < N; ++i) { for (int j = 0; j < M; ++j) { if (map[i][j][h] == 0) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[2583] - 영역 구하기","slug":"Al/2583","date":"2018-06-26T08:51:14.000Z","updated":"2019-04-30T07:24:41.156Z","comments":true,"path":"2018/06/26/Al/2583/","link":"","permalink":"http://DongyeolLee.github.io/2018/06/26/Al/2583/","excerpt":"","text":"문제백준 2583 문제 보기 접근 방법map 배열에 먼저 직사각형을 의미하는 좌표를 -1로 저장한다. 이후 map 배열를 검사하면서 직사각형 영역이 아니라면 완전탐색을 실시한다. 코드#include &ltiostream&gt #include &ltvector&gt #include &ltalgorithm&gt using namespace std; struct Point { int x, y, x2, y2; }; int M, N, K, t; int map[101][101]; int rr[4] = {1, 0, -1, 0}; int cc[4] = {0, 1, 0, -1}; vector&ltPoint> arr; vector&ltint> ans; int dfs(int r, int c) { for(int i = 0; i < 4; i ++) { int nextR = r + rr[i]; int nextC = c + cc[i]; if(map[nextR][nextC] == 0 && nextR < M && nextC < N && nextC >= 0 && nextR >= 0) { t ++; map[nextR][nextC] = t; dfs(nextR, nextC); } } return 0; } int main() { cin >> M >> N >> K; // 좌표 저장 for(int i = 0; i < K; i ++) { Point p; cin >> p.x >> p.y >> p.x2 >> p.y2; arr.push_back(p); } // 저장된 좌표에 따라 지도에 -1로 표시 for(int cnt = 0; cnt < arr.size(); cnt ++) { for(int r = arr[cnt].y; r < arr[cnt].y2; r ++) { for(int c = arr[cnt].x; c < arr[cnt].x2; c ++) { map[r][c] = -1; } } } // -1 영역이외의 공간을 완전 탐색 for(int r = 0; r < M; r ++) { for(int c = 0; c < N; c ++) { if(map[r][c] == 0) { t = 1; map[r][c] = t; dfs(r, c); ans.push_back(t); } } } // 오름차순으로 정렬 sort(ans.begin(), ans.end()); cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1520] - 내리막 길","slug":"Al/1520","date":"2018-06-12T00:41:35.000Z","updated":"2019-04-30T07:24:41.151Z","comments":true,"path":"2018/06/12/Al/1520/","link":"","permalink":"http://DongyeolLee.github.io/2018/06/12/Al/1520/","excerpt":"","text":"문제백준 1520 문제 보기 접근 방법아직은 bottom-up 방식이 익숙치가 않아 거의 모든 다이나믹 문제를 top-down으로 접근하고 있다. 이번 문제도 마찬가지로 top-down 방식으로 접근했다. 동서남북으로 검사하되 범위 안에 있고 내리막일 경우 계속 진행하는 식으로 문제를 풀었다. 제대로 푼것 같았지만 제출했을때 시간초과가 났다. 이유는 길이 없는 경우를 따로 dp에 저장하지 않아 이전에 이미 검사했음에도 불구하고 계속 계산을 진행해 시간 초과가 났다. 이를 해결하기위해 dp[r][c] = 0으로 초기화를 했다. 코드#include &ltiostream&gt #include &ltcstring&gt using namespace std; int M, N; int map[505][505]; int chk[505][505]; int dp[505][505]; int rr[4] = {-1, 0, 1, 0}; int cc[4] = {0, 1, 0, -1}; int dfs(int r, int c) { // 접근했던 곳인지 체크 if(dp[r][c] != -1) { return dp[r][c] ; } // 도착지점 확인 if(r == M && N == c) { return 1; } // dp에 갈수 없는 경우를 미리 저장 dp[r][c] = 0; // 동서남북 for(int i = 0; i < 4; i ++) { int nextR = r + rr[i]; int nextC = c + cc[i]; // 범위체크 if(nextR >= 1 && nextC >= 1 && nextR &lt= M && nextC &lt= N) { // 방문하지 않았고 내리막 길 일 경우 if(!chk[nextR][nextC] && map[nextR][nextC] < map[r][c]) { // 방문 체크 chk[nextR][nextC] = 1; // dp에 새로운 값 저장 dp[r][c] += dfs(nextR, nextC); chk[nextR][nextC] = 0; } } } return dp[r][c]; } int main() { cin >> M >> N; memset(dp, -1, sizeof(dp)); for(int i = 1; i &lt= M; i ++) { for(int j = 1; j &lt= N; j++) { cin >> map[i][j]; } } chk[1][1] = 1; dfs(1, 1); cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[10942] - 팰린드롬?","slug":"Al/10942","date":"2018-06-05T12:11:36.000Z","updated":"2019-04-30T07:24:41.145Z","comments":true,"path":"2018/06/05/Al/10942/","link":"","permalink":"http://DongyeolLee.github.io/2018/06/05/Al/10942/","excerpt":"","text":"문제백준 10942 문제 보기 접근 방법질문의 갯수가 최대 1000000이고 배열을 부분적으로 검사까지 진행해야하니 이는 다이나믹으로 해결해야한다. 일단 팰린드롬은 숫자가 범위 구간내에 대칭이 이루어져야 하므로 이 점을 고려해 점화식을 세워야한다. bottom-up 방식으로 먼저 길이가 1일 경우는 모두 팰린드롬이므로 dp[i][i] = 1을 저장한다. 길이가 2일 경우는 두개의 값이 일치할 경우 dp[i][j] = 1을 저장한다. 길이가 3이상일 경우는 i에서 부터 j까지라면 i+1, j-1은 팰린드롬이고 arr[i] == arr[j]를 만족할 경우 dp[i][j] = 1을 저장하는 식을 해결했다. 코드#include &ltiostream&gt using namespace std; int N, M; int dp[2001][2001]; int arr[2001]; int main() { cin >> N; for(int i = 1; i &lt= N; i ++) scanf(\"%d\", &arr[i]); // 길이가 1 for(int i = 1; i &lt= N; i ++) dp[i][i] = 1; // 길이가 2 for(int i = 1; i &lt= N-1; i ++) { if(arr[i] == arr[i+1]) dp[i][i+1] = 1; } // 길이가 3이상 for(int k = 3; k &lt= N; k ++) { for(int i = 1; i &lt= N-k+1; i ++) { int j = i+k-1; if(arr[i] == arr[j] && dp[i+1][j-1] == 1) dp[i][j] = 1; } } cin >> M; for(int i = 0; i < M; i ++) { int from, to; scanf(\"%d %d\", &from, &to); printf(\"%d\\n\", dp[from][to] ); } return 0; }","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1890] - 점프","slug":"Al/1890","date":"2018-06-05T12:10:56.000Z","updated":"2019-04-30T07:24:41.154Z","comments":true,"path":"2018/06/05/Al/1890/","link":"","permalink":"http://DongyeolLee.github.io/2018/06/05/Al/1890/","excerpt":"","text":"문제백준 1890 문제 보기 접근 방법그냥 완전탐색으로 문제를 풀 경우 시간 초과가 났다. 따라서 중간 중간 메모이제이션을 활용해 값을 저장했다. 코드#include &ltiostream&gt #include &ltalgorithm> #include &ltcstring> using namespace std; int N; int map[100][100]; long long int dp[100][100]; long long int dfs(int r, int c) { // 범위 밖 if(r < 0 || c < 0 || r >= N || c >= N) return 0; // 이전 방문 여부 if(dp[r][c] > 0) { return dp[r][c]; } // 도착지 if(r == N - 1 && c == N - 1) { dp[r][c] = 1; return dp[r][c]; } // 길 x if(map[r][c] == 0) { return 0; } // 두 가지의 경우를 더해서 저장 long long int num = dfs(r + map[r][c], c) + dfs(r, c + map[r][c]); // 메모이제이션 dp[r][c] = num; return dp[r][c]; } int main() { cin >> N; for(int i = 0; i < N; i ++) { for(int j = 0; j < N; j ++) { cin >> map[i][j]; } } memset(dp, 0, sizeof(dp)); cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[11048] - 이동하기","slug":"Al/11048","date":"2018-05-31T02:27:29.000Z","updated":"2019-04-30T07:24:41.145Z","comments":true,"path":"2018/05/31/Al/11048/","link":"","permalink":"http://DongyeolLee.github.io/2018/05/31/Al/11048/","excerpt":"","text":"문제백준 11048 문제 보기 접근 방법다아나믹프로그램을 활용해서 문제를 해결할 수 있다. 먼저 조건을 보면 이동하는 경우는 총 3가지로 오른쪽, 아래, 대각선 방향으로 이동이 가능하다.가장 위쪽 행과 가장 왼쪽 열은 이전 사탕의 갯수를 그대로 더하고 나머지 가운데 부분은 접근 가능한 방향에서의 최대값을 가지는 식으로 코드를 작성했다. 가장 위쪽dp[i][j] = map[i][j] + dp[i][j-1]; 가장 왼쪽dp[i][j] = map[i][j] + dp[i-1][j]; 나머지 영역dp[i][j] = map[i][j] + max(dp[i-1][j], max(dp[i][j-1], dp[i-1][j-1])); 코드#include &ltiostream&gt #include &ltalgorithm&gt using namespace std; int N, M; int map[1000][1000]; int dp[1000][1000]; int main() { cin >> N >> M; for(int i = 0; i < N; i++) { for(int j = 0; j < M; j ++) { cin >> map[i][j]; } } dp[0][0] = map[0][0]; for(int i = 0; i < N; i++) { for(int j = 0; j < M; j ++) { // 가장 위쪽 if(i == 0 && j - 1 >= 0) { dp[i][j] = map[i][j] + dp[i][j-1]; } // 가장 왼쪽 if(j == 0 && i - 1 >= 0) { dp[i][j] = map[i][j] + dp[i-1][j]; } // 나머지 영역 if(i != 0 && j != 0) { dp[i][j] = map[i][j] + max(dp[i-1][j], max(dp[i][j-1], dp[i-1][j-1])); } } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[7785] - 회사에 있는 사람","slug":"Al/7785","date":"2018-05-29T06:23:21.000Z","updated":"2019-04-30T07:24:41.159Z","comments":true,"path":"2018/05/29/Al/7785/","link":"","permalink":"http://DongyeolLee.github.io/2018/05/29/Al/7785/","excerpt":"","text":"문제백준 7785 문제 보기 접근 방법set 자료구조를 사용해서 “enter”가 입력되면 set에 저장하고 “leave”가 입력되면 set에서 제거하는 식으로 구현한다. 코드#include &ltiostream&gt #include &ltvector> #include &ltalgorithm> #include &ltset> using namespace std; int n; vector&ltstring> arr; set&ltstring> st; int main() { cin >> n; for(int i = 0; i < n; i ++) { string s, v; cin >> s >> v; if(v == \"enter\") { // 저장 st.insert(s); } else { // 제거 st.erase(s); } } for (auto it = st.begin(); it != st.end(); ++it) { arr.push_back(*it); } // 역순으로 정렬 reverse(arr.begin(), arr.end()); for(int i = 0; i < arr.size(); i ++) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1764] - 듣보잡","slug":"Al/1764","date":"2018-05-29T06:23:16.000Z","updated":"2019-04-30T07:24:41.153Z","comments":true,"path":"2018/05/29/Al/1764/","link":"","permalink":"http://DongyeolLee.github.io/2018/05/29/Al/1764/","excerpt":"","text":"문제백준 1764 문제 보기 접근 방법set 자료구조를 활용하면 쉽게 해결할 수 있다. 먼저, 들어보지 못한 사람을 모두 set 자료구조에 저장한뒤 이후 입력되는 보지도 못한 사람을 set에서 찾아서 정답을 출력하면 된다. 코드#include &ltiostream&gt #include &ltalgorithm&gt #include &ltvector&gt #include &ltset&gt using namespace std; int n, m; set&ltstring> hear; vector&ltstring> ans; int main() { cin >> n >> m; for(int i = 0; i < n; i ++) { string h; cin >> h; // 들어보지 못한 사람을 모두 set에 저장 hear.insert(h); } for(int i = 0; i < m; i ++) { string s; cin >> s; // 보지도 못한 사람을 set에서 찾음 auto it = hear.find(s); // 찾았다면 정답 배열에 저장 if(it != hear.end()) { ans.push_back(*it); } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[9935] - 문자열 폭발","slug":"Al/9935","date":"2018-05-29T06:23:00.000Z","updated":"2019-04-30T07:24:41.160Z","comments":true,"path":"2018/05/29/Al/9935/","link":"","permalink":"http://DongyeolLee.github.io/2018/05/29/Al/9935/","excerpt":"","text":"문제백준 9935 문제 보기 접근 방법처음 vector의 erase를 활용해 문제를 풀었지만 시간 초과가 났다 erase에 같은 경우는 제거 요소 뒤에 있는 값을 땡기기 위해 다시 어느 정도의 시간을 소비하기 때문이다. 이에 다른 방법으로 정답 배열을 하나 두고 정답 배열에 값이 하나씩 저장 될때 마다 문자열을 검사하는 식으로 문제를 접근하면 해결됨을 찾아냈다. 코드#include &ltiostream&gt #include &ltstring> using namespace std; int m, n; char ans[1000001]; string s, ex; bool isMatching(int s) { // 넘겨받은 인덱스부터 폭발 문자열 길이만큼 검사 for (int i = s ; i < s + m ; ++i) { // 하나라도 다르면 false 리턴 if (ans[i] != ex[i - s]) { return false; } } return true; } int main() { cin >> s >> ex; n = s.length(); m = ex.length(); int pos = 0; // 문자열 검사 길이 for (int i = 0 ; i < n ; ++i) { // 정답 배열에 문자 하나 저장 ans[pos] = s[i]; // 포지션 증가 pos++; // 문자가 폭발하는지 검사 if (pos - m >= 0 && isMatching(pos - m)) { // 폭발했다면 다시 포지션 감소 pos -= m; } } ans[pos] = '\\0'; if(!pos) printf(\"FRULA\"); cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[2606] - 바이러스","slug":"Al/2606","date":"2018-05-29T06:21:28.000Z","updated":"2019-04-30T07:24:41.156Z","comments":true,"path":"2018/05/29/Al/2606/","link":"","permalink":"http://DongyeolLee.github.io/2018/05/29/Al/2606/","excerpt":"","text":"문제백준 2606 문제 보기 접근 방법연결 요소에 대해서 완전탐색으로 문제를 풀수 있다. 연결 돼 있는 요소라면 dfs 탐색을 활용해 방문하고 한번 방문한 곳은 다시 방문하지 않게 chk에 체크를 한다. 코드#include &ltiostream&gt #include &ltvector&gt using namespace std; int computer, con; vector&ltvector&ltint>> v(101); int chk[101]; int dfs(int idx) { // 방문 체크 chk[idx] = 1; // 연결되어 있는 모든 요소 방문 for(int i = 0; i < v[idx].size(); i ++) { // 방문하지 않은 곳 if(chk[v[idx][i]] != 1) { dfs(v[idx][i]); } } return 0; } int main() { cin >> computer >> con; for(int i = 0; i < con; i ++) { int num, num2; cin >> num >> num2; // 이차원 배열로 그래프 표시 v[num].push_back(num2); v[num2].push_back(num); } chk[1] = 1; for(int i = 0; i < v[1].size(); i ++) { if(chk[v[1][i]] != 1) { dfs(v[1][i]); } } int ans = 0; for(int i = 0; i < 101; i ++) { if(chk[i] == 1) ans ++; } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1182] - 부분집합의 합","slug":"Al/1182","date":"2018-05-24T02:00:15.000Z","updated":"2019-04-30T07:24:41.147Z","comments":true,"path":"2018/05/24/Al/1182/","link":"","permalink":"http://DongyeolLee.github.io/2018/05/24/Al/1182/","excerpt":"","text":"문제백준 1182 문제 보기 접근 방법정수의 범위가 20까지 이므로 완전 탐색을하면 손쉽게 해결할 수 있다. 부분집합으로 해당 정수를 포함하는 경우 포함하지 않는 경우 두 가지 경우를 완전 탐색으로 구현한다. 코드#include &ltiostream&gt #include &ltvector&gt using namespace std; int N, S, ans = 0; vector&ltint&gt arr; // cnt: 배열의 인덱스, sum: 합, length: 부분집합의 길이 int dfs(int cnt, int sum, int length) { // 입력된 정수를 모두 활용 if(cnt == N) { // 부분집합의 합이 입력과 같고 공집합이 아닐 경우 if(sum == S && length != 0) { ans ++; } return 0; } // 정수를 부분집합으로 선택 dfs(cnt + 1, sum + arr[cnt], length + 1); // 정수를 부분집합으로 선택하지 않음 dfs(cnt + 1, sum, length); return 0; } int main() { cin >> N >> S; for(int i = 0; i < N; i ++) { int temp; cin >> temp; arr.push_back(temp); } dfs(0, 0, 0); cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"빅 엔디안(big endian)과 리틀 엔디안(little endian)","slug":"Network/Big-Endian-and-Little-Endian","date":"2018-05-22T00:52:17.000Z","updated":"2019-04-30T07:24:41.163Z","comments":true,"path":"2018/05/22/Network/Big-Endian-and-Little-Endian/","link":"","permalink":"http://DongyeolLee.github.io/2018/05/22/Network/Big-Endian-and-Little-Endian/","excerpt":"","text":"들어가기네트워크 관련 과목을 수강하거나 관련 문서를 읽다보면 종종 빅 엔디언(big endian)과 리틀 엔디언(little endian) 같은 단어를 쉽게 볼수 있습니다.평소 따로 정리해두지 않으면 충분히 헷갈릴수 있는 개념이므로 이번 포스팅을 통해 한번 정리해보겠습니다. 본론빅 엔디안과 리틀 엔디안CPU에 따라서 바이트의 숫자를 메모리 공간에 저장하는 방식에 있어 차이가 있을 수 있습니다. 이해하기 쉽게 32비트 CPU란 가정하에 간략한 예를 들어보겠습니다. 00000000 00000000 00000000 00000001 CPU에서는 4바이트의 숫자 1을 이진수 형태로 예시처럼 저장하는가 하면, 다음과 같이 거꾸로 저장하는 CPU도 존재합니다. 00000001 00000000 00000000 00000000 위에서 확인할 수 있는 차이때문에 데이터를 주고 받는 통신에 있어 데이터의 표현을 어떻게 하느냐는 상당히 중요합니다. CPU가 데이터를 메모리에 저장하는 방식은 위에서 확인한 대로 두가지로 나뉩니다. 상위 바이트의 값을 작은 번지수에 저장하는 방식의 빅 엔디안(big endian) 상위 바이트의 값을 큰 번지수에 저장하는 방식의 리틀 엔디안(little endian) 자! 그럼 다시한번 예를 들어보겠습니다. 이번에는 4바이트 int형 정수 0x12345678이 있다고 생각해보겠습니다. 먼저 빅 엔디안(big endian)부터 확인해보겠습니다. 빅 엔디안(big endian)은 데이터의 상위 바이트가 번지수가 작은곳에 저장되므로 위의 예시처럼 저장됩니다. 하지만 리틀 엔디안(little endian)은 이와 반대 입니다. 예시에서와 같이 리틀 엔디안(little endian)은 데이터의 상위 바이트가 주소값이 큰 곳에 저장이 됩니다. 참고로 우리가 주로 사용하는 인텔 계열은 리틀 엔디안(little endian)방식으로 데이터를 저장하고 있습니다. 이와 같은 CPU가 빅 엔디안(big endian)방식의 CPU와 데이터를 주고 받을때는 서로 데이터를 저장하는 방식에서의 차이가 있어 문제가 발생할 수 있습니다.따라서 CPU간의 호환 문제를 해결하기 위해 통일된 네트워크 바이트 순서를 정의 했고 이는 빅 엔디안(big endian) 방식입니다. 즉, 네트워크상으로 데이터를 전송할 때는 데이터의 배열을 빅 엔디안(big endian)으로 변경해서 송신해야 합니다. 수신하는 입장에서도 네트워크에서 전달되는 데이터가 빅 엔디안(big endian)방식임을 인지하고 있어야 올바른 데이터 처리가 가능합니다. 마치며간단한 개념이였지만 네트워크에 있어 기초가 되는 개념을 정리해보았습니다. 틀린 부분이 있으면 편하게 말씀해 주세요. 수정하겠습니다.","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"network","slug":"computer-science/network","permalink":"http://DongyeolLee.github.io/categories/computer-science/network/"}],"tags":[{"name":"network","slug":"network","permalink":"http://DongyeolLee.github.io/tags/network/"},{"name":"big endian","slug":"big-endian","permalink":"http://DongyeolLee.github.io/tags/big-endian/"},{"name":"little endian","slug":"little-endian","permalink":"http://DongyeolLee.github.io/tags/little-endian/"}]},{"title":"백준[1963] - 소수 경로","slug":"Al/1963","date":"2018-05-16T08:09:39.000Z","updated":"2019-04-30T07:24:41.154Z","comments":true,"path":"2018/05/16/Al/1963/","link":"","permalink":"http://DongyeolLee.github.io/2018/05/16/Al/1963/","excerpt":"","text":"문제백준 1963 문제 보기 접근 방법에라토스테네스의 채를 이용해서 1000에서 10000까지의 모든 소수를 구해 놓고 문제를 접근했다. 그 이후 입력된 숫자를 각 자리별로 배열에 담아 bfs로 자릿수를 바꿔 소수인지 아닌지를 판별했다. 코드#include &ltiostream&gt #include &ltcstring&gt #include &ltstring&gt #include &ltqueue&gt using namespace std; int T, st, fin; int primeNum[10001]; int v[10001]; int chk[10001]; int num[4]; queue&ltpair&ltint, int>> q; int prime() { for(int i = 2; i &lt= 10000; i++){ if(primeNum[i] == false){ if(i > 1000) v[i] = 1; for(int j = i + i; j &lt=10000; j += i){ primeNum[j]=true; } } } return 0; } int main() { cin >> T; memset(v, 0, sizeof(v)); memset(primeNum, 0, sizeof(primeNum)); prime(); while(T--) { memset(chk, 0, sizeof(chk)); bool flag = false; while(!q.empty()) { q.pop(); } cin >> st >> fin; chk[st] = 1; q.push({st, 0}); while(!q.empty()) { int n = q.front().first; int time = q.front().second; q.pop(); if (n == fin) { flag = true; cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[10971] - 외판원 순회 2","slug":"Al/10971","date":"2018-05-15T01:38:19.000Z","updated":"2019-04-30T07:24:41.145Z","comments":true,"path":"2018/05/15/Al/10971/","link":"","permalink":"http://DongyeolLee.github.io/2018/05/15/Al/10971/","excerpt":"","text":"문제백준 10971 문제 보기 접근 방법각 점마다 모든 점을 순회하고 다시 출발했던 점으로 돌아오는 것으로 종료 시점을 잡으면 dfs로 문제를 풀 수 있다. 코드#include &ltiostream&gt #include &ltcstring&gt using namespace std; int N; int arr[15][15]; int visited[15]; int minVal = 0; int first; int dfs(int node, int sum, int cnt) { if (!visited[node]) { visited[node] = 1; cnt++; for (int i = 0; i < N; i ++) { if (arr[node][i] != 0) dfs(i, sum+arr[node][i], cnt); } visited[node] = 0; } if (cnt == N && first == node) { minVal = (minVal == 0) ? sum : min(sum, minVal); } } int main() { cin >> N; memset(visited, 0, sizeof(visited)); for (int i = 0; i < N; i++) { for (int j = 0; j < N; j++) { cin >> arr[i][j]; } } for (int i = 0; i < N; i++) { first = i; dfs(i, 0, 0); memset(visited, 0, sizeof(visited)); } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1697] - 숨바꼭질","slug":"Al/1697","date":"2018-05-15T00:02:20.000Z","updated":"2019-04-30T07:24:41.152Z","comments":true,"path":"2018/05/15/Al/1697/","link":"","permalink":"http://DongyeolLee.github.io/2018/05/15/Al/1697/","excerpt":"","text":"문제백준 1697 문제 보기 접근 방법숨박꼭질 문제는 좌표 값이 10만까지 있어 이를 dfs를 활용해 문제를 풀 경우 시간초과가 날수 있다. 따라서 최소값을 구하는데 편리한 bfs를 활용하면 문제를 쉽게 풀 수 있다. -1을 한 경우. +1을 한 경우. *2를 한 경우. 다음과 같이 모든 경우를 나누어 큐에 넣어주면 된다. 코드#include &ltiostream&gt #include &ltqueue&gt #include &ltcstring&gt #include &ltutility&gt using namespace std; int N, K; int dp[100001]; queue&ltpair&ltint, int>> q; bool visited[100001]; int main() { cin >> N >> K; memset(dp, 0, sizeof(dp)); memset(visited, 0, sizeof(visited)); q.push(make_pair(N, 0)); while (!q.empty()) { int cur = q.front().first; int cnt = q.front().second; q.pop(); if (cur < 0 || cur > 100000) continue; if (visited[cur]) continue; visited[cur] = true; if (cur == K){ cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1107] - 리모컨","slug":"Al/1107","date":"2018-05-15T00:01:34.000Z","updated":"2019-04-30T07:24:41.146Z","comments":true,"path":"2018/05/15/Al/1107/","link":"","permalink":"http://DongyeolLee.github.io/2018/05/15/Al/1107/","excerpt":"","text":"문제백준 1107 문제 보기 접근 방법완전 탐색 방법을 활용해 문제를 풀었다. 모든 키의 조합을 활용해 최소한의 버튼 클릭을 구하는 방법이다. +, -로 이동하는 경우. 숫자 키로만 이동하는 경우. 위 두가지를 조합하여 이동하는 경우. 다음과 같은 조합을 적절히 활용해 정답을 구할 수 있다. 일단 +와 -로만 이동이 가능 한 경우는 단순한 계산으로 처리가 가능하다. 입력된 목표 채널 - 100의 절대값은 + 또는 -를 활용해 접근하는 최소값이다.나머지의 경우는 모든 자리에 0 ~ 9까지의 숫자를 대입해 정답을 구할수 있다. 주의해야할 점은 목표 채널의 자릿수와 완전 탐색으로 접근하는 자릿수가 일치하지 않아도 정답이 나올수 있다는 점이다. 예를 들어 목표 채널이 999이고 리모컨의 숫자가 1과 0만 사용 가능할때 999의 3자리가 아닌 1000의 4자리수로 이동해야 한다. 코드#include &ltiostream&gt #include &ltvector&gt #include &ltcmath&gt #include &ltcstring&gt using namespace std; int N, M, size = 0; int ans = 987654321; int num[10]; vector&ltint&gt remote; int dfs() { // 입력 받은 자릿수보다 하나 작은 경우를 계산 if(size - 1 > 0 && remote.size() == size - 1) { string n = \"\"; // 선택된 키 조합을 문자열로 저장 for(int i = 0; i < remote.size(); i ++) { n += remote[i] + '0'; } // 문자열을 다시 임시 숫자로 저장 int numTemp = stoi(n); // 가야될 채널과 임시 숫자 사이의 차를 저장 int diff = abs(N - numTemp); // 채널과 임시 숫자의 차이 + 입력된 숫자의 길이를 비교 ans = min(ans, size - 1 + diff); } // 입력 받은 자릿수와 같은 경우를 계산 if(remote.size() == size) { string n = \"\"; for(int i = 0; i < remote.size(); i ++) { n += remote[i] + '0'; } int numTemp = stoi(n); int diff = abs(N - numTemp); ans = min(ans, size + diff); } // 입력 받은 자릿수보다 하나 큰 경우를 계산 if(remote.size() == size + 1) { string n = \"\"; for(int i = 0; i < remote.size(); i ++) { n += remote[i] + '0'; } int numTemp = stoi(n); int diff = abs(N - numTemp); ans = min(ans, size + 1 + diff); return 0; } for(int i = 0; i < 10; i ++) { // 숫자가 막혀있지 않다면 if(num[i] != 1) { remote.push_back(i); dfs(); remote.pop_back(); } } return 0; } int main() { scanf(\"%d\", &N); scanf(\"%d\", &M); memset(num, 0, sizeof(num)); int t = N; // 입력된 채널의 자릿수 확인 while(1) { t /= 10; size ++; if(t < 1) { break; } } for(int i = 0; i < M; i ++) { int temp; cin >> temp; num[temp] = 1; } if(N == 100) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1722] - 순열의 순서","slug":"Al/1722","date":"2018-05-09T09:22:39.000Z","updated":"2019-04-30T07:24:41.153Z","comments":true,"path":"2018/05/09/Al/1722/","link":"","permalink":"http://DongyeolLee.github.io/2018/05/09/Al/1722/","excerpt":"","text":"문제백준 1722 문제 보기 접근 방법순열의 길이가 큰 관계로 최대 20!의 값을 가진다. 즉, 모든 경우를 해보면서 답을 출력하기는 적절하지 않다. 따라서 약간의 수학적 접근으로 문제를 해결한다.순열의 길이가 10이라고 가정을 한다면 {1, 2, 3, …}, {1, 3, 2, …}, {1, 4, 2, …} 이런식으로 올 수 있는 경우의 수가 9!이다. 따라서 9!보다 구하려는 숫자가 작다면 맨앞의 숫자는 {1, …} 이런식으로 나타날 것이다. 이를 활용해 미리 20!까지의 수를 구해놓고 문제를 해결할 수 있다. 코드#include &ltiostream&gt #include &ltalgorithm&gt #include &ltcstring&gt #include &ltvector&gt using namespace std; int N, in; long long cnt; long long ans = 0; long long factorial[21]; int use[21]; vector&ltint&gt v(N); int main() { cin >> N; cin >> in; memset(use, 0 , sizeof(use)); factorial[0] = 1; // 팩토리얼 미리 구해 놓기 for(int i = 1; i < 21; i ++) { factorial[i] = factorial[i - 1] * i; } switch (in) { case 1: cin >> cnt; for(int i = 0; i < N; i ++) { for(int f = 1; f &lt= N; f ++) { // 사용했다면 패스 if(use[f] == 1) continue; // 구하려는 cnt보다 팩토리얼이 작을 경우 if(factorial[N - i - 1] < cnt) { cnt -= factorial[N - i - 1]; } else { v.push_back(f); // 숫자 사용 여부 체크 use[f] = 1; break; } } } for(int i = 0; i < N; i ++) { cout t; v.push_back(t); } for (int ii = 0; ii < N; ii++) { for (int j = 1; j < v[ii]; j++) { if (use[j] == 0) { ans += factorial[N - ii - 1]; } } use[v[ii]] = 1; } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[10974] - 모든 순열","slug":"Al/10974","date":"2018-05-09T09:22:33.000Z","updated":"2019-04-30T07:24:41.145Z","comments":true,"path":"2018/05/09/Al/10974/","link":"","permalink":"http://DongyeolLee.github.io/2018/05/09/Al/10974/","excerpt":"","text":"문제백준 10974 문제 보기 접근 방법n이 작은 관계로 next_permutation을 이용해서 모든 순열을 구할 수 있다. 코드#include &ltiostream&gt #include &ltalgorithm&gt #include &ltvector&gt using namespace std; int n; vector&ltint&gt a(n); int main() { cin >> n; for (int i = 1; i &lt= n; i ++) { a[i - 1] = i; } do { for (int i = 0; i < n; i ++) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[10972] - 다음 순열","slug":"Al/10972","date":"2018-05-09T09:22:29.000Z","updated":"2019-04-30T07:24:41.145Z","comments":true,"path":"2018/05/09/Al/10972/","link":"","permalink":"http://DongyeolLee.github.io/2018/05/09/Al/10972/","excerpt":"","text":"문제백준 10972 문제 보기 접근 방법주어진 순열에서 바로 다음 순열을 구하는 문제이다. stl 안에 있는 next_permutation 함수를 사용하면 쉽게 해결할 수 있다. stl을 사용하지 않는다면 입력 받은 순열에서 자리 별로 대소관계를 비교해서 문제를 해결할 수 있다. 코드#include &ltiostream&gt #include &ltalgorithm&gt #include &ltvector&gt using namespace std; int n; vector&ltint&gt a(n); int main() { cin >> n; for (int i = 0; i < n; i ++) { cin >> a[i]; } if (next_permutation(a.begin(),a.end())) { for (int i = 0; i < n; i ++) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[15686] - 치킨 배달","slug":"Al/15686","date":"2018-04-16T13:01:49.000Z","updated":"2019-04-30T07:24:41.152Z","comments":true,"path":"2018/04/16/Al/15686/","link":"","permalink":"http://DongyeolLee.github.io/2018/04/16/Al/15686/","excerpt":"","text":"문제백준 15686 문제 보기 접근 방법모든 치킨 집과 주문하는 사람의 위치를 따로 저장한뒤 모든 치킨 집 조합에 대해서 주문 시키는 집의 거리 차를 최소로 하는 값을 출력하면 된다. 코드#include &ltiostream&gt #include &ltvector&gt #include &ltutility&gt #include &ltcstring&gt #include &ltcmath&gt using namespace std; int N, M, ans; // 주문하는 사람 vector&ltpair&ltint, int>> applicant; // 치킨 집 위치 vector&ltpair&ltint, int>> place; int chk[50]; int map[51][51]; int dfs(int idx, int cnt) { // 범위 체크 if(idx > place.size()) { return 0; } // 선택된 치킨 집의 갯수가 주어진 조건과 같을 때 if(cnt == M) { int temp = 0; // 주문하는 집에서 가장 가까운 치킨집 위치를 찾아 dist에 저장 for(int i = 0; i < applicant.size(); i ++) { int dist = 987654321; for(int j = 0; -1 != chk[j]; j ++) { int appR = applicant[i].first; int appC = applicant[i].second; int plR = place[chk[j]].first; int plC = place[chk[j]].second; dist = min(dist, abs(appR - plR) + abs(appC - plC)); } temp += dist; } ans = min(ans, temp); return 0; } // idx번째 치킨 집에서 치킨 주문 O chk[cnt] = idx; dfs(idx + 1, cnt + 1); chk[cnt] = -1; // idx번째 치킨 집에서 치킨을 주문 X dfs(idx + 1, cnt); return 0; } int main() { cin >> N >> M; memset(chk, -1, sizeof(chk)); for(int i = 0; i < N; i ++) { for(int j = 0; j < N; j ++) { cin >> map[i][j]; if(map[i][j] == 1) { applicant.push_back(make_pair(i, j)); } else if(map[i][j] == 2) { place.push_back(make_pair(i, j)); } } } ans = 987654321; dfs(0 , 0); cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[14889] - 스타트와 링크","slug":"Al/14889","date":"2018-04-13T12:30:26.000Z","updated":"2019-04-30T07:24:41.151Z","comments":true,"path":"2018/04/13/Al/14889/","link":"","permalink":"http://DongyeolLee.github.io/2018/04/13/Al/14889/","excerpt":"","text":"문제백준 14889 문제 보기 접근 방법학생들을 각각 a와 b팀으로 나눈다고 가정하고 벡터를 활용해 문제를 푼다. 모든 학생들의 a 또는 b팀으로 배정이 완료되면 a와 b팀의 인원이 같은 경우만 서로의 능력치를 합해 최소값을 구한다. 코드#include &ltiostream&gt #include &ltalgorithm&gt #include &ltvector&gt #include &ltcmath&gt using namespace std; int N; int s[21][21]; vector&ltint> a; vector&ltint> b; int ans = 123456789; int dfs(int idx) { if(idx >= N) { if(a.size() == b.size()) { int aSum = 0; int bSum = 0; for(int i = 0; i < a.size(); i ++) { for(int j = i + 1; j < a.size(); j ++) { aSum += s[a[i]][a[j]] + s[a[j]][a[i]]; } } for(int i = 0; i < b.size(); i ++) { for(int j = i + 1; j < b.size(); j ++) { bSum += s[b[i]][b[j]] + s[b[j]][b[i]]; } } ans = min(ans, abs(aSum-bSum)); } return 0; } // a로 배정 a.push_back(idx); dfs(idx + 1); a.pop_back(); // b로 배정 b.push_back(idx); dfs(idx + 1); b.pop_back(); return 0; } int main() { cin >> N; for(int i = 0; i < N; i ++) { for(int j = 0; j < N; j ++) { cin >> s[i][j]; } } dfs(0); cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[14890] - 경사로","slug":"Al/14890","date":"2018-04-13T12:30:17.000Z","updated":"2019-04-30T07:24:41.151Z","comments":true,"path":"2018/04/13/Al/14890/","link":"","permalink":"http://DongyeolLee.github.io/2018/04/13/Al/14890/","excerpt":"","text":"문제백준 14890 문제 보기 접근 방법다소 예외처리가 많은 구현 문제였다. 문제는 오르막, 내리막 길을 설치하기 위해서는 바닥이 높이차이가 1이나고 L만큼의 바닥이 확보되어야한다는데서 문제를 접근했다. checkC, checkR 함수를 통해 특정 열 또는 행에서부터 주어진 수 만큼 같은 높이로 되어있는지, 이미 오르막 또는 내리막이 설치되어있는지 확인한다. establishC, establishR를 활용해 경사를 설치했다고 chk 배열에 표시한다. 경사로를 설치하면 내가 밟고 있는 발판의 위치 +1 또는 -1하고 다시 check를 반복한다. 코드#include &ltiostream&gt #include &ltcstring&gt using namespace std; int N, L; int chk[101][101]; int arr_copy[101][101]; bool checkR(int r, int c, int cnt) { int start = arr_copy[r][c]; if(c < 0) return false; for(int i = c; i < c+cnt; i ++) { if(start != arr_copy[r][i] || chk[r][i] == 1){ return false; } } return true; } bool checkC(int r, int c, int cnt) { int start = arr_copy[r][c]; if(r < 0) return false; for(int i = r; i < r+cnt; i ++) { if(start != arr_copy[i][c] || chk[i][c] == 1){ return false; } } return true; } void establishRow(int r, int c, int cnt) { for(int i = c; i < c+cnt; i ++) { chk[r][i] = 1; } } void establishColumn(int r, int c, int cnt) { for(int i = r; i < r+cnt; i ++) { chk[i][c] = 1; } } int main() { cin >> N >> L; for(int i = 0; i < N; i ++) { for(int j = 0; j < N; j ++) { cin >> arr_copy[i][j]; } } int cnt = 0; for(int r = 0; r < N; r ++) { if(checkR(r, 0, N)) { cnt++; } else { int startHeight = arr_copy[r][0]; for(int c = 0; c < N; c ++) { if(startHeight != arr_copy[r][c]) { if(startHeight - arr_copy[r][c] == 1) { // 내리막 길이 체크 if(checkR(r, c, L)) { establishRow(r, c, L); c += L - 1; startHeight --; } else { break; } } else if(startHeight - arr_copy[r][c] == -1) { if(checkR(r, c - L, L)) { startHeight ++; } else { break; } } else { break; } } if(startHeight == arr_copy[r][c] && c == N - 1) { cnt ++; } } } } memset(chk, 0, sizeof(chk)); for(int c = 0; c < N; c ++) { if(checkC(0, c, N)) { cnt++; } else { int startHeight = arr_copy[0][c]; for(int r = 0; r < N; r ++) { if(startHeight != arr_copy[r][c]) { if(startHeight - arr_copy[r][c] == 1) { // 내리막 길이 체크 if(checkC(r, c, L)) { establishColumn(r, c, L); r += L - 1; startHeight --; } else { break; } } else if(startHeight - arr_copy[r][c] == -1) { if(checkC(r - L, c, L)) { startHeight ++; } else { break; } } else { break; } } if(startHeight == arr_copy[r][c] && r == N - 1) { cnt ++; } } } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[14888] - 연산자 끼워넣기","slug":"Al/14888","date":"2018-04-13T06:54:48.000Z","updated":"2019-04-30T07:24:41.151Z","comments":true,"path":"2018/04/13/Al/14888/","link":"","permalink":"http://DongyeolLee.github.io/2018/04/13/Al/14888/","excerpt":"","text":"문제백준 14888 문제 보기 접근 방법피연산자에 저장된 +, -, *, / 를 하나씩 적용해 값을 저장한 뒤, 최대값과 최소값을 가려내면 정답을 출력할 수 있다. 코드#include &ltiostream&gt #include &ltalgorithm&gt using namespace std; int N; int num[13]; // + - * / int op[4]; // 가장 작은 값을 설정 int maxN = -1000000005; // 가장 큰 값을 설정 int minN = 1000000005; int dfs(int idx, int amount) { if(idx == N) { maxN = max(maxN, amount); minN = min(minN, amount); return 0; } if(op[0] > 0) { op[0] --; dfs(idx + 1, amount + num[idx]); op[0] ++; } if(op[1] > 0) { op[1] --; dfs(idx + 1, amount - num[idx]); op[1] ++; } if(op[2] > 0) { op[2] --; dfs(idx + 1, amount * num[idx]); op[2] ++; } if(op[3] > 0) { op[3] --; dfs(idx + 1, amount / num[idx]); op[3] ++; } return 0; } int main() { cin >> N; for(int i = 0; i < N; i ++) { cin >> num[i]; } for(int i = 0; i < 4; i ++) { cin >> op[i]; } dfs(1, num[0]); cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[14891] - 톱니바퀴","slug":"Al/14891","date":"2018-04-13T06:54:43.000Z","updated":"2019-04-30T07:24:41.151Z","comments":true,"path":"2018/04/13/Al/14891/","link":"","permalink":"http://DongyeolLee.github.io/2018/04/13/Al/14891/","excerpt":"","text":"문제백준 14891 문제 보기 접근 방법구현 문제다. 어떻게 톱니바퀴를 회전을 시킬지 결정하면 된다. 따라서 rotation 배열을 둬 어떤 방향으로 회전을 할지 저장한다. 그리고 톱니바퀴마다 회전 방향이 결정되면 톱니바퀴를 회전 시킨다.톱니바퀴는 따로 회전을 시키지 않고 12시를 가르키는 인덱스를 바꿔가면서 풀면 실제로 배열을 움직이지 않아돼 더 빠른 시간에 풀 수 있다. 코드#include &ltiostream&gt #include &ltqueue&gt #include &ltvector&gt #include &ltutility&gt #include &ltcstring&gt using namespace std; queue&ltpair&ltint, int>> q; vector&ltstring> wheels; int chk[4]; int rotation[4]; int K; void rotateWheel() { // 톱니바퀴는 0번째 인덱스가 12시 방향을 가리키고 시계방향으로 저장 for(int i = 0; i < 4; i ++) { // 시계 방향 회전 if(rotation[i] == 1) { char temp = wheels[i][7]; wheels[i].pop_back(); wheels[i].insert(wheels[i].begin(), temp); } // 반시계 방향 회전 else if(rotation[i] == -1) { char temp = wheels[i][0]; wheels[i].erase(wheels[i].begin()); wheels[i].insert(wheels[i].end(), temp); } } } int main() { for(int i = 0; i < 4; i ++) { string a; cin >> a; wheels.push_back(a); } cin >> K; int w, dir; while(K --) { memset(chk, 0, sizeof(chk)); memset(rotation, 0, sizeof(rotation)); cin >> w >> dir; w --; chk[w] = 1; rotation[w] = dir; q.push(make_pair(w, dir)); while(!q.empty()) { int wh = q.front().first; int whDir = q.front().second; q.pop(); if(wh >= 0 && wh < 4) { if(wh != 0 && chk[wh-1] == 0 && wheels[wh-1][2] - '0'!= wheels[wh][6] - '0') { chk[wh-1] = 1; rotation[wh-1] = -whDir; q.push(make_pair(wh-1, -whDir)); } if(wh != 3 && chk[wh+1] == 0 && wheels[wh][2] - '0' != wheels[wh+1][6] - '0') { chk[wh+1] = 1; rotation[wh+1] = -whDir; q.push(make_pair(wh+1, -whDir)); } } } // 톱니바퀴 회전 rotateWheel(); } int ans = 0; for(int i = 0; i < 4; i ++) { int cnt = wheels[i][0] - '0'; if(cnt == 1) { if(i == 0) { ans += 1; } else if(i == 1) { ans += 2; } else if(i == 2) { ans += 4; } else { ans += 8; } } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[14502] - 연구소","slug":"Al/14502","date":"2018-04-12T09:14:13.000Z","updated":"2019-04-30T07:24:41.149Z","comments":true,"path":"2018/04/12/Al/14502/","link":"","permalink":"http://DongyeolLee.github.io/2018/04/12/Al/14502/","excerpt":"","text":"문제백준 14502 문제 보기 접근 방법먼저 벽을 dfs을 활용해 세운 뒤, bfs로 바이러스를 전파시켜 안전 구역을 확인한다. bfs를 한 뒤 이전 맵 상태를 되돌려와야 한다는 것을 주의한다. 코드#include &ltiostream&gt #include &ltqueue&gt #include &ltvector&gt #include &ltutility&gt #include &ltalgorithm&gt using namespace std; int N, M, ans = 0; int temp[9][9]; int map[9][9]; int dr[4] = {0, 0, -1, 1}; int dc[4] = {1, -1, 0, 0}; vector&ltpair&ltint, int>> v; queue&ltpair&ltint, int>> q; int map_copy() { for(int i = 0; i < N; i ++) { for(int j = 0; j< M; j ++) { temp[i][j] = map[i][j]; } } return 0; } int map_recover() { for(int i = 0; i < N; i ++) { for(int j = 0; j< M; j ++) { map[i][j] = temp[i][j]; } } return 0; } int virus_count() { int cnt = 0; for(int i = 0; i < N; i ++) { for(int j = 0; j< M; j ++) { if(map[i][j] == 0){ cnt ++; } } } ans = max(ans, cnt); return 0; } int dfs(int cnt) { if(cnt == 3) { map_copy(); for(int a = 0; a < v.size(); a ++) { q.push(v[a]); } while(!q.empty()) { int r = q.front().first; int c = q.front().second; q.pop(); for(int x = 0; x < 4; x ++) { int nextR = r + dr[x]; int nextC = c + dc[x]; if(map[nextR][nextC] == 0 && nextR >= 0 && nextR < N && nextC >= 0 && nextC < M) { map[nextR][nextC] = 2; q.push(make_pair(nextR, nextC)); } } } virus_count(); map_recover(); return 0; } for(int i = 0; i < N; i ++) { for(int j = 0; j< M; j ++) { if(map[i][j] == 0) { map[i][j] = 1; dfs(cnt + 1); map[i][j] = 0; } } } return 0; } int main() { cin >> N >> M; for(int i = 0; i < N; i ++) { for(int j = 0; j< M; j ++) { cin >> map[i][j]; if(map[i][j] == 2) { v.push_back(make_pair(i, j)); } } } for(int i = 0; i < N; i ++) { for(int j = 0; j< M; j ++) { if(map[i][j] == 0) { map[i][j] = 1; dfs(1); map[i][j] = 0; } } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[14503] - 로봇 청소기","slug":"Al/14503","date":"2018-04-12T09:14:10.000Z","updated":"2019-04-30T07:24:41.150Z","comments":true,"path":"2018/04/12/Al/14503/","link":"","permalink":"http://DongyeolLee.github.io/2018/04/12/Al/14503/","excerpt":"","text":"문제백준 14503 문제 보기 접근 방법구현 문제인 것 같다. 현재 방향과 4방향의 방 검사 후 위치를 이동할 때 주의하여 풀면 문제를 풀수 있다. 4방향을 검사하여 빈 방이 있는지 확인. 빈 방이 존재한다면 방향을 바꾸고 방 청소. 빈방이 없다면 후진 실행. 코드#include &ltiostream&gt #include &ltcstring&gt using namespace std; int dr[4] = { -1, 0, 1, 0 }; int dc[4] = { 0, 1, 0, -1 }; int map[51][51]; int r, c, dir, nextR, nextC; int N, M; int clean, cnt; int change_dir(int now) { if (now == 0) { return 3; } else if (now == 1) { return 0; } else if (now == 2) { return 1; } else { return 2; } } int main() { cin >> N >> M; cin >> r >> c >> dir; memset(map, 0, sizeof(map)); for (int i = 0; i < N; i++){ for (int j = 0; j < M; j++) { cin >> map[i][j]; } } cnt++; map[r][c] = 2; while (1) { int tdir = dir; for (int i = 0; i < 4; i++) { clean = 0; tdir = change_dir(tdir); nextR = r + dr[tdir]; nextC = c + dc[tdir]; if (nextC >= 0 && nextC < M && nextR >= 0 && nextR < N && map[nextR][nextC] == 0) { cnt += 1; dir = tdir; r = nextR; c = nextC; map[r][c] = 2; clean = 1; break; } } if (clean == 0) { if (dir == 0) { r++; } else if (dir == 1) { c--; } else if (dir == 2) { r--; } else if (dir == 3) { c++; } if (map[r][c] == 1) { break; } } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[14501] - 퇴사","slug":"Al/14501","date":"2018-04-11T05:59:09.000Z","updated":"2019-04-30T07:24:41.149Z","comments":true,"path":"2018/04/11/Al/14501/","link":"","permalink":"http://DongyeolLee.github.io/2018/04/11/Al/14501/","excerpt":"","text":"문제백준 14501 문제 보기 접근 방법진료 스케줄이 주어졌을때 선택할 수 있는 경우는 두 가지가 있다. 진료를 하던가 아니면 해당 날짜에 진료를 하지않던가 이렇게 두가지 경우에 대해서 완전 탐색을하면 정답을 출력할 수 있다. 코드#include &ltiostream&gt #include &ltalgorithm&gt using namespace std; int N, ans = 0; int day[16]; int price[16]; void dfs(int date, int cost) { if(date > N) { return; } if(date == N) { ans = max(ans, cost); return; } dfs(date + 1, cost); dfs(date + day[date], cost+price[date]); } int main() { cin >> N; for(int i = 0; i < N; i ++) { cin >> day[i]; cin >> price[i]; } // 진료 X dfs(1, 0); // 진료 O dfs(day[0], price[0]); cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[14500] - 테트로미노","slug":"Al/14500","date":"2018-04-11T05:59:06.000Z","updated":"2019-04-30T07:24:41.149Z","comments":true,"path":"2018/04/11/Al/14500/","link":"","permalink":"http://DongyeolLee.github.io/2018/04/11/Al/14500/","excerpt":"","text":"문제백준 14500 문제 보기 접근 방법각 좌표에서 모든 방향에 대해 dfs 탐색을 진행하면 테트리스의 모양 대로 접근할 수 있다. 하지만 ㅗ 모양은 dfs로는 접근할 수 없는 모양이므로 따로 예외처리를 해주어야 한다. 코드#include &ltiostream&gt #include &ltalgorithm&gt using namespace std; int dr[4] = {1, 0, -1, 0}; int dc[4] = {0, 1, 0, -1}; int map[501][501]; int chk[501][501]; int N, M, ans = 0; void check() { // ㅗ for(int i = 1; i < N; i ++) { for(int j = 1; j < M - 1; j ++) { int temp = map[i][j] + map[i - 1][j] + map[i][j - 1] + map[i][j + 1]; ans = max(ans, temp); } } // ㅜ for(int i = 0; i < N - 1; i ++) { for(int j = 1; j < M - 1; j ++) { int temp = map[i][j] + map[i + 1][j] + map[i][j - 1] + map[i][j + 1]; ans = max(ans, temp); } } // ㅓ for(int i = 1; i < N - 1; i ++) { for(int j = 1; j < M; j ++) { int temp = map[i][j] + map[i + 1][j] + map[i - 1][j] + map[i][j - 1]; ans = max(ans, temp); } } // ㅏ for(int i = 1; i < N - 1; i ++) { for(int j = 0; j < M - 1; j ++) { int temp = map[i][j] + map[i + 1][j] + map[i - 1][j] + map[i][j + 1]; ans = max(ans, temp); } } } void dfs(int r, int c, int cnt, int sum) { if(cnt == 4) { ans = max(ans, sum); return; } for(int i = 0; i < 4; i ++) { int nextR = r + dr[i]; int nextC = c + dc[i]; if (nextR < N && nextR >= 0 && nextC < M && nextC >= 0 && chk[nextR][nextC] != 1) { chk[nextR][nextC] = 1; dfs(nextR, nextC, cnt + 1, sum + map[nextR][nextC]); chk[nextR][nextC] = 0; } } } int main() { cin >> N >> M; for(int i = 0; i < N; i ++) { for(int j = 0; j < M; j ++) { cin >> map[i][j]; } } for(int i = 0; i < N; i ++) { for(int j = 0; j < M; j ++) { chk[i][j] = 1; dfs(i, j, 1, map[i][j]); chk[i][j] = 0; } } check(); cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[2805] - 나무 자르기","slug":"Al/2805","date":"2018-04-11T05:58:46.000Z","updated":"2019-04-30T07:24:41.157Z","comments":true,"path":"2018/04/11/Al/2805/","link":"","permalink":"http://DongyeolLee.github.io/2018/04/11/Al/2805/","excerpt":"","text":"문제백준 2805 문제 보기 접근 방법절단기의 높이를 조절하면서 내가 필요한 나무 길이보다 더 얻을 경우 절단기 높이를 줄이고 나무의 길이가 짧을 경우 절단기의 높이를 높이는 방식으로 진행한다. 코드#include &ltiostream&gt using namespace std; int M, N; int trees[1000001]; int main() { cin >> N >> M; long long start = 0; long long end = 0; for(int i = 0; i < N; i ++) { cin >> trees[i]; if(end < trees[i]) end = trees[i]; } long long ans = 0; long long mid; while(start &lt= end) { long temp = 0; mid = (start + end)/2; for(int i = 0; i < N; i ++) { // 음수일때 조심 if(trees[i] - mid >= 0) temp += trees[i] - mid; } if(temp >= M) { start = mid + 1; if(mid > ans) { ans = mid; } } else { end = mid - 1; } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1654] - 랜선 자르기","slug":"Al/1654","date":"2018-04-11T05:58:08.000Z","updated":"2019-04-30T07:24:41.152Z","comments":true,"path":"2018/04/11/Al/1654/","link":"","permalink":"http://DongyeolLee.github.io/2018/04/11/Al/1654/","excerpt":"","text":"문제백준 1654 문제 보기 접근 방법랜선의 길이를 계속 바꿔가면서 필요한 랜선의 갯수와 비교해 줄이거나 늘리거나 한다. 현재 길이가 x일때 얻을수 있는 랜선이 y이고 이게 내가 필요한 랜선의 갯수보다 작다면 x의 길이를 줄이고 크거나 같다면 x의 길이를 늘리는 방식이다. 코드#include &ltiostream&gt using namespace std; int K, N; int lan[10000]; int main() { cin >> K >> N; long long start = 1; long long end = 0; for(int i = 0; i < K; i ++) { cin >> lan[i]; if(end < lan[i]) end = lan[i]; } long long ans = 0; long long mid; while(start &lt= end) { int temp = 0; mid = (start + end)/2; for(int i = 0; i < K; i ++) { temp += lan[i] / mid; } if(temp >= N) { start = mid + 1; if(mid > ans) { ans = mid; } } else { end = mid - 1; } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[13458] - 시험 감독","slug":"Al/13458","date":"2018-04-10T06:48:31.000Z","updated":"2019-04-30T07:24:41.148Z","comments":true,"path":"2018/04/10/Al/13458/","link":"","permalink":"http://DongyeolLee.github.io/2018/04/10/Al/13458/","excerpt":"","text":"문제백준 13458 문제 보기 접근 방법비교적 간단한 문제이다. 일단 모든 방에 총감독이 있어야 한다. 따라서 모든 방에 총감독이 배치되고 총감독이 관리할 수 있는 인원을 뺀 상태에서 시작한다. 관리해야할 인원이 더 있다면 그 때부터 부감독관을 넣는다.여기서 주의해야하는 점은 정답 출력을 int로 하다보면 오버플로우가 나 제대로된 정답을 출력할수가 없다. 코드#include &ltiostream&gt using namespace std; int N; int studentNum[1000001]; int captain; int vice; int main() { cin >> N; for(int i = 1; i &lt= N; i ++) { cin >> studentNum[i]; } cin >> captain >> vice; long long ans = N; for(int i = 1; i &lt= N; i ++) { studentNum[i] = studentNum[i] - captain; int students = studentNum[i]; int temp; if(students > 0) { if(students % vice == 0) { temp = students / vice; } else { temp = (students / vice) + 1; } ans += temp; } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[14499] - 주사위 굴리기","slug":"Al/14499","date":"2018-04-10T06:48:23.000Z","updated":"2019-04-30T07:24:41.149Z","comments":true,"path":"2018/04/10/Al/14499/","link":"","permalink":"http://DongyeolLee.github.io/2018/04/10/Al/14499/","excerpt":"","text":"문제백준 14499 문제 보기 접근 방법문제가 처음에는 이해가 되지않아 문제를 이해하는데 시간을 좀 들였다. 이 문제는 동, 서, 남, 북으로 움직일때 전개도의 변화를 확인하면 문제를 풀수 있다. 바닥과 맞닿는 부분을 0, 하늘을 보고 있는 부분은 2, 이런 식으로 임의로 인덱스 부여하고 변화에 따른 전개도를 배열로 표현하면 문제를 풀수있다. 코드#include &ltiostream&gt using namespace std; int N, M, x, y, K; int map[21][21]; int order[1001]; int dice[6]; void right() { int temp[6]; for(int i = 0; i < 6; i ++){ temp[i] = dice[i]; } dice[0] = temp[5]; dice[1] = temp[1]; dice[2] = temp[4]; dice[3] = temp[3]; dice[4] = temp[0]; dice[5] = temp[2]; } void left() { int temp[6]; for(int i = 0; i < 6; i ++){ temp[i] = dice[i]; } dice[0] = temp[4]; dice[1] = temp[1]; dice[2] = temp[5]; dice[3] = temp[3]; dice[4] = temp[2]; dice[5] = temp[0]; } void up() { int temp[6]; for(int i = 0; i < 6; i ++){ temp[i] = dice[i]; } dice[0] = temp[1]; dice[1] = temp[2]; dice[2] = temp[3]; dice[3] = temp[0]; dice[4] = temp[4]; dice[5] = temp[5]; } void down() { int temp[6]; for(int i = 0; i < 6; i ++){ temp[i] = dice[i]; } dice[0] = temp[3]; dice[1] = temp[0]; dice[2] = temp[1]; dice[3] = temp[2]; dice[4] = temp[4]; dice[5] = temp[5]; } int main() { cin >> N >> M >> x >> y >> K; for(int i = 0; i < N; i ++) { for(int j = 0; j < M; j ++) { cin >> map[i][j]; } } for(int i = 0; i < K; i ++) { cin >> order[i]; } for(int i = 0; i < K; i ++) { int dir = order[i]; if(dir == 1) { if(y+1 == M) { continue; } y ++; right(); cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1780] - 종이의 개수","slug":"Al/1780","date":"2018-04-09T05:50:36.000Z","updated":"2019-04-30T07:24:41.154Z","comments":true,"path":"2018/04/09/Al/1780/","link":"","permalink":"http://DongyeolLee.github.io/2018/04/09/Al/1780/","excerpt":"","text":"문제백준 1780 문제 보기 접근 방법분할 정복으로 풀리는 문제이다. 처음 받은 정사각형을 검사한 뒤 다른 숫자가 있으면 9분할하여 다시 검사를 진행한다. -1은 배열에 잡히지 않으므로 모든 값은 +를 해줘 0, 1, 2 형태로 검사한다. 코드#include &ltiostream&gt #include &ltcstring&gt using namespace std; int N; int map[2200][2200]; int ans[3]; bool check(int r, int c, int num) { int test = map[r][c]; for(int i = r; i < r + num; i ++) { for(int j = c; j < c + num; j ++) { if(test != map[i][j]) return false; } } return true; } int divide(int r, int c, int num) { if(check(r, c, num)) { ans[map[r][c]] += 1; } else { int newsize = num / 3; for (int i = 0; i < 3; i++) { for (int j = 0; j < 3; j++) { divide(r + newsize*i, c + newsize*j, newsize); } } } return 0; } int main() { cin >> N; memset(ans, 0, sizeof(ans)); for(int i = 0; i < N; i ++) { for(int j = 0; j < N; j ++) { int num; cin >> num; num ++; map[i][j] = num; } } divide(0, 0, N); cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[13460] - 구슬 탈출 2","slug":"Al/13460","date":"2018-04-09T02:07:10.000Z","updated":"2019-04-30T07:24:41.148Z","comments":true,"path":"2018/04/09/Al/13460/","link":"","permalink":"http://DongyeolLee.github.io/2018/04/09/Al/13460/","excerpt":"","text":"문제백준 13460 문제 보기 접근 방법코드를 줄이는 습관을 들여야겠다. 문제는 모든 방향에 대해서 10번을 수행한뒤 안되면 -1을 출력하면 된다. 노드 구조체를 만들어 빨간색, 파란색 구슬을 관리한다. 각 방향 별로 구슬을 벽까지 이동시키고 빨간 구슬과 파란 구슬의 위치를 봐서 상관 관계를 구현한다. 파란 구슬과 빨간 구슬이 동시에 들어갔을 경우를 예외처리한다. 노드 객체 안에 cnt를 증가시키고 변경된 위치를 큐에 집어 넣는다. cnt가 10보다 크거나 작으면 -1을 출력한다. 코드#include &ltiostream&gt #include &ltqueue&gt using namespace std; struct node { int redR; int redC; int blueR; int blueC; int redGoal = 0; int blueGoal = 0; int cnt = 0; }; int N, M; int map[11][11]; queue q; int main() { cin >> N >> M; char c; node n; for(int i = 0; i < N; i ++) { for(int j = 0; j < M; j ++) { cin >> c; if(c == '#') { // 벽은 -1로 저장 map[i][j] = - 1; } else if (c == '.') { // 길은 0으로 저장 map[i][j] = 0; } else if(c == 'O') { // 출구는 1로 저장 map[i][j] = 1; } else if(c == 'R') { // 빨간 구슬 위치 저장 n.redR = i; n.redC = j; } else { // 파란 구슬 위치 저장 n.blueR = i; n.blueC = j; } } } // 큐에 삽입 q.push(n); while(!q.empty()){ // cnt가 10보다 크거나 같으면 탈출 if(q.front().cnt >= 10) break; // 4방향에 대해서 큐에 삽입 for (int dir = 0; dir < 4; dir++) { // 북 if (dir == 0) { node temp = q.front(); // 새롭게 위치한 빨간 구슬과 파란 구슬의 row값 int redNR = temp.redR; int blueNR = temp.blueR; // 빨간 구슬 벽으로 이동 while (map[redNR - 1][temp.redC] != -1) { // 출구라면 이동을 중단하고 탈출 if (map[redNR - 1][temp.redC] == 1) { temp.redGoal = 1; break; } redNR--; } // 파란 구슬 벽으로 이동 while (map[blueNR - 1][temp.blueC] != -1) { if (map[blueNR - 1][temp.blueC] == 1) { temp.blueGoal = 1; break; } blueNR--; } // 빨간 구슬과 파란 구슬의 위치가 같으면 이전 위치에서 상관 관계를 봐 위치를 조정 if (temp.blueC == temp.redC && redNR == blueNR) { if (temp.redR < temp.blueR) { blueNR++; } else { redNR++; } } // 빨간 구슬만 골인 했다면 정답 출력 if (temp.blueGoal == 0 && temp.redGoal == 1) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[3190] - 뱀","slug":"Al/3190","date":"2018-04-06T03:55:28.000Z","updated":"2019-04-30T07:24:41.158Z","comments":true,"path":"2018/04/06/Al/3190/","link":"","permalink":"http://DongyeolLee.github.io/2018/04/06/Al/3190/","excerpt":"","text":"문제백준 3190 문제 보기 접근 방법시뮬레이션을 하는 문제이므로 문제에 쓰인 조건대로 진행하면 된다. 뱀의 위치 정보, 시간, 현재 방향을 저장하는 뱀 구조체와 바뀌는 방향 정보를 담는 구조체 배열을 만들어 관리한다. 뱀의 몸통 정보는 배열보다는 헤드와 테일에 지속적인 삽입으로 벡터로 선언한다. change_dir으로 현재 방향 기준 어떻게 방향을 바뀌는지 계산한다. map과 snake_history의 이차원 배열을 두어 사과 및 뱀의 몸통을 확인한다. (snake_history을 두지 않고 뱀의 구조체에 위치 정보가 있으니 확인해도 된다. 하지만 조회를 하는데 시간이 걸린다.) main에서는 문제에 따라 시물레이션을 돌려본다. 코드 및 주석 참조 코드#include &ltiostream&gt #include &ltvector&gt #include &ltutility&gt using namespace std; struct dir_info { int second; char direction; }; struct snake { int time; int cur_direction; vector&ltpair&ltint, int>> body; }; int N, K, L; int map[100][100]; int snake_history[100][100]; dir_info dirInfo[100]; int change_dir(int current, char change_to) { // 동: 1 서: 3 남: 2 북: 0 if(current == 0) { if(change_to == 'D') { current++; return current; } else { current = 3; return current; } } else if(current == 1) { if(change_to == 'D') { current++; return current; } else { current--; return current; } } else if(current == 2) { if(change_to == 'D') { current++; return current; } else { current--; return current; } } else if(current == 3) { if(change_to == 'D') { current = 0; return current; } else { current--; return current; } } } int main() { cin >> N; cin >> K; for(int i = 0; i < K; i ++) { int r, c; cin >> r >> c; map[r - 1][c - 1] = 1; } cin >> L; for(int i = 0; i < L; i ++){ int second; char dir; dir_info temp; cin >> second >> dir; temp.second = second ; temp.direction = dir; dirInfo[i] = temp; } snake s; s.time = 0; // 동: 1 서: 3 남: 2 북: 0 s.cur_direction = 1; // 위치 초기화 s.body.push_back(make_pair(0, 0)); // 방향 정보를 갖고있는 배열의 인덱스 정보 int idx = 0; while(true) { int r = s.body[0].first; int c = s.body[0].second; int time = s.time; // 방향이 바뀌어야할 시간이라면 방향 전환 후 방향 정보 배열 인덱스 증가 if(time == dirInfo[idx].second) { s.cur_direction = change_dir(s.cur_direction, dirInfo[idx].direction); idx ++; } // 동 if(s.cur_direction == 1) { int nextR = r; int nextC = c + 1; // 다음 방문할 위치가 뱀의 몸통이거나 맵 밖으로 나가면 조건문 탈출 if(snake_history[nextR][nextC] == 1 || nextR >= N || nextC >= N || nextC < 0 || nextR < 0) { break; } // 머리 추가 s.body.insert(s.body.begin(), make_pair(nextR, nextC)); // 뱀의 지도에서 추가 snake_history[nextR][nextC] = 1; // 사과가 없다면 if(!map[nextR][nextC]) { int xR = s.body.back().first; int xC = s.body.back().second; // 뱀의 지도에서 위치 삭제 snake_history[xR][xC] = 0; // 구조체에서도 위치 정보 삭제 s.body.pop_back(); } else { // 사과가 있다면 사과만 지우고 몸통은 유지 map[nextR][nextC] = 0; } } else if(s.cur_direction == 0) { int nextR = r - 1; int nextC = c; if(snake_history[nextR][nextC] == 1 || nextR >= N || nextC >= N || nextC < 0 || nextR < 0) { break; } s.body.insert(s.body.begin(), make_pair(nextR, nextC)); snake_history[nextR][nextC] = 1; if(!map[nextR][nextC]) { int xR = s.body.back().first; int xC = s.body.back().second; snake_history[xR][xC] = 0; s.body.pop_back(); } else { map[nextR][nextC] = 0; } } else if(s.cur_direction == 2) { int nextR = r + 1; int nextC = c; if(snake_history[nextR][nextC] == 1 || nextR >= N || nextC >= N || nextC < 0 || nextR < 0) { break; } s.body.insert(s.body.begin(), make_pair(nextR, nextC)); snake_history[nextR][nextC] = 1; if(!map[nextR][nextC]) { int xR = s.body.back().first; int xC = s.body.back().second; snake_history[xR][xC] = 0; s.body.pop_back(); } else { map[nextR][nextC] = 0; } } else if(s.cur_direction == 3) { int nextR = r; int nextC = c - 1; if(snake_history[nextR][nextC] == 1 || nextR >= N || nextC >= N || nextC < 0 || nextR < 0) { break; } s.body.insert(s.body.begin(), make_pair(nextR, nextC)); snake_history[nextR][nextC] = 1; if(!map[nextR][nextC]) { int xR = s.body.back().first; int xC = s.body.back().second; snake_history[xR][xC] = 0; s.body.pop_back(); }else { map[nextR][nextC] = 0; } } s.time ++; } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1074] - Z","slug":"Al/1074","date":"2018-04-04T09:21:15.000Z","updated":"2019-04-30T07:24:41.144Z","comments":true,"path":"2018/04/04/Al/1074/","link":"","permalink":"http://DongyeolLee.github.io/2018/04/04/Al/1074/","excerpt":"","text":"문제백준 1074 문제 보기 접근 방법일일이 (0,0)부터 좌표를 찍는 순으로 접근하면 시간 초과를 유발한다. 따라서 좌표가 어느 위치에 있는지 확인한 뒤 해당 분면까지 계산한다. 또 다시 분할된 좌표를 기준으로 계산한다. 코드#include &ltiostream&gt using namespace std; int power2(int k) { // 2의 제곱을 계산 return (1 > n >> x >> y; cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[2263] - 트리의 순회","slug":"Al/2263","date":"2018-04-04T07:58:06.000Z","updated":"2019-04-30T07:24:41.155Z","comments":true,"path":"2018/04/04/Al/2263/","link":"","permalink":"http://DongyeolLee.github.io/2018/04/04/Al/2263/","excerpt":"","text":"문제백준 2263 문제 보기 접근 방법분할 정복 방식으로 문제를 풀수 있다. PostOrder에서 루트 값을 찾아내고 InOrder를 사용해 왼쪽, 오른쪽 자식이 몇개씩 있는지 찾아 분할 정복한다. 코드#include &ltiostream&gt using namespace std; int N; int inO[100000]; int postO[100000]; int position[100001]; void solve(int in_start, int in_end, int post_start, int post_end) { if (in_start > in_end || post_start > post_end) return; int root = postO[post_end]; cout N; for (int i = 0; i < N; i++) { cin >> inO[i]; } for (int i = 0; i < N; i++) { cin >> postO[i]; } for (int i = 0; i < N; i++) { // inorder에서 해당 i(root)가 몇번째 위치하고 있는지 저장 position[inO[i]] = i; } solve(0, N-1, 0, N-1); return 0; }","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[10816] - 숫자 카드2","slug":"Al/10816","date":"2018-04-02T08:09:46.000Z","updated":"2019-04-30T07:24:41.144Z","comments":true,"path":"2018/04/02/Al/10816/","link":"","permalink":"http://DongyeolLee.github.io/2018/04/02/Al/10816/","excerpt":"","text":"문제백준 10816 문제 보기 접근 방법숫자를 입력 받음과 동시에 인덱스 정보로 활용해 갯수를 저장한다. 음수 같은 경우는 양수의 최대 범위 이후로 인덱스를 설정해 저장한다. 코드#include &ltiostream&gt #include &ltcstring&gt using namespace std; int N, M; int arr[20000001]; int ans[500000]; int main() { cin >> N; memset(arr, 0, sizeof(arr)); for(int i = 0; i < N; i ++) { int idx; cin >> idx; // 입력받은 수가 음수이면 양수화 하고 양수 인덱스 뒤로 설정 if(idx < 0) { idx *= -1; idx += 10000000; } arr[idx] ++; } cin >> M; for(int i = 0; i < M; i++) { int temp; cin >> temp; if(temp < 0){ temp *= -1; temp += 10000000; } ans[i] = temp; } for(int i = 0; i < M; i++) { int idx = ans[i]; cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1783] - 병든 나이트","slug":"Al/1783","date":"2018-03-27T01:44:23.000Z","updated":"2019-04-30T07:24:41.154Z","comments":true,"path":"2018/03/27/Al/1783/","link":"","permalink":"http://DongyeolLee.github.io/2018/03/27/Al/1783/","excerpt":"","text":"문제백준 1783 문제 보기 접근 방법맵의 높이가 1일 때와 2일 때를 먼저 예외처리한다. 맵의 높이가 2일 때, 이동 횟수가 4이상이 되면 모든 경우의 이동을 수행해야 하므로 이동을 3번 이내로 제한한다. 맵의 높이가 2보다 클 경우는 너비를 신경써서 예외처리한다. 4가지 경우를 다 해보면 움직일수 있는 최대 너비가 7이 된다. 이후 접근해야하는 너비는 오른쪽으로 한칸씩 이동하면서 모든 너비에 접근이 가능하다. 7보다 작을 경우 4와 비교해 계산한다. 코드#include &ltiostream&gt #include &ltalgorithm&gt using namespace std; int height, width; int main() { cin >> height >> width; if (height == 1) { cout = 7) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1744] - 수 묶기","slug":"Al/1744","date":"2018-03-24T07:44:24.000Z","updated":"2019-04-30T07:24:41.153Z","comments":true,"path":"2018/03/24/Al/1744/","link":"","permalink":"http://DongyeolLee.github.io/2018/03/24/Al/1744/","excerpt":"","text":"문제백준 1744 문제 보기 접근 방법음수와 양수를 따로 구분해 오름 차순, 내림 차순으로 정렬한 뒤, 2개씩 묶으면 정답 출력이 가능하다.하지만, 2가지 주의해야할 사항이 있는데 1은 묶는 것 보다 더하는게 더 이득. (2 * 1 &lt; 2 + 1) 음수 영역에 숫자가 하나 남고 0이 있는 경우 예외 처리 이 두 가지 경우를 따로 처리해야 한다. 코드#include &ltiostream&gt #include &ltalgorithm&gt #include &ltfunctional&gt #include &ltvector&gt using namespace std; int N, zero, one; vector&ltint> positive; vector&ltint> negative; int cal(vector&ltint> arr) { int ans = 0; auto size = (int)arr.size(); int loop = size/2; for(int i = 0, idx = 0; i < loop; i ++, idx = idx + 2){ ans += (arr[idx] * arr[idx + 1]); } if(size % 2 == 1){ if(zero > 0 && arr.back() < 0) { } else { ans += arr.back(); } } return ans; } int main() { cin >> N; int num; one = 0; zero = 0; for(int i = 0; i < N; i ++) { cin >> num; if(num == 1) { one++; } else if(num > 0) { positive.push_back(num); } else if(num < 0) { negative.push_back(num); } else { zero ++; } } sort(positive.begin(), positive.end(), greater&ltint>()); sort(negative.begin(), negative.end()); // 1을 따로 처리해줘야 추후 1, 2 가 입력됐을때 2가 아니라 3이 출력되야 함 int ans = one; int negative_max = 0, positive_max = 0; if(negative.size() > 1) { negative_max = cal(negative); } else if(negative.size() == 1) { if(zero) { negative_max = 0; } else negative_max = negative[0]; } if(positive.size() > 1) { positive_max = cal(positive); } else if(positive.size() == 1) { positive_max = positive[0]; } ans += positive_max + negative_max; cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1931] - 회의실 배정","slug":"Al/1931","date":"2018-03-23T05:21:33.000Z","updated":"2019-04-30T07:24:41.154Z","comments":true,"path":"2018/03/23/Al/1931/","link":"","permalink":"http://DongyeolLee.github.io/2018/03/23/Al/1931/","excerpt":"","text":"문제백준 1931 문제 보기 접근 방법회의실을 끝나는 시간을 기준으로 오름 차순 정렬을 한다. 끝나는 시간이 빠른 순으로 회의실을 배정하면 정답이 출력. 코드#include &ltiostream&gt #include &ltalgorithm&gt using namespace std; struct Time { int start, end; }; int N; Time arr[100000]; bool cmp(const Time &a, const Time &b) { if(a.end == b.end) { return a.start < b.start; } else { return a.end < b.end; } } int main() { cin >> N; for(int i = 0; i < N; i ++) { cin >> arr[i].start >> arr[i].end; } // 오름차순 정렬, 만약 끝나는 시간이 같으면 시작 시간이 작은 순으로 sort(arr, arr + N, cmp); int now = 0; int ans = 0; for(int i = 0; i < N; i ++) { if(now &lt= arr[i].start) { now = arr[i].end; ans += 1; } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[11725] - 트리의 부모 찾기","slug":"Al/11725","date":"2018-03-20T03:46:12.000Z","updated":"2019-04-30T07:24:41.146Z","comments":true,"path":"2018/03/20/Al/11725/","link":"","permalink":"http://DongyeolLee.github.io/2018/03/20/Al/11725/","excerpt":"","text":"문제백준 11725 문제 보기 접근 방법bfs를 통해 부모를 찾아 저장하면 정답을 출력할 수 있다. 입력시 양방향을 다 고려해야 하는 것에 주의. 코드#include &ltiostream&gt #include &ltqueue&gt using namespace std; int N; int parents[100001]; int visited[100001]; vector&ltvector&ltint>> tree(100001); queue&ltint> q; int main() { cin >> N; int i, j; // 양방향을 고려해 입력 for(int x = 0; x < N-1; x ++) { cin >> i >> j; tree[i].push_back(j); tree[j].push_back(i); } // 루트 노드는 부모가 없으므로 처리하고 큐에 저장 parents[1] = 0; q.push(1); visited[1] = 1; while(!q.empty()) { int a = q.front(); q.pop(); // 연결된 노드에 접근한 적이 없다면 접근하고 방문처리 및 부모 설정 for(int b : tree[a]){ if(!visited[b]) { visited[b] = 1; parents[b] = a; q.push(b); } } } // 출력 for(int i = 2; i &lt= N; i++) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[9466] - 텀 프로젝트","slug":"Al/9466","date":"2018-03-19T04:38:29.000Z","updated":"2019-04-30T07:24:41.159Z","comments":true,"path":"2018/03/19/Al/9466/","link":"","permalink":"http://DongyeolLee.github.io/2018/03/19/Al/9466/","excerpt":"","text":"문제백준 9466 문제 보기 접근 방법시간 초과가 나기때문에 dfs를 돌지만 한 번 방문한 노드는 다시 방문하면 안된다. 한 번 방문을 체크할 때 사이클의 여부 역시 같이 판단해야한다. 사이클이 존재하면 사이클이 시작되는 노드를 저장하고 이후 계산을 통해 정답을 구한다.1 시간 가량 계속 문제가 없는것 같았는데 ‘틀렸습니다’가 나와 삽질했지만 원인은 벡터를 다시 지워주지 않아서… 코드#include &ltiostream&gt #include &ltvector&gt #include &ltcstring&gt using namespace std; int T, n, cnt; int students[100001]; int visited[100001]; int cycle[100001]; vector&ltint> v; void dfs(int node) { int next = students[node]; if(!visited[next]) { visited[next] = 1; cycle[next] = 1; dfs(next); cycle[next] = 0; } else if(cycle[next] == 1) { v.push_back(next); cycle[next] = 0; } } void dfs2(int node) { int next = students[node]; students[node] = -1; if(students[next] != -1) dfs2(next); } int main() { cin >> T; while(T--) { cin >> n; cnt = 0; v.clear(); memset(visited, 0, sizeof(visited)); memset(students, 0, sizeof(students)); for(int i = 1; i &lt= n; i ++) { cin >> students[i]; } for(int i = 1; i &lt= n; i ++) { if(!visited[i]) { visited[i] = 1; cycle[i] = 1; dfs(i); cycle[i] = 0; } } auto size = static_cast&ltint>(v.size()); for(int i = 0; i < size; i ++) { int node = v[i]; dfs2(node); } for(int i = 1; i &lt= n; i ++) { if(students[i] != -1) cnt ++; } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[7576] - 토마토","slug":"Al/7576","date":"2018-03-16T09:14:52.000Z","updated":"2019-04-30T07:24:41.159Z","comments":true,"path":"2018/03/16/Al/7576/","link":"","permalink":"http://DongyeolLee.github.io/2018/03/16/Al/7576/","excerpt":"","text":"문제백준 7576 문제 보기 접근 방법bfs 완전 탐색을 이용해 토마토의 위치 값과 bfs의 실행 수를 저장하면 정답을 출력할 수 있다. 정답 출력 과정에서는 익지 않은 토마토가 있다면 무조건 -1을 출력하면 된다. 코드#include &ltiostream&gt #include &ltcstring&gt #include &ltqueue&gt #include &ltutility&gt using namespace std; int M, N; int tomato[1000][1000]; int visited[1000][1000]; int dr[4] = {0, 0, -1, 1}; int dc[4] = {1, -1, 0, 0}; queue&ltpair&ltint, pair&ltint, int>>> q; int main() { cin >> M >> N; memset(tomato, 0, sizeof(tomato)); memset(visited, 0, sizeof(visited)); for(int i = 0; i < N; i ++) { for(int j = 0; j < M; j ++) { cin >> tomato[i][j]; if(tomato[i][j] == 1) { visited[i][j] = 1; q.push(make_pair(i, make_pair(j, 1))); } } } while(!q.empty()) { int r = q.front().first; int c = q.front().second.first; int cnt = q.front().second.second; q.pop(); for(int i = 0; i < 4; i ++) { int nextR = r + dr[i]; int nextC = c + dc[i]; if(nextC >= 0 && nextR >= 0 && nextR < N && nextC < M) { if (tomato[nextR][nextC] != -1 && visited[nextR][nextC] == 0) { tomato[nextR][nextC] = 1; visited[nextR][nextC] = cnt + 1; q.push(make_pair(nextR, make_pair(nextC, cnt + 1))); } } } } int flag = 0; int ans = 0; for (int i = 0; i < N; ++i) { if(flag) { break; } for (int j = 0; j < M; ++j) { if (tomato[i][j] == 0) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1991] - 트리 순회","slug":"Al/1991","date":"2018-03-15T08:13:30.000Z","updated":"2019-04-30T07:24:41.155Z","comments":true,"path":"2018/03/15/Al/1991/","link":"","permalink":"http://DongyeolLee.github.io/2018/03/15/Al/1991/","excerpt":"","text":"문제백준 1991 문제 보기 접근 방법순회 시점에 따라 출력하고 재귀함수를 호출하면 정답이 출력된다. 트리의 왼쪽, 오른쪽 노드의 자료 표현을 위해 이치원 배열을 선언하고 [0]에는 왼쪽 노드를 [1]에는 오른쪽 노드를 저장했다. 코드#include &ltiostream&gt using namespace std; int N; int tree[26][2]; void preOrder(int node) { if(node == (int)('.' - 'A')) return; cout > a >> b >> c; tree[a - 'A'][0] = b - 'A'; tree[a - 'A'][1] = c - 'A'; } preOrder(0); cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[2146] - 다리 만들기","slug":"Al/2146","date":"2018-03-13T06:14:24.000Z","updated":"2019-04-30T07:24:41.155Z","comments":true,"path":"2018/03/13/Al/2146/","link":"","permalink":"http://DongyeolLee.github.io/2018/03/13/Al/2146/","excerpt":"","text":"문제백준 2146 문제 보기 접근 방법섬을 숫자로 분류해 섬의 갯수를 파악한 뒤 각 섬마다 돌면서 가장 자리를 증가시키는 형식으로 제출했다. 그리고 최소값을 저장한다. 하지만 메모리 초과!!이유는 59번째 주석 처리돼 있듯이 큐에 넣기 전에 방문을 체크해야하는데 큐에서 뺀 뒤 방문 체크가 이루어져 중복된 방문이 발생했다. 코드#include &ltiostream&gt #include &ltvector&gt #include &ltqueue&gt #include &ltutility&gt using namespace std; int N; int ans = 987654321; int dr[4] = {0, 0, 1, -1}; int dc[4] = {1, -1, 0, 0}; vector&ltvector&ltint>> map; vector&ltvector&ltint>> visited; queue&ltpair&ltint, int>> q; int copy() { for(int i = 0; i < N; i ++) { for(int j = 0; j < N; j ++) { map[i][j] = visited[i][j]; } } return 0; } int queueClear() { while(!q.empty()) { q.pop(); } return 0; }; int main() { cin >> N; map.assign(100, vector&ltint>(100, 0)); visited.assign(100, vector&ltint>(100, 0)); for(int i = 0; i < N; i ++) { for(int j = 0; j < N; j ++) { cin >> map[i][j]; } } // 구역 나누기 int cnt = 1; for(int i = 0; i < N; i ++) { for (int j = 0; j < N; j++) { if(map[i][j] == 1 && !visited[i][j]) { q.push(make_pair(i, j)); visited[i][j] = cnt; while(!q.empty()) { int r = q.front().first; int c = q.front().second; q.pop(); // visited[nextR][nextC] = cnt; // cout = 0 && nextC < N && nextR < N) { if(map[nextR][nextC] && !visited[nextR][nextC]) { visited[nextR][nextC] = cnt; q.push(make_pair(nextR, nextC)); } } } } cnt ++; } } } cnt --; int check = 1; int finish; while(cnt --) { copy(); queueClear(); for (int i = 0; i < N; i++) { for (int j = 0; j < N; j++) { if (map[i][j] == check) { q.push(make_pair(i, j)); } } } int temp_ans = 0; finish = 0; while(!q.empty()) { if(finish) { break; } long long loop = q.size(); temp_ans ++; while(loop --){ if(finish) { break; } int r = q.front().first; int c = q.front().second; q.pop(); for(int i = 0; i < 4; i ++){ int nextR = r + dr[i]; int nextC = c + dc[i]; if(nextC >= 0 && nextR >= 0 && nextC < N && nextR < N) { if(!map[nextR][nextC]) { map[nextR][nextC] = check; q.push(make_pair(nextR, nextC)); } else if(map[nextR][nextC] != check) { ans = (ans > temp_ans)? temp_ans : ans; finish = 1; break; } } } } } check ++; } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[4963] - 섬의 개수","slug":"Al/4963","date":"2018-03-10T13:54:47.000Z","updated":"2019-04-30T07:24:41.158Z","comments":true,"path":"2018/03/10/Al/4963/","link":"","permalink":"http://DongyeolLee.github.io/2018/03/10/Al/4963/","excerpt":"","text":"문제백준 4963 문제 보기 접근 방법동서남북과 대각선 방향을 맵의 유효 범위안에서 완전 탐색하면 답을 출력할 수 있다. 코드#include &ltiostream&gt #include &ltcstring&gt using namespace std; int h, w; int map[50][50]; int visited[50][50]; // 동 북 남 서 int dx[4] = {1, 0, -1, 0}; int dy[4] = {0, -1, 0, 1}; // 대각선 방향 int dx2[4] = {1, 1, -1, -1}; int dy2[4] = {1, -1, -1, 1}; int dfs(int i, int j) { visited[i][j] = 1; for(int k = 0; k < 4; k ++) { // 지도 범위 체크 if(j + dx[k] >= 0 && j + dx[k] < w && i + dy[k] >= 0 && i + dy[k] < h) { // 땅이면서 방문하지 않았는지 체크 if(map[i + dy[k]][j + dx[k]] && !visited[i + dy[k]][j + dx[k]]) dfs(i + dy[k], j + dx[k]); } } for(int k = 0; k < 4; k ++) { if(j + dx2[k] >= 0 && j + dx2[k] < w && i + dy2[k] >= 0 && i + dy2[k] < h) { if(map[i + dy2[k]][j + dx2[k]] && !visited[i + dy2[k]][j + dx2[k]]) dfs(i + dy2[k], j + dx2[k]); } } return 0; } int main() { while(1) { cin >> w >> h; if(w == 0 && h == 0) break; memset(map, 0, sizeof(map)); memset(visited, 0, sizeof(visited)); for(int i = 0; i < h; i ++) { for(int j = 0; j < w; j ++) { cin >> map[i][j]; } } int cnt = 0; for(int i = 0; i < h; i ++) { for(int j = 0; j < w; j ++) { if(map[i][j] && !visited[i][j]) { cnt ++; dfs(i, j); } } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[2331] - 반복 수열","slug":"Al/2331","date":"2018-03-09T01:56:19.000Z","updated":"2019-04-30T07:24:41.155Z","comments":true,"path":"2018/03/09/Al/2331/","link":"","permalink":"http://DongyeolLee.github.io/2018/03/09/Al/2331/","excerpt":"","text":"문제백준 2331 문제 보기 접근 방법최악의 상황으로 메모리를 잡고 연산을 계산해보니 시간 초과는 나지 않을 것 같아 배열을 최대로 잡고 풀었다. 먼저 계속 각 자리를 제곱해 더한 수를 따로 배열에 저장하고 계산 진행하다 추후에 반복된 숫자가 나오면 완전 탐색을 빠져 나간다.dfs함수 안에서 cnt를 세는 건 참고로 안해도 된다. 코드#include &ltiostream&gt #include &ltcstring&gt #include &ltcmath&gt #include &ltvector&gt using namespace std; string A; int P, E; vector visited; int D[600000]; int dfs(string num) { int temp = 0; for(int i = 0; i < num.length(); i ++) { temp += pow(num[i] - '0', P); } int cnt = 0; if(D[temp]) { E = temp; for(int i = 0; i < 600000; i ++) { if(D[i]) { cnt ++; } } return cnt; } else { D[temp] = 1; visited.push_back(temp); return dfs(to_string(temp)); } }; int main() { cin >> A >> P; memset(D, 0, sizeof(D)); int index = stoi(A); D[index] = 1; visited.push_back(index); dfs(A); int cnt = 0; for(int i = 0; i < visited.size(); i ++) { if(visited[i] == E){ cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[1707] - 이분 그래프","slug":"Al/1707","date":"2018-03-08T08:46:21.000Z","updated":"2019-04-30T07:24:41.153Z","comments":true,"path":"2018/03/08/Al/1707/","link":"","permalink":"http://DongyeolLee.github.io/2018/03/08/Al/1707/","excerpt":"","text":"문제백준 1707 문제 보기 접근 방법처음 이차 배열을 다 잡아 놓고 시작했다. 그럼 128MB 밖에 안되는 문제 요건을 충족할 수 없어 vector을 활용해 추가될때마다 공간를 만드는 형식으로 변환했다. dfs를 돌며 blue, red로 번갈아가며 색을 배정한다.dfs를 다 돌면 노드 별로 연결된 노드를 확인하며 색이 같은지만 체크하면 된다. 코드#include &ltiostream&gt #include &ltcstring&gt #include &ltvector&gt #define RED 1 #define BLUE 2 using namespace std; int testCase, node, edge; vector map[20001]; int visited[20001]; int dfs(int Enode, int color) { visited[Enode] = color; for(int i = 0; i < map[Enode].size(); i ++) { int next = map[Enode][i]; if(!visited[next]) { dfs(next, 3 - color); } } return 0; } int main() { cin >> testCase; // cout node >> edge; for(int i = 0; i < edge; i ++) { int x, y; cin >> x >> y; // map[x][y] = map[y][x] = 1; map[x].push_back(y); map[y].push_back(x); } for(int i = 1; i &lt= node; i ++) { if(!visited[i]) dfs(i, RED); } bool ok = true; for (int i = 1; i &lt= node; i++) { for (int k = 0; k < map[i].size(); k++) { int j = map[i][k]; if (visited[i] == visited[j]) { ok = false; } } } printf(\"%s\\n\", ok ? \"YES\" : \"NO\"); } return 0; }","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[11724] - 연결 요소의 개수","slug":"Al/11724","date":"2018-03-06T09:32:58.000Z","updated":"2019-04-30T07:24:41.146Z","comments":true,"path":"2018/03/06/Al/11724/","link":"","permalink":"http://DongyeolLee.github.io/2018/03/06/Al/11724/","excerpt":"","text":"문제백준 11724 문제 보기 접근 방법dfs로 접근해 거의 리니어한 타임에 문제를 풀수 있다. 그 대신 사이클이 있는 경우를 대비해 방문한 노드를 체크하고 방문했을 경우에는 다시 해당 노드로 접근하지 않는다. 코드#include &ltiostream&gt #include &ltcstring&gt using namespace std; int N, M; int map[1001][1001]; int visited[1001]; int cnt; int dfs(int node) { visited[node] = 1; for(int i = 1; i &lt= N; i++) { if(map[node][i] && !visited[i]) { dfs(i); } } return 0; } int main() { cin >> N >> M; memset(map, 0, sizeof(map)); memset(visited, 0, sizeof(visited)); int r, c; for(int i = 0; i < M; i ++) { cin >> r >> c; map[r][c] = map[c][r] = 1; } for(int i = 1; i &lt= N; i ++) { if(!visited[i]){ dfs(i); cnt++; } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"Let's Encrypt를 활용한 Glassfish Https 설정하기","slug":"Spadework/GlassfishWithHTTPS","date":"2018-03-05T04:07:25.000Z","updated":"2019-04-30T07:24:41.167Z","comments":true,"path":"2018/03/05/Spadework/GlassfishWithHTTPS/","link":"","permalink":"http://DongyeolLee.github.io/2018/03/05/Spadework/GlassfishWithHTTPS/","excerpt":"","text":"들어가기최근 봉사 활동을 하면서 관리하는 페이지의 인증서가 만료되어 수동으로 갱신을 해야했습니다. 자료를 찾아보니 아직은 많은 자료가 없는 것 같아 Let’s Encrypt를 활용한 Glassfish 인증서 수동 갱신 과정을 공유해볼까 합니다. 본론Let’s Encrypt 설치Let’s Encrypt가 설치가 안된 상태라면 먼저 Let’sEncrypt를 설치해야 합니다. 설치하는 과정은 많은 블로그에서 공유되고 있으므로 간략하게 클론하는 명령어만 적고 넘어가겠습니다. git clone https://github.com/letsencrypt/letsencrypt 정상적으로 설치가 됐다면 확인을 해보겠습니다. letsencrypt-auto --help 다음과 같이 출력된다면 정삭적으로 설치를 마친것 입니다. Let’s Encrypt를 활용해 pem 파일 받아오기이제 앞에서 설치한 Let’s Encrypt를 활용해 pem 파일을 받아오겠습니다. letsencrypt-auto certonly 명령어를 치고 나면 환경에 맞게 서버를 인증 받아야합니다. 저같은 경우는 이전에 standalone으로 인증 받았기 때문에 똑같이 standalone으로 진행하겠습니다. 문제가 없다면 정상적으로 /etc/letsencrypt 아래 pem 파일이 갱신 또는 새롭게 받아온 것을 확인할 수 있습니다. 날짜를 보시면 pkcs.p12 파일은 이전에 만들어 놨던 인증서이므로 아직까지는 신경을 쓰지 않아도 됩니다. 발급된 pem 파일, 인증서로 변환하기이제 받아온 pem 파일들을 인증서로 변환하여 Glassfish keystore에 넣어주면 인증서는 갱신 됩니다. pem 파일들을 인증서로 변환하기 위해서는 openssl을 사용해야합니다. openssl pkcs12 -export -in fullchain.pem -inkey privkey.pem -out pkcs.p12 -name s1as 비밀번호는 별도의 설정을 하지 않았을 경우 changeit 입니다. 이 과정을 수행하면 다음과 같이 pkcs라는 파일이 생성됨을 확인 할 수 있습니다. 이제 생성된 pkcs 인증서를 keysore.jks에 넣어주기만 하면 인증서 갱신이 완료 됩니다. keystore에 인증서 넣기먼저 keystore에 기존에 있었던 만료된 인증서를 지워야 합니다. 만약 만료된 인증서가 없었다면 바로 pkcs 파일을 넣어 주시면 됩니다. 그럼 먼저 리스트를 확인하고 삭제 해보겠습니다. keytool -list -keystore keystore.jks keytool -delete -alias s1as -keystore keystore.jks 기본 비밀번호는 똑같이 changeit 입니다. 위의 명령어를 진행하면 keystore에 저정되 있던 만료된 인증서는 삭제가 됩니다. 자!! 그럼 이제 마지막으로 갱신한 인증서를 넣어 주겠습니다. cd /usr/local/glassfish4/glassfish/domains/domain1/config keytool -importkeystore -deststorepass {비밀번호} -destkeypass {비밀번호} -destkeystore keystore.jks -srckeystore /etc/letcencrypt/live/freemed.iptime.org/pkcs.p12 -srcstoretype PKCS12 -alias s1as 해당 환경은 저의 환경을 기준으로 Path가 설정되어 있으므로 참고하시고 각자의 설정된 Path로 진행하시면 됩니다. 마지막으로 확인보면 갱신된 인증서가 정상적으로 keystore에 추가됨을 확인할 수 있습니다. 이제 정말 마지막으로 서버만 껏다 키면 인증서가 적용됩니다. https 통신이 정상적으로 작동되네요..!! 마치며glassfish 서버 자체를 많이 쓰지는 않지만 유용한 정보였기를 바랍니다.","categories":[{"name":"삽질기","slug":"삽질기","permalink":"http://DongyeolLee.github.io/categories/삽질기/"}],"tags":[{"name":"https","slug":"https","permalink":"http://DongyeolLee.github.io/tags/https/"},{"name":"letsencrypt","slug":"letsencrypt","permalink":"http://DongyeolLee.github.io/tags/letsencrypt/"},{"name":"glassfish","slug":"glassfish","permalink":"http://DongyeolLee.github.io/tags/glassfish/"}]},{"title":"백준[11650] - 좌표 정렬하기","slug":"Al/11650","date":"2018-03-04T11:00:41.000Z","updated":"2019-04-30T07:24:41.146Z","comments":true,"path":"2018/03/04/Al/11650/","link":"","permalink":"http://DongyeolLee.github.io/2018/03/04/Al/11650/","excerpt":"","text":"문제백준 11650 문제 보기 접근 방법pair를 사용하면 pair 컨테이너의 구현된 정렬 기준에 따라 앞에 값을 비교하고 같으면 뒷 값을 비교한다. 처음 제출했을 때는 시간 초과가 났는데 출력할때 cout &lt;&lt; endl이 시간이 오래 걸리기 때문이었다. 코드#include &ltiostream&gt #include &ltvector&gt #include &ltalgorithm&gt using namespace std; int N; pair arr[100000]; int main() { cin >> N; for(int i = 0; i < N; i ++) { cin >> arr[i].first >> arr[i].second; } sort(arr, arr + N); for(int i = 0; i < N; i ++) { // endl 시간 초과 cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[10989] - 수 정렬하기 3","slug":"Al/10989","date":"2018-03-04T11:00:27.000Z","updated":"2019-04-30T07:24:41.145Z","comments":true,"path":"2018/03/04/Al/10989/","link":"","permalink":"http://DongyeolLee.github.io/2018/03/04/Al/10989/","excerpt":"","text":"문제백준 10989 문제 보기 접근 방법문제는 간단하다. 입력된 수를 오름차순으로 정렬만 하면 된다. 하지만 입력이 10,000,000 이다. 즉, sort로 간단하게 구현하면 메모리 초과를 유발할 수 있다. 이에 따라 다른 접근 방법을 택했다. 입력을 받으며 해당 숫자가 몇개 입력 됐는지 체크한다. 코드#include &ltiostream&gt #include &ltcstring&gt using namespace std; int N; int arr[10001]; int main() { cin >> N; memset(arr, 0, sizeof(arr)); int num = 0; for(int i = 0; i < N; i ++) { cin >> num ; arr[num] += 1; } for(int i = 1; i &lt= 10000; i ++) { if(arr[i] > 0) { for(int j = 0; j < arr[i]; j ++) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[2745] - 진법 변환","slug":"Al/2745","date":"2018-03-02T07:24:11.000Z","updated":"2019-04-30T07:24:41.157Z","comments":true,"path":"2018/03/02/Al/2745/","link":"","permalink":"http://DongyeolLee.github.io/2018/03/02/Al/2745/","excerpt":"","text":"문제백준 2745 문제 보기 접근 방법입력된 B진법을 10진수로 변환해주면 된다. 코드#include &ltiostream&gt #include &ltmath.h&gt using namespace std; string s; int b, ans; long size; int main() { cin >> s >> b; size = s.size(); for(int i = 0; i < size; i ++) { if(s[i] >= '0' && s[i] &lt= '9') { ans += pow(b, size - i - 1) * (s[i] - '0'); } else { ans += pow(b, size - i - 1) * (s[i] - 'A' + 10); } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[11653] - 소인수분해","slug":"Al/11653","date":"2018-03-02T07:23:58.000Z","updated":"2019-04-30T07:24:41.146Z","comments":true,"path":"2018/03/02/Al/11653/","link":"","permalink":"http://DongyeolLee.github.io/2018/03/02/Al/11653/","excerpt":"","text":"문제백준 11653 문제 보기 접근 방법입력된 숫자를 2부터 시작하여 i*i가 입력된 수보다 작거나 같을 때까지 나눈다. 코드#include &ltiostream&gt using namespace std; int N; int main() { cin >> N; for(int i = 2; i*i &lt= N; i ++) { while(N%i == 0) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[2609] - 최대공약수와 최소공배수","slug":"Al/2609","date":"2018-03-02T07:23:43.000Z","updated":"2019-04-30T07:24:41.157Z","comments":true,"path":"2018/03/02/Al/2609/","link":"","permalink":"http://DongyeolLee.github.io/2018/03/02/Al/2609/","excerpt":"","text":"문제백준 2609 문제 보기 접근 방법유클리드 호제법을 사용하여 최대공약수를 구하고 입력된 두 수의 곱에 다시 최대공약수로 나누어 최소 공배수를 구한다. 코드#include &ltiostream&gt using namespace std; int N, M; int gcd, lcm; int getGCD(int a, int b) { return b ? getGCD(b, a%b) : a; } int main() { cin >> N >> M; gcd = getGCD(N, M); lcm = (N * M) / gcd; cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[11576] - base conversion","slug":"Al/11576","date":"2018-03-02T07:23:30.000Z","updated":"2019-04-30T07:24:41.146Z","comments":true,"path":"2018/03/02/Al/11576/","link":"","permalink":"http://DongyeolLee.github.io/2018/03/02/Al/11576/","excerpt":"","text":"문제백준 11576 문제 보기 접근 방법먼저 입력된 값을 10진법으로 변환한 뒤 다시 진법을 변환한다. 코드#include &ltiostream&gt #include &ltcmath&gt #include &ltvector&gt #include &ltalgorithm&gt using namespace std; int A, B, m; vector&ltint > v; int main() { cin >> A >> B; cin >> m; int temp; int decimal = 0; for(int i = 0; i < m; i++) { cin >> temp; decimal += temp * pow(A, m - i - 1); } while(decimal) { v.push_back(decimal % B); decimal /= B; } reverse(v.begin(), v.end()); long size = v.size(); for(int i = 0; i < size; i ++) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[11054] - 가장 긴 바이토닉 부분 수열","slug":"Al/11054","date":"2018-02-23T02:17:11.000Z","updated":"2019-04-30T07:24:41.145Z","comments":true,"path":"2018/02/23/Al/11054/","link":"","permalink":"http://DongyeolLee.github.io/2018/02/23/Al/11054/","excerpt":"","text":"문제백준 11054 문제 보기 접근 방법먼저 증가하는 부분 수열을 구하는 dp을 작성하고 뒤에서 부터 감소하는 가장 긴 부분 수열을 구하는 dp2를 구한다.따라서 dp - dp2 - 1에서 최대값을 출력한다. -1을하는 이유는 dp[2] + dp2[2]를 계산하면 2번째 인덱스가 중복 계산되기 때문이다. 코드#include &ltiostream&gt #include &ltcstring&gt using namespace std; int N; int arr[1001]; int dp[1001]; int dp2[1001]; int main() { cin >> N; memset(arr, 0, sizeof(arr)); memset(dp, 0, sizeof(dp)); memset(dp2, 0, sizeof(dp2)); for(int i = 1; i &lt= N; i++) { cin >> arr[i]; } for(int i = 1; i &lt= N; i ++) { dp[i] = 1; for(int j = 1; j < i; j ++) { if(arr[j] < arr[i] && dp[i] < dp[j] + 1) { dp[i] = dp[j] + 1; } } } for(int i = N; i >= 1; i--) { dp2[i] = 1; for(int j = i+1; j &lt= N; j++) { if(arr[i] > arr[j] && dp2[j]+1 > dp2[i]) { dp2[i] = dp2[j]+1; } } } int ans = 0; for(int i = 0; i &lt= N; i++) { if(ans < dp[i] + dp2[i]-1) { ans = dp[i] + dp2[i]-1; } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[2156] - 포도주 시식","slug":"Al/2156","date":"2018-02-21T02:40:08.000Z","updated":"2019-04-30T07:24:41.155Z","comments":true,"path":"2018/02/21/Al/2156/","link":"","permalink":"http://DongyeolLee.github.io/2018/02/21/Al/2156/","excerpt":"","text":"문제백준 2156 문제 보기 접근 방법경우를 총 3가지로 나누어 dp로 해결한다. n번째 포도주를 마시지 않을 때와 마실 때(첫번째 잔인지, 연속된 잔인지 구분).n번째 잔을 마시지 않을 경우, n-1번째 잔은 마셧는지 안마셧는지 여부에 상관없이 최대값을 저장.n번째 잔이 연속된 첫 잔일 경우, 이전 잔은 무조건 마시지 않었어야 한다.n번째 잔이 연속된 잔일 경우, 이전 잔은 연속된 첫잔이여야 한다.if(n번째 잔을 마시지 않을 때) dp[i][0] = max(dp[i - 1][0], dp[i - 1][1], dp[i - 1][2]);if(n번째 잔이 첫 시작 잔) dp[i][1] = dp[i - 1][0] + a[i];if(n번째 잔이 연속된 잔) dp[i][2] = dp[i - 1][1] + a[i]; 코드#include &ltiostream&gt #include &ltcstring&gt #include &ltalgorithm&gt using namespace std; int n; int a[10001]; int dp[10001][3]; int main() { cin >> n; memset(dp, 0, sizeof(dp)); memset(a, 0, sizeof(a)); for(int i = 1; i &lt= n; i ++) { cin >> a[i]; } dp[1][1] = a[1]; for(int i = 2; i &lt= n; i ++) { int temp = max(dp[i - 1][0], dp[i - 1][1]); dp[i][0] = max(temp, dp[i - 1][2]); dp[i][1] = dp[i - 1][0] + a[i]; dp[i][2] = dp[i - 1][1] + a[i]; } int t = max(dp[n][0], dp[n][1]); int ans = max(t, dp[n][2]); cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[10844] - 쉬운계단수","slug":"Al/10844","date":"2018-02-20T14:36:33.000Z","updated":"2019-04-30T07:24:41.145Z","comments":true,"path":"2018/02/20/Al/10844/","link":"","permalink":"http://DongyeolLee.github.io/2018/02/20/Al/10844/","excerpt":"","text":"문제백준 10844 문제 보기 접근 방법바로 앞의 수가 0과 9일때 주의해서 점화식을 세운다. 처음 제출할 때 출력할때만 나머지를 계산해서 출력되도록해서 오버플로우 발생으로 오답이 됐다.점화식은 자릿수와 바로 앞의 숫자를 인덱스로 모든 경우를 저장한다.if(앞에 저장된 숫자가 0) dp[i][j] = dp[i - 1][1];if(앞에 저장된 숫자가 9) dp[i][j] = dp[i - 1][8];나머지 모든 경우는 dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]; 코드#include &ltiostream&gt #define mod 1000000000 using namespace std; int N; long long dp[101][10]; int main() { cin >> N; dp[1][0] = 0; for(int i = 1; i &lt= 9; i ++) { dp[1][i] = 1; } for(int i = 2; i &lt= N; i ++) { for(int j = 0; j &lt= 9; j ++) { dp[i][j] = 0; if(j == 0) { dp[i][j] = dp[i - 1][1]; } else if(j == 9) { dp[i][j] = dp[i - 1][8]; } else { dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]; } // 숫자가 너무 커서 오버플로우, 미리 나눈값 저장. dp[i][j] %= mod; } } long long ans = 0; for(int i = 0; i &lt= 9; i ++) ans += dp[N][i]; cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[11726] - 2*n 타일링","slug":"Al/11726","date":"2018-02-19T02:31:14.000Z","updated":"2019-04-30T07:24:41.147Z","comments":true,"path":"2018/02/19/Al/11726/","link":"","permalink":"http://DongyeolLee.github.io/2018/02/19/Al/11726/","excerpt":"","text":"문제백준 11726 문제 보기 접근 방법bottom-up 방식의 dp를 활용해 문제 접근을 했다. 길이가 1인 타일이 추가될 때와 2인 타일이 추가될때의 경우를 계산해 식을 세웠다.점화식은 다음과 같다.dp[n] = dp[n-1] + dp[n-2] 코드#include &ltiostream&gt using namespace std; int n; int dp[1001]; int main() { cin >> n; dp[0] = 1; dp[1] = 1; for(int i = 2; i &lt= n; i ++) { dp[i] = (dp[i - 1] + dp[i - 2]) % 10007; } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[11836] - 여왕벌","slug":"Al/11836","date":"2018-02-17T16:18:01.000Z","updated":"2019-04-30T07:24:41.147Z","comments":true,"path":"2018/02/18/Al/11836/","link":"","permalink":"http://DongyeolLee.github.io/2018/02/18/Al/11836/","excerpt":"","text":"문제백준 10836 문제 보기 접근 방법초반에 문제를 잘못 이해해 엄청 틀렸다.. 첫날부터 순서대로 입력이 되는건데 내맘대로 순서대로라는 단어를 빼고 읽었다. 문제 접근 방법은 먼저 map[1][1]을 구해야 이후의 행을 구할 수 있다.행 하나하나를 계산하면서 진행하면 시간초과가 남으로 먼저 맨 왼쪽 행과 맨 위쪽 열만 받아 저장하고 나머지 영역은 맨 윗 열을 그대로 내리면 정답. 따지고 보면 map[1][1]를 계산할때 순서대로 입력이됨으로 결국 map[1][1]의 증가량은 map[0][1]과 같은 것! 코드#include &ltiostream&gt #include &ltcstring&gt using namespace std; int N, M; int map[701][701]; int leftAndTop[1500]; int main() { cin >> M >> N; memset(map, 0, sizeof(map)); for(int i = 0; i < 2*M - 1; i ++) { leftAndTop[i] = 1; } for(int i = 0; i < N; i ++) { int zero, one, two; cin >> zero >> one >> two; for(int j = zero; j < zero + one; j ++) { leftAndTop[j] += 1; } for(int j = zero + one; j < 2*M - 1; j ++) { leftAndTop[j] += 2; } } int r = M - 1; int c = 0; for(int i = 0; i < 2*M - 1; i ++) { if(r == 0) { map[r][c] = leftAndTop[i]; c++; } else { map[r][c] = leftAndTop[i]; r--; } } for(int i = 1; i < M; i ++) { int temp = map[0][i]; for(int j = 1; j < M; j ++) { map[j][i] = temp; } } for(int i = 0; i < M; i++) { for(int j = 0; j < M; j ++) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"17. 멀티레벨 큐 스케줄러로 업그레이드하고 태스크 종료 기능을 추가하자","slug":"OS/Project/AddMultilevelQueue","date":"2018-02-14T01:52:39.000Z","updated":"2019-04-30T07:24:41.164Z","comments":true,"path":"2018/02/14/OS/Project/AddMultilevelQueue/","link":"","permalink":"http://DongyeolLee.github.io/2018/02/14/OS/Project/AddMultilevelQueue/","excerpt":"","text":"들어가기태스크에 우선순위를 할당하고 이에 따라 태스크를 실행하는 빈도를 조절. 본론17.1 태스크 우선순위와 멀티레벨 큐 스케줄러 알고리즘17.1.1 멀티레벨 큐 스케줄러와 라운드 로빈 스케줄러의 관계 멀티레벨 큐 스케줄러는 우선순위에 따라 구분된 여러 개의 큐를 사용. 태스크가 대기하는 공간이 여러 개이므로, 멀티레벨 큐 스케줄러에는 두 가지 스케줄링 정책이 필요. 여러 개의 큐 중에서 특정 큐를 선택하는 정책. 선택된 큐에서 태스크를 선택하는 정책. 17.1.2 태스크 우선순위와 큐 스케줄링 정책 구현할 OS의 태스크 우선순위는 가장 높음, 높음, 중간, 낮음, 가장 낮음 순으로 구성. 가장 높은 단계의 큐는 긴급하고 주기적으로 수행해야하는 태스크를 설정, 무리하게 많은 태스크를 가장 높음으로 할당하면 시스템의 성능이 저하. 17.2 멀티레벨 큐 스케줄러 업그레이드17.2.1 스케줄러 자료구조 업그레이드// 태스크의 우선 순위 #define TASK_FLAGS_HIGHEST 0 #define TASK_FLAGS_HIGH 1 #define TASK_FLAGS_MEDIUM 2 #define TASK_FLAGS_LOW 3 #define TASK_FLAGS_LOWEST 4 // 스케줄러의 상태를 관리하는 자료구조 typedef struct kSchedulerStruct { // 현재 수행 중인 태스크 TCB* pstRunningTask; // 현재 수행 중인 태스크가 사용할 수 있는 프로세서 시간 int iProcessorTime; // 실행할 태스크가 준비중인 리스트, 태스크의 우선 순위에 따라 구분 LIST vstReadyList[ TASK_MAXREADYLISTCOUNT ]; // 종료할 태스크가 대기중인 리스트 LIST stWaitList; // 각 우선 순위별로 태스크를 실행한 횟수를 저장하는 자료구조 int viExecuteCount[ TASK_MAXREADYLISTCOUNT ]; } SCHEDULER; 이전의 작성한 스케줄러의 자료 구조를 수정. 17.2.2 스케줄러 함수 업그레이드스케줄러 초기화 함수 업그레이드 초기화 함수는 스케줄러의 초깃값을 설정, 추가된 준비 리스트와 대기 리스트, 큐별 태스크 실행 횟수를 초기화. 태스크 선택 함수 업그레이드 라운드 로빈 방식때와는 달리 우선순위에 따라 큐를 선택해야함. 높은 큐의 태스크가 모두 1회씩 수행해야 하위 큐의 태스크 1개를 수행하도록 설정. 태스크 등록 함수 업그레이드 우선 순위는 TCB 자료구조에 있는 플래그 필드의 하위 8비트를 통해 해당 우선순위 큐에 삽입하도록 수정. 17.2.3 태스크 우선순위 제어 태스크의 우선순위를 즉시 변경하려면 두 가지 경우를 고려. 실행 중인 자신의 우선순위를 변경하는 경우. 변경할 태스크가 준비 큐에 있는 경우. 17.2.4 콘솔 셸과 테스트 태스크의 우선순위 지정 콘솔 셸은 우선순위를 가장 높게 설정해 끊기지 않게 해야 함. 17.3 태스크 종료와 유휴 태스크17.3.1 태스크 종료, 태스크 상태와 대기 큐 태스크를 완전히 종료하려면 메모리를 반환한 후 다른 태스크로 전환하는 코드를 수행. 가장 낮은 순위를 갖는 유휴(idle task)와 대기 큐로 이를 해결. 대기 큐는 종료시킬 테스크를 저장하는 용도. 17.3.2 태스크 종료 함수 구현 태스크를 종료하는 작업은 자신을 종료하는 경우와 다른 태스크를 종료하는 경우로 나뉨. 다른 태스크를 종료하는 경우라면 태스크 플래그에 태스크 종료 비트 설정 후 우선 순위를 변경. 자신을 종료하려면 태스크 종료 플래그 설정이 끝난 후 자신을 대기 큐에 연결하고 다른 태스크로 전환. 코드 17.4 참조 17.4 멀티레벨 큐 스케줄러와 태스크 종료 기능의 통합과 빌드17.4.1 태스크 파일 수정Task.c 코드 보기Task.h 코드 보기AssemblyUtility.asm 코드 보기AssemblyUtility.h 코드 보기 17.4.2 C 언어 커널 엔트리 포인트 파일과 콘솔 셸 파일 추가Main.c 코드 보기ConsoleShell.c 코드 보기ConsoleShell.h 코드 보기Console.c 코드 보기 17.4.3 빌드와 실행 마치며끝..","categories":[{"name":"project","slug":"project","permalink":"http://DongyeolLee.github.io/categories/project/"},{"name":"정리","slug":"project/정리","permalink":"http://DongyeolLee.github.io/categories/project/정리/"},{"name":"os","slug":"project/정리/os","permalink":"http://DongyeolLee.github.io/categories/project/정리/os/"}],"tags":[{"name":"os","slug":"os","permalink":"http://DongyeolLee.github.io/tags/os/"}]},{"title":"백준[10835] - 카드놀이","slug":"Al/10835","date":"2018-02-13T07:10:19.000Z","updated":"2019-04-30T07:24:41.145Z","comments":true,"path":"2018/02/13/Al/10835/","link":"","permalink":"http://DongyeolLee.github.io/2018/02/13/Al/10835/","excerpt":"","text":"문제백준 10835 문제 보기 접근 방법dfs를 사용해서 경우를 잘 나누면 문제를 해결할 수 있음. 근데 N이 크다보니 메모이제이션 방법으로 중간값을 계속 저장해야 함. 시간 초과가 나지 않을까 걱정했는데 다행히 통과. 코드#include &ltiostream&gt using namespace std; int N; int box[2001][2001]; int dp[2001][2001]; int sum = 0; int dfs(int leftCard, int rightCard, int num) { if (leftCard >= N + 1 || rightCard >= N + 1) { return num; } if (dp[leftCard][rightCard] != -1) return dp[leftCard][rightCard] + num; int ret; if (rightCard < N + 1 && leftCard < N + 1) { ret = dfs(leftCard + 1, rightCard, num); ret = max(ret, dfs(leftCard + 1, rightCard + 1, num)); } if (box[0][leftCard] > box[1][rightCard] && rightCard < N + 1 && leftCard < N + 1) { ret = max(ret, dfs(leftCard, rightCard + 1, num + box[1][rightCard])); } dp[leftCard][rightCard] = ret - num; return ret; } int main () { cin >> N; for (int i = 0; i < 2; i++) { for (int j = 0; j < N; j++) { cin >> box[i][j]; } } for (int i = 0; i < N; i++) { for (int j = 0; j < N; j++) { dp[i][j] = -1; } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[10834] - 벨트","slug":"Al/10834","date":"2018-02-12T13:18:35.000Z","updated":"2019-04-30T07:24:41.144Z","comments":true,"path":"2018/02/12/Al/10834/","link":"","permalink":"http://DongyeolLee.github.io/2018/02/12/Al/10834/","excerpt":"","text":"문제백준 10834 문제 보기 접근 방법마지막 바퀴 벨트만 신경써서 접근하면 공략 가능.i 바퀴와 i+1의 관계를 비율로 접근해 i+2에 적용하는 방식. 코드#include &ltiostream&gt using namespace std; int M; int arr[1001][3]; int vec = 0; int main() { cin >> M; for (int i = 0; i < M; i ++) { for (int j = 0; j < 3; j ++) { cin >> arr[i][j]; } } for (int i = 0; i < M - 1; i ++) { // i 대비 i+1의 회전수의 비율을 저장 int ratio = arr[i][1] / arr[i + 1][0]; arr[i + 1][1] = arr[i + 1][1] * ratio; vec += arr[i][2]; } // 위의 for문이 M-1만큼 반복하므로 마지막 벨트의 방향을 저장 vec += arr[M - 1][2]; cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[10833] - 사과","slug":"Al/10833","date":"2018-02-10T07:24:35.000Z","updated":"2019-04-30T07:24:41.144Z","comments":true,"path":"2018/02/10/Al/10833/","link":"","permalink":"http://DongyeolLee.github.io/2018/02/10/Al/10833/","excerpt":"","text":"문제백준 10833 문제 보기 접근 방법간단한 수학문제와 같다. 나머지만 잘 저장하고 더하면 끝. 코드#include &ltiostream&gt using namespace std; int N; int arr[101][2]; int sum = 0; int main() { cin >> N; for (int i = 0; i < N; i++) { for(int j = 0; j < 2; j++) { cin >> arr[i][j]; } } for (int i = 0; i < N; i++) { sum += arr[i][1]%arr[i][0]; } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[13302] - 리조트","slug":"Al/13302","date":"2018-02-06T15:18:33.000Z","updated":"2019-04-30T07:24:41.148Z","comments":true,"path":"2018/02/07/Al/13302/","link":"","permalink":"http://DongyeolLee.github.io/2018/02/07/Al/13302/","excerpt":"","text":"문제백준 13302 문제 보기 접근 방법각 금액 별로 완전 탐색을 하다가 이전 방문한 경로를 저장하는 형식으로 구현했더니 정답. 코드#include &ltiostream&gt #include &ltcstring&gt #define MIN(a,b) ((a)&lt(b)? (a):(b)) #define IMPOSSIBLE (100000000) using namespace std; int N, M; int cant[101]; int memo[101][101]; int dfs(int day, int coupon, int price) { if(N < day) { return price; } if(memo[day][coupon]) { return memo[day][coupon] + price; } if(cant[day]) { return dfs(day + 1, coupon, price); } int ans = IMPOSSIBLE; ans = MIN(ans, dfs(day + 1, coupon, price + 10000)); ans = MIN(ans, dfs(day + 3, coupon + 1, price + 25000)); ans = MIN(ans, dfs(day + 5, coupon + 2, price + 37000)); if(coupon &gt= 3) { ans = MIN(ans, dfs(day + 1, coupon - 3, price)); } memo[day][coupon] = ans - price; return ans; } int main() { cin >> N >> M; memset(cant, 0, sizeof(cant)); memset(memo, 0, sizeof(memo)); int temp; if(M) for(int i = 1; i &lt= M; i ++) { cin >> temp; cant[temp] = 1; } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"16. 라운드 로빈 스케줄러를 추가하자","slug":"OS/Project/AddRoundRobinScheduler","date":"2018-02-06T08:48:28.000Z","updated":"2019-04-30T07:24:41.164Z","comments":true,"path":"2018/02/06/OS/Project/AddRoundRobinScheduler/","link":"","permalink":"http://DongyeolLee.github.io/2018/02/06/OS/Project/AddRoundRobinScheduler/","excerpt":"","text":"들어가기라운드 로빈 스케줄러를 구현하는 방법에 대해 알아보자. 본론16.1 스케줄러와 리스트16.1.1 스케줄러의 역할과 종류 스케줄러는 태스크를 특정 기준에 따라 정렬하여 실행 순서를 결정. 프로세서의 사용률을 높이고 성능을 향상시킬 수 있음. 일정한 시간마다 돌아가면서 공평하게 실행하는 라운드 로빈 방식. 태스크가 많아지면 프로세서를 할당 받을때 까지 시간이 오래 걸림. 우선순위별로 라운드 로빈 방식을 적용할 필요. 멀티레벨 큐. 멀티 피드백 큐. 16.1.2 스케줄러와 자료구조 스케줄러가 태스크를 선택하려면 실행할 태스크를 모아 놓을 자료구조가 필요. 삽입, 제거 기능을 포함한 검색이나 임의의 위치에 데이터를 제거하는 기능이 필요, 리스트. 16.1.3 범용 리스트의 설계외 구현// 데이터를 연결하는 구조체 typedef struct kListLinkStruct{ void* pvNext; QWORD qwID; } LISTLINK; // 리스트를 관리하는 구조체 typedef struct kLiskManagerStruct{ int iItemCount; void* pvHeader; void* pvTail; } LIST; 리스트를 구현하는데 있어 핵심적인 부분은 다음 데이터의 어드레스를 관리하는 것. 다음 데이터의 어드레스를 구조체 내에서 정의하면 쉽게 관리. 삽입할 때와 달리 리스트에 데이터를 제거할 때는 네 가지 경우를 고려. Header와 Tail의 값이 아무것도 없을 때. 가운데에 있는 데이터를 제거할 때. 리스트에 데이터가 2개 이상 존재하고, 처음이나 맨 뒤를 제거할 때. 18.3 코드 참조. 16.2 태스크 풀과 스케줄러16.2.1 태스크 풀과 스택 풀 설계typedef struct kTCBPoolManagerStruct { TCB* pstStartAddress; int iMaxCount; int iUseCount; int iAllocatedCount } 태스크 풀은 태스크 자료구조를 모아 놓은 자료 공간, 태스크를 생상하거나 삭제할 때 사용할 TCB가 모여 있는 특정 메모리 영역. 태스크 풀을 IST 영역 이후에 별도 공간에 할당할 예정. 16.2.2 태스크 풀과 스택 풀 구현 구현할 운영체제에서는 최대 1024개의 태스크를 생성할 수 있게 설정. 태스크를 할당하기 위해서는 태스크 풀을 검색해 TCB가 할당된 상태인지, 해제된 상태인지를 확인. iAllocatedCount와 TCB의 ID의 상위 32비트를 OR 연산하여 태스크를 구분. 해제 상태를 나타내는 필드를 쓰지 않고, ID 필드에 통합하여 관리하는 이유는 TCB ID의 중복을 막고자 하는 것. 18.3 코드 참조. 16.2.3 라운드 로빈 스케줄러 설계typedef struct kSchedulerStruct { // 현재 수행 중인 태스크 TCB* pstRunningTask; // 할당된 프로세서의 시간 int iProcessorTime; // 실행할 태스크가 준비 중인 리스트 List stReadyList; } 대기 중인 태스크의 목록과 현재 수행 중인 태스크 정보만 있으면 작동. 16.2.4 라운드 로빈 스케줄러 구현 부팅 과정에서 새로운 TCB를 할당받아 현재 수행 중인 태스크에 설정, 태스크를 전환할 때 부팅 과정을 진행한 태스크의 콘텍스트를 저장. 태스크를 전환하는 함수는 태스크 수행하는 중에 전환하는 코드와 인터럽트가 발생했을 때 전환하는 코드로 구분. 태스크 수행 중에 전환하는 함수는 인터럽트가 발생하지 못하도록 막는 코드를 포함해야 함. 인터럽트가 발생하면 IST에 이미 콘텍스트가 저장된 상태이므로, 콘텍스트를 따로 저장할 필요 없이 IST에서 TCB로 복사. 16.2.5 시분할 멀티태스킹 구현 시분할 멀티태스킹 기법은 일정한 시간을 개별 태스크에 할당하고 해당 시간이 만료되면 태스크를 강제로 전환하는 방식. PIT 컨트롤러가 발생시키는 IRQ 0 인터럽트를 활용. 16.3 라운드 로빈 스케줄러의 통합과 빌드16.3.1 리스트 파일 추가List.c 코드 보기List.h 코드 보기 16.3.2 태스크 파일 수정Task.c 코드 보기Task.h 보드 보기 16.3.3 인터럽트 관련 파일과 유틸리티 파일 수정ISR.asm 코드 보기interruptHandler.c 코드 보기interruptHandler.h 코드 보기Utility.c 코드 보기Utility.h 코드 보기 16.3.4 C 언어 커널 엔트리 포인트 파일과 콘솔 셸 파일 수정Main.c 코드 보기consoleShell.c 코드 보기 16.3.5 빌드와 실행 라운드 로빈 방식으로 화면 출력 태스킹을 수행. 마치며끝.. 코드를 이해하면 길이 보인다…..","categories":[{"name":"project","slug":"project","permalink":"http://DongyeolLee.github.io/categories/project/"},{"name":"정리","slug":"project/정리","permalink":"http://DongyeolLee.github.io/categories/project/정리/"},{"name":"os","slug":"project/정리/os","permalink":"http://DongyeolLee.github.io/categories/project/정리/os/"}],"tags":[{"name":"os","slug":"os","permalink":"http://DongyeolLee.github.io/tags/os/"}]},{"title":"백준[13301] - 타일 장식물","slug":"Al/13301","date":"2018-02-06T08:20:04.000Z","updated":"2019-04-30T07:24:41.148Z","comments":true,"path":"2018/02/06/Al/13301/","link":"","permalink":"http://DongyeolLee.github.io/2018/02/06/Al/13301/","excerpt":"","text":"문제백준 13301 문제 보기 접근 방법만들어지는 각 사각형의 둘레 및 변을 확인해보면 규칙이 있는 것을 확인할 수 있다. 코드#include &ltiostream&gt using namespace std; int N; // 타일의 수 long long temp; // 임시 박스 long long arr[80][4]; // 4변의 길이 저장 long long shLine; // 짧은 변 long long loLine; // 긴 변 int main() { cin >> N; arr[0][0] = 1; arr[0][1] = 1; arr[0][2] = 1; arr[0][3] = 1; shLine = arr[0][0]; loLine = arr[0][1] + arr [0][0]; for (int i = 1; i < N; i++) { for (int j = 0; j < 4; j++) { j % 2 == 0 ? arr[i][j] = shLine : arr[i][j] = loLine; } temp = shLine; shLine = loLine; loLine = shLine + temp; } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[13300] - 방 배정","slug":"Al/13300","date":"2018-02-05T12:36:12.000Z","updated":"2019-04-30T07:24:41.148Z","comments":true,"path":"2018/02/05/Al/13300/","link":"","permalink":"http://DongyeolLee.github.io/2018/02/05/Al/13300/","excerpt":"","text":"문제백준 13300 문제 보기 접근 방법인원을 학년별로 같은 성별끼리 저장한 뒤, 방의 최대 인원으로 각 학년별 인원을 나누었다. 코드#include &ltiostream&gt #include &ltcstring&gt #include &ltmath.h&gt using namespace std; int K; // 방의 최대 인원 수 int N; // 학생 수 int S; // 성별 int Y; // 학년 int cnt; // 방의 수 int arr[2][6]; // 학년 별 인원 int main() { cin >> N; cin >> K; cnt = 0; memset(arr, 0, sizeof(arr)); for (int i = 0; i < N; i++) { cin >> S; cin >> Y; arr[S][Y-1]++; } for (int i = 0; i < 2; i++){ for (int j = 0; j < 6; j++){ double temp; temp = arr[i][j] / (double)K; cnt += ceil(temp); } } cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"15. 태스크 개념을 추가해 멀티태스킹을 구현하자","slug":"OS/Project/AddBasicMultiTasking","date":"2018-02-05T02:04:19.000Z","updated":"2019-04-30T07:24:41.163Z","comments":true,"path":"2018/02/05/OS/Project/AddBasicMultiTasking/","link":"","permalink":"http://DongyeolLee.github.io/2018/02/05/OS/Project/AddBasicMultiTasking/","excerpt":"","text":"들어가기멀티태스킹 기능을 구현하면서 멀티태스킹이 무엇인지 알고 함수를 작성하자. 본론15.1 태스크, 멀티태스킹, 성능 향상15.1.1 태스크, 콘텍스트, 스택 태스크마다 개별적인 콘텍스트만 보장한다면 여러 개의 태스크를 동시에 실행해도 서로 간섭 없이 처리. 독립적인 콘텍스트를 보장한다 해도 스택이 구분되지 않으면 다른 태스크로 인해 스택의 내용이 변경되어 문제가 발생. 태스크에 의존적이지 않은 코드나 데이터는 쓰임에 따라 공유 가능. 15.1.2 멀티태스킹과 성능 향상 하나의 코어는 여러 개의 태스크를 동시에 실행할 수 없으므로 특정 시점에서 실행되는 태스크는 코어당 하나지만, 아주 짧은 주기마다 태스크를 전환. 멀티태스킹을 사용하는 가장 큰 두 가지 이유. 응답 시간이 빨라짐. CPU bound, I/O bound를 구분하여 CPU의 처리량을 극대화 할 수 있음. 15.2 태스크 제어 블록과 태스크 전환 구현15.2.1 태스크 제어 블록 정의 typedef struct kTaskControlBlockStruct { CONTEXT stContext; QWORD qwID; QWORD qwFlags; void* pvStackAddress; QWORD qwStackSize; } 인터럽트나 예외가 발생했을 때와 같은 순서로 콘텍스트 자료구조에 저장, 같은 순서로 저장하면 인터럽트나 예외 처리에 사용됐던 콘텍스트 저장과 복원 코드를 그대로 태스크 전환. 15.3 코드 참조. 15.2.2 태스크 생성 처리void kSetUpTask(TCB* pstTCB, QWORD qwID, QWORD qwFlags, QWORD qwEntryPointAddress, void* pvStackAddress, QWORD qwStackSize) { kMemSet(pstTCB -> stContext.vqRegister, 0, sizeof(pstTCB -> stContext.vqRegister)); // TCB 영역을 위한 스택 초기화 pstTCB -> stContext.vqRegister[TASK_RSPOFFSET] = (QWORD) pvStackAddress + qwStackSize; pstTCB -> stContext.vqRegister[TASK_RBPOFFSET] = (QWORD) pvStackAddress + qwStackSize; pstTCB -> stContext.vqRegister[TASK_CSOFFSET] = GDT_KERNELCODESEGMENT; pstTCB -> stContext.vqRegister[TASK_DSOFFSET] = GDT_KERNELDATASEGMENT; pstTCB -> stContext.vqRegister[TASK_ESOFFSET] = GDT_KERNELDATASEGMENT; pstTCB -> stContext.vqRegister[TASK_FSOFFSET] = GDT_KERNELDATASEGMENT; pstTCB -> stContext.vqRegister[TASK_GSOFFSET] = GDT_KERNELDATASEGMENT; pstTCB -> stContext.vqRegister[TASK_SSOFFSET] = GDT_KERNELDATASEGMENT; pstTCB -> stContext.vqRegister[TASK_RIPOFFSET] = qwEntryPointAddress; pstTCB -> stContext.vqRegister[TASK_RFLAGSOFFSET] |= 0x0200; pstTCB -> qwID = qwID; pstTCB -> pvStackAddress = pvStackAddress; pstTCB -> qwStackSize = qwStackSize; pstTCB -> qwFlags = qwFlags; } RSP와 RBP 레지스터는 스택의 TOP을 나타냄으로 태스크가 생성되었을때 스택은 비어있는 상태, 초기화 필요. RIP는 해당 태스크로 전환했을 때 실행을 시작하는 코드의 어드레스. 15.2.3 태스크 전환 처리 프로세서에서 자동으로 저장하는 SS, RSP, RFLAGS, CS, RIP를 주의해서 저장. SS, RFLAGS, CS 레지스터는 현재 프로세서에 저장된 값을 그대로 저장. 15.3 코드 참조. 15.3 멀티태스킹 기능 통합과 빌드15.3.1 태스크 파일 추가 Task.c 코드 보기 Tack.h 코드 보기 15.3.2 어셈블리어 유틸리티 파일 수정 AssemblyUtility.asm 코드 보기 AssemblyUtility.h 코드 보기 15.3.3 콘솔 셸 파일 수정 ConsoleShell.c 코드 보기 ConsoleShell.h 코드 보기 15.3.4 빌드와 실행 마치며끝..","categories":[{"name":"project","slug":"project","permalink":"http://DongyeolLee.github.io/categories/project/"},{"name":"정리","slug":"project/정리","permalink":"http://DongyeolLee.github.io/categories/project/정리/"},{"name":"os","slug":"project/정리/os","permalink":"http://DongyeolLee.github.io/categories/project/정리/os/"}],"tags":[{"name":"os","slug":"os","permalink":"http://DongyeolLee.github.io/tags/os/"}]},{"title":"14. 타이머 디바이스 드라이버를 추가하자","slug":"OS/Project/AddTimerDeviceDriver","date":"2018-02-02T05:59:38.000Z","updated":"2019-04-30T07:24:41.164Z","comments":true,"path":"2018/02/02/OS/Project/AddTimerDeviceDriver/","link":"","permalink":"http://DongyeolLee.github.io/2018/02/02/OS/Project/AddTimerDeviceDriver/","excerpt":"","text":"들어가기PIT 컨트롤러 제어, 타임 스탬프 카운터와 RTC 통해 정밀하게 시간 측정하는 방법에 대해 알아보자. 본론14.1 디바이스의 특징과 쓰임 타이머 디바이스(PIT)는 PIC의 IRQ 0에 연결, 한 번 또는 일정한 주기로 인터럽트를 발생시킴. 타임 스탬프 카운터는 프로세서 내부에서 클록을 기준으로 카운터가 증가, 클록의 주기가 빨라서 정밀한 시간 측정이 가능하고, 프로세서의 클록을 기준으로 동작하기 때문에 프로파일링에 유용. RTC는 PC의 시계로서 별도의 전원이 존재해 컴퓨터 전원이 꺼져있어도 작동. 14.2 PIT 컨트롤러의 구조와 기능14.2.1 PIT 컨트롤러, I/O 포트, 레지스터 PIT 컨트롤러는 1개의 컨트롤 레지스터와 3개의 카운터로 구성. 컨트롤 레지스터는 쓰기만 가능하고 카운터는 읽기 쓰기 가능. PIT 컨트롤러의 컨트롤 레지스터의 크기는 1 바이트, 카운터 레지스터는 2 바이트. PIT 컨트롤러는의 내부 클록은 1.193182Mhz로 동작, 매회 마다 카운터의 값을 1씩 감소, 0이 되었을 때 신호를 발생. 컨트롤 레지스터의 모드는 총 6개가 존재, 모드 0과 모드 2를 사용. 모드 0 : 카운터가 0이 되었을 때, 외부로 신호를 발생. 모드 2 : 일정한 주기로 신호를 발생. 카운터 0은 다른 카운터와 다르게 IRQ0에 연결되어 있음. 14.2.2 PIT 컨트롤러 초기화#define PIT_FREQUENCY 1193180 #define MSTOCOUNT(x) (PIT_FREQUENCY * (x) / 1000) #define USTOCOUNT(x) (PIT_FREQUENCY * (x) / 1000000) ... 생략 ... //1ms마다 주기적으로 인터럽트 발생 kInitializePIT(MSTOCOUNT(1), true); //100us 후에 인터럽트를 발생 kInitializePIT(USTOCOUNT(100), false) PIT 컨트롤러를 이용해서 시간을 측정하려면 시간을 PIT 컨트롤의 카운터 값으로 변환. 1초에 1193182번 카운터가 증가하므로 이를 계산. 14.2.3 카운터를 읽어 직접 시간 계산하기WORD kReadCounter0() { BYTE bHigh, bLow; WORD wTemp = 0; kOutPortByte(PIT_PORT_CONTROL, PIT_COUNTER0_LATCH); bLow = kInPortByte(PIT_PORT_COUNTER0); bHigh = kInPortByte(PIT_PORT_COUNTER0); wTemp = bHigh; wTemp = (wTemp","categories":[{"name":"project","slug":"project","permalink":"http://DongyeolLee.github.io/categories/project/"},{"name":"정리","slug":"project/정리","permalink":"http://DongyeolLee.github.io/categories/project/정리/"},{"name":"os","slug":"project/정리/os","permalink":"http://DongyeolLee.github.io/categories/project/정리/os/"}],"tags":[{"name":"os","slug":"os","permalink":"http://DongyeolLee.github.io/tags/os/"}]},{"title":"백준[14864] - 줄서기","slug":"Al/14864","date":"2018-02-02T05:12:48.000Z","updated":"2019-04-30T07:24:41.150Z","comments":true,"path":"2018/02/02/Al/14864/","link":"","permalink":"http://DongyeolLee.github.io/2018/02/02/Al/14864/","excerpt":"","text":"문제백준 14864 문제 보기 접근 방법문제를 손으로 적어보고 그대로 구현해보니깐 정답이 나왔다. 그래도 초반 몇번의 제출에서는 시간 초과가 나왔는데 벡터를 사용하는 대신 배열을 사용해서 시간 초과가 났다. 이유는 중간을 지웠을 경우 중간 인덱스서 부터 맨끝까지 한 칸씩 앞으로 땡겨야 했다.문제 접근은 처음 입력을 받으면서 나보다 뒤에 몇명이 작은 숫자를 들고 있는지 확인한다. 즉, (1,2),(1,3)이 입력이 될 경우 1 학생 입장에서는 자신 보다 뒤에 서고 작은 숫자를 들고 있는 사람이 2명이다. 따라서 strArr[1] = 2 이다.그리고 카드 벡터에서 1 학생 입장에서 자신 보다 작은 숫자가 2개 있으므로 3 번째 작은 숫자를 뽑고 erase한다. 이런식으로 배열을 만든 뒤 모든 입력쌍과 학생들이 들고 있는 카드의 배열이 맞는지 확인한다. 코드#include &ltiostream&gt #include &ltutility&gt #include &ltcstring&gt #include &ltalgorithm&gt #include &ltvector&gt using namespace std; int N, M; int student[100001]; int stdArr[100001]; vector&ltint&gt card; pair&ltint, int&gt arr[1000001]; int check() { for(int i = 1; i &lt= M; i ++) { int x = arr[i].first; int y = arr[i].second; if(student[x] < student[y]) { return -1; } } return 1; } int main() { cin >> N >> M; memset(stdArr, 0, sizeof(stdArr)); for(int i = 1; i &lt= N; i ++) { card.push_back(i); } for(int i = 1; i &lt= M; i ++) { int a, b; cin >> a >> b; stdArr[a]++; arr[i].first = a; arr[i].second = b; } if(N == 1) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"13. 콘솔 셸을 만들자","slug":"OS/Project/MakeAConsoleShell","date":"2018-01-31T01:33:45.000Z","updated":"2019-04-30T07:24:41.165Z","comments":true,"path":"2018/01/31/OS/Project/MakeAConsoleShell/","link":"","permalink":"http://DongyeolLee.github.io/2018/01/31/OS/Project/MakeAConsoleShell/","excerpt":"","text":"들어가기셸을 구현하는데 필요한 콘솔 라이브러리를 구현하고 콘솔 라이브러리를 구성하는 함수를 구현하는데 필요한 가변 인자 처리 방법. 본론13.1 sprintf()와 가변 인자 처리13.1.1 포맷 스트링과 가변 인자// 가변 인자 예시 printf(\"%s\", \"test\") 포맷 스트링에는 함수의 파라미터가 가변적이라는 전제가 포함. 함수를 호출하는 쪽에서 넘기는 파라미터의 정보를 알려줘야함. 포맷스트링을 보고 대략적인 파라미터의 수를 파악할 수 있지만 정확하지 않음. void main (void) { int iSum; iSum = sum(5, 1, 2, 3, 4, 5); printf(\"Sum = %d\\n\", iSum); } int sum(int iParameterCount, ...) { int i; int iSum = 0; QWORD qwArgumentStartAddress; qwArgumentStartAddress = ((QWORD) (&iParameterCount)) + 8; for(i = 0; i < iParameterCount; i ++) { iSum += *((int *) (qwArgumentStartAddress)); qwArgumentStartAddress += 8; } return iSum; } 파라미터를 모두 스택에 넣어 전달하고, 호출되는 함수는 포맷 스트링을 참조하여 스택에서 파라미터를 직접 참조. int Sum(int iParameterCount, ...) { va_list va; int i; int iSum = 0; // 가변 인자의 주소를 가변 인자 리스트에 등록 va_start(va, iParameterCount); for(i = 0; i < iParameterCount; i ++) { // 가변 인자 리스트에서 int 데이터를 꺼내고 다음 파라미터로 이동 iSum += (int) va_arg(va, int); } va_end(va); return iSum; } C 언어는 가변 인자 처리를 위해 매크로가 존재. va_list : 데이터 타입. va_start() : 가변 인자의 시작 주소. va_arg() : 데이터 타입에 해당하는 값을 꺼내고 이동. va_end() : 가변 인자 리스트 종료. 13.1.2 sprintf() 함수와 vsprintf() 함수 구현int printf(const char* pcFormatString, ...) { ... // 문법 오류 -> '...'를 다른 함수의 파라미터로 전달할 수 없음 sprintf(vcBuffer, pcFormatString, ...); // 가능 va_start(va, pcFormatString); vsprintf(vcBuffer, pcFormatString, va); va_end(va); ... } vsprintf() 함수는 sprintf() 함수의 실질적인 기능을 담당, 가변 인자 대신 va_list 타입의 가변 인자 리스트를 받아서 처리. while(포맷 스트링의 끝이 아님) { if(데이터 타입을 나타내는 '%' 문자인가) { '%' 이후의 문자에 따라 가변 인자의 타입을 해석하여 출력 버퍼에 복사. } else { 포맷 스트링의 현재 문자를 출력 버퍼에 복사 } 포맷 스트링 내의 문자 위치를 다음을 이동 } vsprintf()의 함수의 알고리즘. 13.1.3 itoa() 함수와 atoi() 함수 구현int kIToA(long iValue, char* buffer, int iRadix) { int iReturn; switch(iRadix) { case 16: 정수 값을 16진수 문자열로 변환하는 함수 break; case 10: 정수 값을 10진수 문자열로 변환하는 함수 break; } return iReturn; } C에서의 itoa를 구현한 알고리즘. 정수 값을 문자열로 바꾸는 방법은 여러가지가 존재. 전체 코드는 13.4 참조. 13.2 콘솔 입출력 처리13.2.1 콘솔 자료구조 생성과 printf() 함수 구현#pragma pack(push, 1) typedef struct kConsoleManagerStruct { // 문자와 커서를 출력할 위치 int iCurrentPrintOffset; }CONSOLEMANAGER #pragma pack(pop) 커서 위치를 추가할 자료 구조. 그래픽 모드로 전환하기 전까지 텍스트 모드 사용, 80 컬럼에 25라인 출력. 전체 코드는 13.4 참조. 13.2.2 커서 제어 커서는 모니터 출력을 담당하는 VGA 컨트롤러가 담당. 컨트롤러 어드레스 레지스터, 0x3D4. 컨트롤러 데이터 레지스터, 0x3D5. 커서 위치 제어를 위해 컨트롤러 어드레스 레지스터에 0xE, 0xF를 전달. 컨트롤러 데이터 레지스터에 상위 바이트, 하위 바이트로 나누어 커서 위치를 전달. 13.3 셸 구현13.3.1 프롬프트, 커맨드 버퍼, 사용자 입력 처리 프롬프트는 셸이 사용자로부터 키를 입력받을 준비가 되어있다는 것. 전체 코드는 13.4 참조. 13.3.2 커맨드 비교와 커맨드 실행typedef void(* CommandFunction) (const char* pcParameter); typedef struct kShellCommandEntryStruct { // 커맨드의 도움말 char* pcHelp; // 커맨드를 수행할 함수 포인터 CommandFunction pfFunction; }SHELLCOMMANDENTRY; 함수 포인터를 통해 커맨드 함수 실행, if-else 구조보다 유지보수에 있어 수월. 전체 코드는 13.4 참조. 13.4 콘솔 라이브러리와 셀의 통합과 빌드13.4.1 콘솔 파일 추가Console.c 코드 보기Console.h 코드 보기 13.4.2 콘솔 셸 파일 추가ConsoleShell.c 코드 보기ConsoleShell.h 코드 보기 13.4.3 유틸리티 파일 수정Utility.c 코드 보기Utility.h 코드 보기 13.4.4 인터럽트 핸들러 파일 수정InterruptHandler.c 코드 보기 13.4.5 C 언어 커널 엔트리 포인트 파일 수정Main.c 코드 보기 13.4.6 빌드와 실행 마치며끝!!","categories":[{"name":"project","slug":"project","permalink":"http://DongyeolLee.github.io/categories/project/"},{"name":"정리","slug":"project/정리","permalink":"http://DongyeolLee.github.io/categories/project/정리/"},{"name":"os","slug":"project/정리/os","permalink":"http://DongyeolLee.github.io/categories/project/정리/os/"}],"tags":[{"name":"os","slug":"os","permalink":"http://DongyeolLee.github.io/tags/os/"}]},{"title":"12. 키보드 디바이스 드라이버를 업그레이드하자","slug":"OS/Project/UpgradeKeyboardDeviceDriver","date":"2018-01-30T06:55:06.000Z","updated":"2019-04-30T07:24:41.166Z","comments":true,"path":"2018/01/30/OS/Project/UpgradeKeyboardDeviceDriver/","link":"","permalink":"http://DongyeolLee.github.io/2018/01/30/OS/Project/UpgradeKeyboardDeviceDriver/","excerpt":"","text":"들어가기데이터를 전달하는 큐를 구현해 인터럽트 핸들러에서 셸 코드로 키 정보를 전달. 본론12.1 인터럽트 핸들러와 큐12.1.1 인터럽트 핸들러와 어떻게 통신할까? 인터럽트 핸들러는 디바이스에서 읽은 데이터를 버퍼에 저장하고, 프로그램은 버퍼를 확인하여 이를 처리. 12.1.2 큐란 무엇인가? FIFO 구조의 자료구조. 12.1.3 범용 큐 설계 범용 큐의 설계에 있어서 두 가지 상황을 고려. 삽입이나 제거한 뒤에 위치가 버퍼의 최댓값을 초과하는 경우. 삽입하거나 제거한 뒤에 두 위치가 같아지는 경우. 전자는 인덱스를 다시 처음으로 되돌려 환형 큐 형식으로 설계. 후자는 다시 두 가지 상황을 고려. 제거 동작을 수행한 후 두 위치가 같아지는 경우. 삽입 후 두 위치가 같아지는 경우. 12.1.4 범용 큐 구현과 사용 방법typedef struct kQueueManagerStruct { int iDataSize; int iMaxDataCount; void* pvQueueArray; int iPutIndex; int iGetIndex; // 큐에 수행된 마지막 명령이 삽입인지 저장인지 확인. bool bLastOperationPut; }QUEUE; bLastOperationPut 필드는 삽입 위치와 제거 위치가 같아지는 경우를 처리하려고 추가한 필드. 삽입 동작을 수행할 때 True, 제거 동작을 수행할 때 False. void kInitializeQueue(QUEUE* pstQueue, void* pvQueueBuffer, int iMaxDataCount, int iDataSize) { pstQueue -> iMaxDataCount = iMaxDataCount; pstQueue -> iDataSize = iDataSize; pstQueue -> pvQueueArray = pvQueueBuffer; pstQueue -> iPutIndex = 0; pstQueue -> iGetIndex = 0; pstQueue -> bLastOperationPut = FALSE; } 초기화하는 함수는 큐 버퍼 어드레스와 데이터의 크기를 설정하고 나머지 필드를 0으로 설정. 12.2 키보드 디바이스 드라이버 업그레이드12.2.1 키 정보를 저장하는 자료구조와 큐 생성typedef struct kKeyDataStruct { // 키보드에서 전달된 스캔 코드 BYTE bScanCode; // 변환한 아스키 코드 BYTE bASCIICode; // 키 상태를 저장하는 플래그 BYTE bFlags; }KEYDATA; 키 정보를 전달하는데 사용할 자료구조. 전체 코드는 12.3 참조. 12.2.2 키보드 핸들러 수정 전체 코드는 12.3 참조. 12.2.3 셀 코드 수정 전체 코드는 12.3 참조. 12.3 키보드 디바이스 드라이버의 업그레이드와 빌드12.3.1 큐 파일 추가Queue.c 코드 보기Queue.h 코드 보기 12.3.2 키보드 디바이스 드라이버 파일 수정Keyboard.c 코드 보기Keyboard.h 코드 보기 12.3.3 인터럽트 핸들러 파일과 유틸리티 파일 수정InterruptHandler.c 코드 보기 12.3.4 C 언어 커널 엔트리 포인트 파일 수정Utility.c 코드 보기Utility.h 코드 보기 12.3.5 빌드와 실행 마치며끝.","categories":[{"name":"project","slug":"project","permalink":"http://DongyeolLee.github.io/categories/project/"},{"name":"정리","slug":"project/정리","permalink":"http://DongyeolLee.github.io/categories/project/정리/"},{"name":"os","slug":"project/정리/os","permalink":"http://DongyeolLee.github.io/categories/project/정리/os/"}],"tags":[{"name":"os","slug":"os","permalink":"http://DongyeolLee.github.io/tags/os/"}]},{"title":"11. PIC 컨트롤러와 인터럽트 핸들러를 이용해 인터럽트를 처리하자","slug":"OS/Project/PIC-controllerAndInterruptHandler","date":"2018-01-27T05:56:03.000Z","updated":"2019-04-30T07:24:41.165Z","comments":true,"path":"2018/01/27/OS/Project/PIC-controllerAndInterruptHandler/","link":"","permalink":"http://DongyeolLee.github.io/2018/01/27/OS/Project/PIC-controllerAndInterruptHandler/","excerpt":"","text":"들어가기PIC 컨트롤러로 인터럽트를 프로세서에 전달하고 실행 중이던 코드로의 복귀를 구현해보자. 본론11.1 PIC 컨트롤러 소개11.1.1 PIC 컨트롤러란 PIC 컨트롤러는 인터럽트 처리에 관련된 세부기능을 프로그래밍할 수 있는 컨트롤러. 마스터-슬레이브 방식으로 연결해 15개의 인터럽트를 처리. PIC 컨트롤러는 각각 8개의 핀으로 총 16개를 구성하지만 핀 하나는 슬레이브와 연결. 11.1.2 PIC 컨트롤러의 구조와 동작 방식 PIC 컨트롤러는 내부에 8비트 크기의 IRR, ISR, IMR 레지스터가 존재. IRR, 인터럽트가 발생한 핀의 정보를 관리 ISR, 현재 인터럽트 핸들러가 실행 중인 인터럽트 정보를 저장. IMR, 비트가 1로 설정된 인터럽트 핀에서 발생한 요청을 무시하는 역할. 11.2 PIC 컨트롤러 제어11.2.1 PIC 컨트롤러 초기화 PIC 컨트롤러는 I/O 포트 방식으로 연결 마스터 PIC 컨트롤러는 0x20, 0x21을 사용하고 슬레이브 PIC 컨트롤러는 0xA0과 0xA1을 사용. PIC 컨트롤러는 크게 두가지 타입의 커맨드를 제공. ICW, 초기화와 관련된 명령. OCW, 제어와 관련된 명령. 해당 포트로 ICW1을 보내면 해당 포트에 쓰는 데이터는 ICW2, ICW3, ICW4 순서대로 해석. 11.2.2 인터럽트 입력 선택void kMaskPICInterrupt(WORD wIRQBitmask) { // 마스터 PIC 컨트로러에 IMR 설정. kOutPortByte(PIC_MASTER_PORT2, (BYTE) wIRQBitmask); // 슬레이브 PIC 컨트롤러에 IMR 설정. kOutPortByte(PIC_MASTER_PORT2, (BYTE) (wIRQBitmask >> 8)); } PIC 컨트롤러는 IRQ를 특정 벡터에 매핑하는 기능 외에 특정 인터럽트를 선택할 수 있는 기능도 있음. OCW1를 이용해, IMR 레지스터에 무시할 인터럽트를 1로 설정. 11.2.3 인터럽트 종료 처리void kSendEOIToPIC(int iIRQNumber) { kOutPortByte(PIC_MASTER_PORT1, 0x20); if(iIRQNumber >= 8) { kOutPortByte(PIC_SLAVE_PORT1, 0x20); } } 프로세서는 핸들러를 실행하여 인터럽트 처리를 완료한 후 다시 PIC 컨트롤러에 알려줘야 함. 프로세서가 알려주지 않으면 PIC 컨르롤러는 핸들러가 수행중인 것으로 간주, 해당 인터럽트보다 우선순귀가 낮은 인터럽트를 실행하지 않음. 11.3 인터럽트, 예외 핸들러, 콘텍스트11.3.1 임시 핸들러의 문제점 임시 핸들러는 인터럽트나 예외처리 후 코드로 복귀했을 때 두 가지 문제로 정상적으로 코드를 수행할 수 없음. 복귀할 때 사용하는 명령어를 사용하지 않음. 프로세서의 상태를 완정히 저장 및 복원하지 않았다는 점. 11.3.2 콘텍스트 저장과 복원 인터럽트 또는 예외로 인해 핸들러가 수행되거나 어떤 이유로 현재 수행 중인 코드를 중단하고 나서 다시 수행해야 한다면 전후 콘텍스트를 동일하게 유지해야 가능. 스택에 프로세서가 저장하는 레지스터를 제외하고 저장. 11.3.3 인터럽트와 예외 핸들러 업그레이드; 콘텍스트를 저장하고 셀렉터를 교체하는 매크로 %macro KSAVECONTEXT 0 ; 파라미터를 전달받지 않는 KSAVECONTEXT 매크로 정의 ; RBP 레지스터부터 GS 세그먼트 셀렉터까지 모두 스택에 삽입 push rbp mov rbp, rsp push rax push rbx push rcx push rdx push rdi push rsi push r8 push r9 push r10 push r11 push r12 push r13 push r14 push r15 mov ax, ds ; DS 세그먼트 셀렉터와 ES 세그먼트 셀렉터는 스택에 직접 push rax ; 삽입할 수 없으므로, RAX 레지스터에 저장한 후 스택에 삽입 mov ax, es push rax push fs push gs ; 세그먼트 셀렉터 교체 mov ax, 0x10 ; AX 레지스터에 커널 데이터 세그먼트 디스크립터 저장 mov ds, ax ; DS 세그먼트 셀렉터부터 FS 세그먼트 셀렉터까지 모두 mov es, ax ; 커널 데이터 세그먼트로 교체 mov gs, ax mov fs, ax %endmacro ; 매크로 끝 ; 콘텍스트를 복원하는 매크로 %macro KLOADCONTEXT 0 ; 파라미터를 전달받지 않는 KSAVECONTEXT 매크로 정의 ; GS 세그먼트 셀렉터부터 RBP 레지스터까지 모두 스택에서 꺼내 복원 pop gs pop fs pop rax mov es, ax ; ES 세그먼트 셀렉터와 DS 세그먼트 셀렉터는 스택에서 직접 pop rax ; 꺼내 복원할 수 없으므로, RAX 레지스터에 저장한 뒤에 복원 mov ds, ax pop r15 pop r14 pop r13 pop r12 pop r11 pop r10 pop r9 pop r8 pop rsi pop rdi pop rdx pop rcx pop rbx pop rax pop rbp %endmacro ; 매크로 끝 ISR 함수는 인터럽트 처리를 위해 모두 16개를 작성해야하는데, 이를 위해 nasm에서 매크로를 정의. 11.3.4 IDT 테이블 수정 이전 코드의 kDummyHandler 부분을 추가한 핸들러로 대체. 11.4 PIC 컨트롤러 제어 코드와 핸들러 코드의 통합과 빌드11.4.1 PIC 컨트롤러 파일 추가PIC.c 코드 보기;PIC.h 코드 보기; 11.4.2 ISR 파일 추가ISR.asm 코드 보기;ISR.h 코드 보기; 11.4.3 인터럽트 핸들러 파일 추가InterruptHandler.c 코드 보기;InterruptHandler.h 코드 보기; 11.4.4 어셈블리어 유틸리티 파일 수정AssemblyUtility.asm 코드 보기;AssemblyUtility.h 코드 보기; 11.4.5 디스크립터 파일 수정Descriptor.c 코드 보기; 11.4.6 C 언어 커널 엔트리 포인트 파일 수정Main.c 코드 보기; 11.4.7 빌드와 실행 마치며끝","categories":[{"name":"project","slug":"project","permalink":"http://DongyeolLee.github.io/categories/project/"},{"name":"정리","slug":"project/정리","permalink":"http://DongyeolLee.github.io/categories/project/정리/"},{"name":"os","slug":"project/정리/os","permalink":"http://DongyeolLee.github.io/categories/project/정리/os/"}],"tags":[{"name":"os","slug":"os","permalink":"http://DongyeolLee.github.io/tags/os/"}]},{"title":"백준[14863] - 서울에서 경산까지","slug":"Al/14863","date":"2018-01-25T14:35:27.000Z","updated":"2019-04-30T07:24:41.150Z","comments":true,"path":"2018/01/25/Al/14863/","link":"","permalink":"http://DongyeolLee.github.io/2018/01/25/Al/14863/","excerpt":"","text":"문제백준 14863 문제 보기 접근 방법빠르게 틀을 만들어 놓고 이상한 곳에서 실수를 너무 많이했다. 문제 접근은 처음 도보와 자전거를 모두 dfs로 탐색한다. 하지만 이전에 진행했던 경로를 저장하지 않으면 시간복잡도는 O(2^n)으로 시간 초과를 유발한다. 따라서 이전에 지나갔던 노드라면 memo에서 꺼내어 여지껏 노드까지 온 거리를 더해서 리턴한다.하지만 실수가 2가지 있었다. 목적지에 도착했을때만 memo에 값을 저장했다. 목적지 이동 도중 이미 제한된 시간을 넘어서 지나가면 안되는 길을 저장하지않아 제출했을때 시간 초과가 났다. 이를 해결하고 다시 제출했을때 또 문제가 있었다. 제한 시간과 소모 시간을 비교하는 if(time &gt; k)가 memo보다 아래에 있어 memo[cnt][time]을 수행할때 index out of array로 틀렸었다. 코드#include &ltiostream&gt #include &ltcstring&gt using namespace std; #define IMPOSSIBLE (-987654321) int N, K; int arr[101][5]; int memo[101][100001]; int dfs(int cnt, int money ,int time) { if(time > K) { return IMPOSSIBLE; } if(memo[cnt][time] == IMPOSSIBLE) { return IMPOSSIBLE; } if(cnt == N && time &lt= K) { return money; } if(memo[cnt][time] != -1) { return memo[cnt][time] + money; } int val = IMPOSSIBLE; val = max(val, dfs(cnt + 1, money + arr[cnt + 1][2], time + arr[cnt + 1][1])); val = max(val, dfs(cnt + 1, money + arr[cnt + 1][4], time + arr[cnt + 1][3])); if(val == IMPOSSIBLE) { memo[cnt][time] = IMPOSSIBLE; } else { memo[cnt][time] = val - money; } return val; } int main() { cin >> N >> K; memset(memo, -1, sizeof(memo)); // 시간, 모금액, 자전거 시간, 자전거 모금액 for(int i = 1; i &lt= N; i ++) { cin >> arr[i][1] >> arr[i][2] >> arr[i][3] >> arr[i][4]; } int ans = dfs(1, arr[1][2], arr[1][1]); ans = max(ans, dfs(1, arr[1][4], arr[1][3])); cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"백준[14697] - 방 배정하기","slug":"Al/14697","date":"2018-01-23T15:44:11.000Z","updated":"2019-04-30T07:24:41.150Z","comments":true,"path":"2018/01/24/Al/14697/","link":"","permalink":"http://DongyeolLee.github.io/2018/01/24/Al/14697/","excerpt":"","text":"문제백준 14697 문제 보기 접근 방법처음에는 dfs로 문제를 접근하려했다. 하지만 dfs로 문제를 풀 경우 O(3^N)이라는 큰 시간복잡도를 보인다. 이를 해결하기 위해 복잡한 예외 처리 및 메모이제이션을 사용해야할 것 같아 다른 방법을 생각해 보았다. 결과적으로 브루스포스로 접근하면 O(N^3)으로 쉽게 해결할 수 있다. 코드 #include &ltiostream&gt using namespace std; int A, B, C, st; int temp1, temp2, temp3; int main() { cin >> A >> B >> C >> st; for(int i = 0; i &lt= 113; i ++) { temp1 = A * i; for(int j = 0; j &lt= 113; j ++) { temp2 = B * j; for(int z = 0; z &lt= 113; z ++) { temp3 = C * z; if(temp1 + temp2 + temp3 == st) { cout","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"problems","slug":"computer-science/algorithms/problems","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/problems/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"}]},{"title":"10. GDT, IDT 테이블, TSS 세그먼트를 추가해 인터럽트에 대비하자","slug":"OS/Project/PrepareForInterrupt","date":"2018-01-23T09:33:45.000Z","updated":"2019-04-30T07:24:41.166Z","comments":true,"path":"2018/01/23/OS/Project/PrepareForInterrupt/","link":"","permalink":"http://DongyeolLee.github.io/2018/01/23/OS/Project/PrepareForInterrupt/","excerpt":"","text":"들어가기TSS 세그먼트와 IDT 테이블을 생성하는 방법에 대해 알아보고, 임시 핸들러를 등록해보자. 본론10.1 인터럽트와 예외10.1.1 인터럽트와 예외의 차이점 인터럽트와 예외의 공통점은 코드 수행 도중에 발생하거나 프로세서에 의해 처리가 필요한 이벤트. 인터럽트나 예외가 발생하면 준비한 특수 코드를 실행. 인터럽트와 예외의 차이점은 이벤트를 발생시키는 주체가 다름. 인터럽트는 외부 디바이스에 의해 프로세서에 전달되는 이벤트. 예외는 프로세서가 코드를 수행하는 도중에 페이지 폴트나 잘못된 명령 같은 오류로 발생. 이벤트별로 특수한 처리 함수가 필요 -&gt; 인터럽트 또는 예외 핸들러. 핸들러는 함수를 수행 후 발생한 시점으로 정상적으로 복귀. 10.1.2 IDT와 IDT 게이트 디스크립터 프로세서는 인터럽트가 발생했을때 벡터 테이블의 인덱스에 해당하는 어드레스로 이동하여 처리 함수를 수행. 벡터 테이블은 각 운영 모드마다 존재. 리얼 모드의 벡터 테이블은 세그먼트 : 어드레스의 형태로 어드레스 0x0000 : 0x0000에 위치. 보호 모드와 IA-32e 모드에서는 IDT라고 불리는 특수한 형태의 벡터 테이블 사용. IDT는 IDT 게이트 디스크립터로 구성된 테이블, IDTR 레지스터를 통해 프로세서에 IDT 정보를 설정하며 최대 256의 엔트리. IDT 게이트 디스크립터는 다른 디스크립터와 달리 세그먼트 셀렉터를 포함 -&gt; 유저 레벨의 어플리케이션 코드를 실행 중 인터럽트 발생시 커널 레벨로 올라가야하기 때문. IDT 게이트 디스크립터는 여러 가지 타입이 있음. 태스크 게이트 인터럽트 게이트 트랩 게이트 보호 모드만 세가지 다 지원하며 IA-32e 모드는 하위 2개의 게이트만 지원. 인터럽트 게이트와 트랩 게이트의 차이는 핸들러 실행 중 추가 인터럽트를 발생 시키느냐의 여부. 인터럽트 게이트를 사용해 예외 처리를 하는 동안 인터럽트가 더 이상 발생하지 않음. IST는 IA-32e 모드에서 도입된 새로운 개념으로 인터럽트나 예외가 발생했을 때 별도의 스택 공간을 할당. 10.1.3 인터럽트와 예외의 종류 x86 프로세스는 IDT 테이블의 상위 32개 디스크립터를 예약, 20개는 실제로 사용되며 12개는 앞으로 사용을 위해 미리 예약한 영역. 즉, 224개는 OS가 임의로 사용할 수 있는 부분. 프로세서가 사용하는 20개의 예외는 3가지로 분류. faults는 코드에 문제가 발생했으나 수정하면 정상적으로 실행 가능한 예외. traps는 trap을 유발하는 명령어를 실행했을 때 발생. aborts는 심각한 문제가 발생하여 더이상 코드를 실행할 수 없는 경우. 10.2 인터럽트와 예외, 스택과 태스크 상태 세그먼트10.2.1 스택 스위칭과 IST IDT 게이트 디스크립터에 설정된 코드 디스크립터의 권한이 현재 수행 중인 코드의 권한보다 높으면 새로운 스택으로 전환 -&gt; 스택 스위칭. 스택 스위칭을 하는 첫 번째 이유는 핸들러의 스택 공간 부족으로 오류가 발생하는 일을 방지. 스택 스위칭을 하는 두 번째 이유는 권한이 높은 함수가 낮은 권한의 스택을 공유함으로써 발생할 수 있는 간섭을 최소화. 보호 모드도 스택 스위칭을 지원하지만 권한이 변경되어야만 스택 스위칭이 발생. IST는 인터럽트 처리를 위한 스택을 정의한 테이블로 최대 7개의 스택을 지정. IST는 권한 변동 없이 무조건 스택 스위칭이 발생. IST의 스택에서 수행 중이던 코드의 정보와 스택의 정보를 저장해 커널의 스택 데이터 유지. 10.2.2 프로세서와 태스크 상태 세그먼트, 태스크 디스크립터 TSS는 104 바이트로 태스크의 상태를 저장하는 영역으로 프로세스의 상태를 저장하는 역할. 보호 모드의 TSS는 특정 레지스터를 제외하고 프로세서의 모든 레지스터를 저장, 또한 권한별 스택 정보를 저장하는 역할과 I/O 포트에 접근하는 것을 제한. IA-32e 모드로 옮기면서 TSS 위상 추락, 레지스터의 크기가 커지면서 고정된 TSS를 사용할 수 없게됨. IST 정보를 저장하는 역할을 IA-32e 모드에서 함. 프로세서에 TSS 세그먼트에 대한 정보를 알려주는 TSS 디스크립터와 LTR 어셈블리어 명령어. TSS 디스크립터는 GDT 테이블에 있으며 16바이트를 차지. 10.3 GDT 테이블 교환과 TSS 세그먼트 디스크립터 추가10.3.1 왜 GDT 테이블을 교환해야 하는가? 어셈블리어로 작성된 보호 모드 GDT에 추가해도 되지만, 커널 엔트리 포인트 영역(512바이트)에 비해 104바이트의 TSS 세그멘트 디스크립터가 너무 큼. 1MB 이상의 공간에 GDT 테이블을 생성. 10.3.2 GDT 테이블 생성과 TSS 세그먼트 디스크립터 추가 GDT 테이블과 GDT 정보를 나타내는 자료구조를 구조체로 작성. GDTR 자료구조의 시작 어드레스를 0x142000으로 설정하는 이유는 0x100000 영역부터 264KB를 페이지 테이블로 사용. 10.3.3 TSS 세그먼트 초기화void kInitializeTSSSegment(TSSEGMENT * pstTSS) { kMemSet(pstTSS, 0, sizeof(TSSDATA)); pstTSS -> qwIST[0] = 0x800000; pstTSS -> wIOMapBASEAddress = 0xFFFF; } I/O 맵을 사용하지 않으려면 TSS 세그먼트 디스크립터에서 설정한 Limit 필드 값보다 크게 설정. IST 필드의 0이 아닌 값으로 설정하고 핸들러가 사용할 스택 어드레스를 설정하면 사용 가능. 10.3.4 GDT 테이블 교체와 TSS 세그먼트 로드 kLoadGDTR: lgdt [rdi] ; GDTR 어드레스를 프로세서에 로드 ret kLoadTR: ltr di ; TSS 세그먼트 디스크립터의 오프셋을 프로세서에 설정해 TSS 세그먼트 로드 ret GDT는 LGDT를 사용해 갱신. TSS 세그먼트는 LTR 명령어를 사용하여 GDT 테이블 내의 TSS 세그먼트 인덱스를 지정. 10.4 IDT 테이블 생성, 인터럽트, 예외 핸들러 등록10.4.1 IDT 테이블 생성for(i = 0; i < 100; i ++) { kSetIDTEntry( &(pstEntry[i]), kDummyHandler, 0x08, IDT_FLAGS_IST1, IDT_FLAGS_KERNEL, IDT_TYPE_INTERRUPT) } void kDummyHandler(void) { kPrintString(0, 0, \"==================================\"); kPrintString(0, 1, \" Dummy Interrupt Handler Called \"); kPrintString(0, 2, \"==================================\"); } 앞서 IDTR 자료구조의 시작 어드레스는 이 전에 생성한 TSS 세그먼트 이후에 위차하게 0x1420A0을 설정. 인터럽트와 예외는 최대 100개까지 처리 가능하게 설정. 10.5 IDT, TSS 통합과 빌드10.5.1 디스크립터 파일 추가Descriptor.c 코드 보기Descriptor.h 코드 보기 10.5.2 어셈블리어 유틸리티 파일 수정수정된 AssemblyUtility.h 코드 보기수정된 AssemblyUtility.asm 코드 보기 10.5.3 유틸리티 파일 추가Utility.c 코드 보기Utility.h 코드 보기 10.5.4 C 언어 커널 엔트리 포인트 파일 수정수정된 main 코드 보기 10.5.5 빌드와 실행 마치며내일 코드 한번 다시 봐야겠다..끝","categories":[{"name":"project","slug":"project","permalink":"http://DongyeolLee.github.io/categories/project/"},{"name":"정리","slug":"project/정리","permalink":"http://DongyeolLee.github.io/categories/project/정리/"},{"name":"os","slug":"project/정리/os","permalink":"http://DongyeolLee.github.io/categories/project/정리/os/"}],"tags":[{"name":"os","slug":"os","permalink":"http://DongyeolLee.github.io/tags/os/"}]},{"title":"9. 키보드 디바이스 드라이버를 추가하자","slug":"OS/Project/AddKeyboardDriver","date":"2018-01-21T13:09:55.000Z","updated":"2019-04-30T07:24:41.164Z","comments":true,"path":"2018/01/21/OS/Project/AddKeyboardDriver/","link":"","permalink":"http://DongyeolLee.github.io/2018/01/21/OS/Project/AddKeyboardDriver/","excerpt":"","text":"들어가기키보드를 제어하는 방법에 대해서 알아보고 스캔 코드를 ASCII 코드로 변환해보자 본론9.1 키보드 컨트롤러의 구조와 기능9.1.1 키보드 컨트롤러, I/O 포트, 레지스터 할당된 포트는 두 개이지만 포트에서 데이터를 읽을 때와 쓸 때 접근하는 레지스터가 다름. 그중 상태 레지스터는 키보드 컨트롤러의 상태를 표시하는 레지스터. 9.2 키보드 컨트롤러 제어9.2.1 키보드와 키보드 컨트롤러 활성화 BIOS에 의해 키보드는 활성화된 상태이지만 만약을 대비해 직접 활성화. 키보드 컨트롤러에서 키보드 디바이스를 활성화하려면 커맨드(OxAE) 전송. 키보드 컨트롤러에서 키보드 데이터를 받을 준비가 된 것이므로 따로 키보드도 활성화 시킴. 입력 버퍼에 키보드로 보낼 커맨드를 직접 입력. 정상적으로 처리한 경우 응답(0xFA) 전송. 9.2.2 IA-32e 모드의 호출 규약 IA-32e 모드의 C 호출 규약과 보호 모드의 C 호출 규약을 비교하면 3가지 차이. 파라미터를 전달할 때 레지스터 우선 사용. 레지스터 또는 스택에 파라미터를 삽입하는 순서가 다름. 반환 값을 사용하는 레지스터의 차이. 9.2.3 키보드 컨트롤러에서 키 값 읽기 BYTE kGetKeyboardScanCode(void) { // 출력 버퍼에 데이터가 있을 때까지 대기. while(kIsOutBufferFull() == FALSE) { ; } // 출력 버퍼에서 키 값을 읽어서 반환. return kInPortByte(0x60); } 키보드의 키가 눌리거나 떨어질 때마가 키 별로 할당된 스캔 코드가 출력 버퍼에 쌓임. 상태 레지스터를 읽어서 출력 버퍼에 데이터를 확인한 후, 읽어서 저장. 9.2.4 A20 게이트 활성화와 프로세서 리셋 A20 게이트 비트와 프로세서 리셋 비트는 출력 포트의 비트를 변경하면서 적용. 출력 포트는 0xD0, 0xD1 커맨드로 접근. 프로세서를 리셋하는 방법은 출력 포트의 데이터를 0으로 설정. A20 게이트를 활성화하는 방법은 0xD0으로 데이터를 읽고 비트 1을 1로 설정 후, 0xD1으로 전달. 9.2.5 키보드 LED 상태 제어 키보드의 LED 상태를 변경하려면 입력 버퍼로 0xED 커맨드 전송해 LED 정보가 전송 될 것을 알림. ACK을 확인한 후, LED 상태 정보 전송. 9.3 스캔 코드와 간단한 쉘9.3.1 키보드와 스캔 코드 키보드의 모든 키는 각자의 고유 코드를 가지고 있으며, 키보드는 키가 눌리거나 떨어질 때마다 그 상태에 해당하는 키 값을 키보드 컨트롤러에 전달. 일반적으로 떨어졌을 때의 키 값은 눌러졌을 때의 값에 비트 7을 1로 설정한 것. 스캔 코드와 우리가 사용하는 ASCII 코드는 일치하지 않아 스캔 코드의 변경이 필요. 9.3.2 스캔 코드를 ASCII 문자로 변환 확장 키를 제외한 스캔 코드를 테이블을 사용해 변환. typedef struct kKeyMappingEntryStruct { // 조합되지 않은 일반 키. BYTE bNormalCode; // 조합된 키. BYTE bCombinedCode; } KEYMAPPINGENTRY 매핑 테이블을 만들기 전 엔트리 자료구조 정의. 9.4 키보드 디바이스 드라이버의 통합과 빌드9.4.1 키보드 디바이스 드라이버 파일 추가Keyboard.h 코드 보기Keyboard.c 코드 보기 9.4.2 어셈블리어 유틸리티 파일 추가AssemblyUtility.asm 코드 보기AssemblyUtility.h 코드 보기 9.4.3 C 언어 커널 엔트리 포인트 파일 수정C 언어 커널 코드 보기 9.4.4 빌드와 실행 마치며끝!","categories":[{"name":"project","slug":"project","permalink":"http://DongyeolLee.github.io/categories/project/"},{"name":"정리","slug":"project/정리","permalink":"http://DongyeolLee.github.io/categories/project/정리/"},{"name":"os","slug":"project/정리/os","permalink":"http://DongyeolLee.github.io/categories/project/정리/os/"}],"tags":[{"name":"os","slug":"os","permalink":"http://DongyeolLee.github.io/tags/os/"}]},{"title":"8. 64비트 모드로 전환하자","slug":"OS/Project/ConvertTo64bitMode","date":"2018-01-20T03:58:07.000Z","updated":"2019-04-30T07:24:41.165Z","comments":true,"path":"2018/01/20/OS/Project/ConvertTo64bitMode/","link":"","permalink":"http://DongyeolLee.github.io/2018/01/20/OS/Project/ConvertTo64bitMode/","excerpt":"","text":"들어가기64비트 모드로 전환하는데 필요한 페이징 기능 활성화와 IA-32e 모드 커널을 작성 본론8.1 프로세서의 제조사와 IA-32e 지원 여부 검사 프로세서마다 지원하는 기능이 조금씩 다름. 프로세서 제조사는 지원하는 기능을 확인할 수 있는 CPUID 명령어 제공. 8.1.1 CPUID를 사용하여 프로세서 정보 확인 방법 CPUID 명령어는 EAX에 설정된 값에 따라 해당 정보를 조회, 반환값은 EAX, EBX, ECX, EDX에 저장. 8.1.2 프로세서 제조사와 IA-32e 모드 지원 여부 확인[BITS 32] global kReadCPUID SECTION .text ; text 섹션(세그먼트)을 정의 ; CPUID를 반환 ; PARAM: DWORD dwEAX, DWORD* pdwEAX,* pdwEBX,* pdwECX,* pdwEDX kReadCPUID: push ebp ; 베이스 포인터 레지스터(BP)를 스택에 삽입 mov ebp, esp ; 베이스 포인터 레지스터(BP)에 스택 포인터 레지스터(SP)의 값을 설정 push eax ; 함수에서 임시로 사용하는 레지스터로 함수의 마지막 부분에서 push ebx ; 스택에 삽입된 값을 꺼내 원래 값으로 복원 push ecx push edx push esi ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; EAX 레지스터의 값으로 CPUID 명령어 실행 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; mov eax, dword [ ebp + 8 ] ; 파라미터 1(dwEAX)를 EAX 레지스터에 저장 cpuid ; CPUID 명령어 실행 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; 반환된 값을 파라미터에 저장 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; *pdwEAX mov esi, dword [ ebp + 12 ] ; 파라미터 2(pdwEAX)를 ESI 레지스터에 저장 mov dword [ esi ], eax ; pdwEAX가 포인터이므로 포인터가 가리키는 어드레스에 ; EAX 레지스터의 값을 저장 ; *pdwEBX mov esi, dword [ ebp + 16 ] ; 파라미터 3(pdwEBX)를 ESI 레지스터에 저장 mov dword [ esi ], ebx ; pdwEBX가 포인터이므로 포인터가 가리키는 어드레스에 ; EBX 레지스터의 값을 저장 ; *pdwECX mov esi, dword [ ebp + 20 ] ; 파라미터 4(pdwECX)를 ESI 레지스터에 저장 mov dword [ esi ], ecx ; pdwECX가 포인터이므로 포인터가 가리키는 어드레스에 ; ECX 레지스터의 값을 저장 ; *pdwEDX mov esi, dword [ ebp + 24 ] ; 파라미터 5(pdwEDX)를 ESI 레지스터에 저장 mov dword [ esi ], edx ; pdwEDX가 포인터이므로 포인터가 가리키는 어드레스에 ; EDX 레지스터의 값을 저장 pop esi ; 함수에서 사용이 끝난 ESI 레지스터부터 EBP 레지스터까지를 스택에 pop edx ; 삽입된 값을 이용해서 복원 pop ecx ; 스택은 가장 마지막에 들어간 데이터가 가장 먼저 나오는 pop ebx ; 자료구조(Last-In, First-Out)이므로 삽입(push)의 역순으로 pop eax ; 제거(pop) 해야 함 pop ebp ; 베이스 포인터 레지스터(BP) 복원 ret ; 함수를 호출한 다음 코드의 위치로 복귀 CPUID 명령어를 사용하려면 어셈블리어 코드로 직접 레지스터를 제어해야 함. CPUID 명령을 수행하는 함수가 외부에서도 실행 가능하도록 global 사용. 주의해서 볼 부분은 결과를 넘겨줄때 esi를 사용 -&gt; C 코드에서 넘어올 때 주소로 넘어옴. // 64 모드 지원 확인 kReadCPUID( 0x80000001, &dwEAX, &dwEBX, &dwECX, &dwEDX ); kPrintString( 0, 8, \"64bit Mode Support Check -------------------[ ]\" ); if( dwEDX & ( 1","categories":[{"name":"project","slug":"project","permalink":"http://DongyeolLee.github.io/categories/project/"},{"name":"정리","slug":"project/정리","permalink":"http://DongyeolLee.github.io/categories/project/정리/"},{"name":"os","slug":"project/정리/os","permalink":"http://DongyeolLee.github.io/categories/project/정리/os/"}],"tags":[{"name":"os","slug":"os","permalink":"http://DongyeolLee.github.io/tags/os/"}]},{"title":"7. 페이징 기능을 활성화하여 64비트 전환을 준비하자","slug":"OS/Project/ReadyFor64bitMode","date":"2018-01-19T01:35:35.000Z","updated":"2019-04-30T07:24:41.166Z","comments":true,"path":"2018/01/19/OS/Project/ReadyFor64bitMode/","link":"","permalink":"http://DongyeolLee.github.io/2018/01/19/OS/Project/ReadyFor64bitMode/","excerpt":"","text":"들어가기페이징 설정을 통한 64비트 모드로의 전환 준비! 본론7.1 선형 주소화 4단계 페이징 기법 페이징에 사용하는 각 테이블은 512(2^9)개의 엔트리로 구성, 다음 레벨에서 사용할 테이블의 기준 주소를 포함. 그림과 구현한 페이징의 차이점은 2MB 페이지를 만들 계획, 따라서 페이지 테이블 엔트리없이 페이지 디렉터리에서 바로 물리 주소. 선형 주소 역시 테이블 관련 9 비트 없이 20 비트를 오프셋으로 사용. 제작하는 OS를 실행하는데 필요한 페이지의 역할은 다음과 같음. 선형 주소롸 물리 주소를 1:1로 매핑. 2MB 페이지를 사용하려 최대 64GB의 물리 메모리 매핑. 물리 메모리 전체 영역에 대해 캐시를 활성화. 7.2 페이지 테이블 구성과 공간 할당7.2.1 64GB의 물리 메모리 관리를 위한 메모리 계산 페이지 디렉터리는 8 바이트 크기인 엔트리 512개로 구성, 각 엔트리는 2MB 페이지에 대한 정보 담음. 2MB * 512 = 1GB를 관리함. 페이지 디렉터리의 크기는 8 바이트 * 512 = 4KB. 64GB의 메모리 영역 관리를 위해서는 페이지 디렉터리 64개 필요, 크기는 64 * 4KB = 256KB. 페이지 디렉터리를 포인팅하는 페이지 디렉터리 포인터 테이블 역시 512개의 엔트리로 구성되며, 64개의 페이지 디렉터리를 관리하는데 1개면 충분. PML4 역시 8 바이트 크기로 1개면 충분. 64GB 물리 메모리를 매핑하는데 필요한 페이지 테이블 개수는 66개(264KB). 7.2.2 페이지 테이블을 위한 공간 할당 264KB나 되는 영역을 OS 이미지나 커널 어드레스 공간에 두는 것은 좋지 않음. 커널 이미지가 2MB에서 시작, 1MB ~ 2MB 사이에 저장. 7.2.3 공통 속성 필드 설정PCD 필드와 PWT 필드 속도 향상을 위해 캐시. 캐시 정책으로 Write-Through &amp; Write-Back 방식이 있으며, Write-Back 방식이 더 효과적. PCD = 0, PWT = 0. U/S 필드와 R/W 필드 유저 레벨과 커널 레벨의 구분이 필요. 하지만 현재는 따로 구분하지 않고(유저 레벨 어플리케이션이 아직 없기 때문에) 모두 읽기/쓰기 가능하게 설정. U/S = 0, R/W = 1. EXB 필드, A 필드, P 필드, Avail 필드 페이징 기능외에 다른 기능은 사용하지 않을 예정. EXB = 0. 특정 페이지에 접근 했는지 여부 파악도 X. A = 0. 테이블을 임의의 용도로 사용하지 않음. Avail = 0. 해당 엔트리가 유효하다는 것을 나타내야 함. P = 1. 7.2.4 페이지 디렉터리 엔트리용 속성 필드 설정PAT 필드, G 필드, D 필드 페이지 별로 특수한 옵션을 지정하지 않음. PAT = 0. 페이지 테이블 고정되어 있음. G = 0. A 필드와 마찬가지로 사용하지 않음. D = 0. 7.3 페이지 테이블 생성과 페이징 기능 활성화7.3.1 페이지 엔트리를 위한 자료구조 정의와 매크로 정의 typedef struct kPageTableEntryStruct{ // PML4T와 PDPTE의 경우 // 1 비트 P, RW, US, PWT, PCD, A, 3 비트 Reserved, 3 비트 Avail, // 20 비트 Base Address // PDE의 경우 // 1 비트 P, RW, US, PWT, PCD, A, D, 1, G, 3 비트 Avail, 1 비트 PAT, 8 비트 Avail, // 11 비트 Base Address DWORD dwAttributeAndLowerBaseAddress; // 8 비트 Upper BaseAddress, 12 비트 Reserved, 11 비트 Avail, 1 비트 EXB DWORD dwUpperBaseAddressAndEXB; } PML4TENTRY, PDPTENTRY, PDENTRY, PTENTRY; 세 종류의 페이지 엔트리는 내부 필드가 거의 유사, 개별적으로 정의하지 않고 형태만 정의. #define PAGE_FLAGS_P 0x00000001 // Present #define PAGE_FLAGS_RW 0x00000002 // Read/Write #define PAGE_FLAGS_US 0x00000004 // User/Supervisor(플래그 설정 시 유저 레벨) #define PAGE_FLAGS_PWT 0x00000008 // Page Level Write-through #define PAGE_FLAGS_PCD 0x00000010 // Page Level Cache Disable #define PAGE_FLAGS_A 0x00000020 // Accessed #define PAGE_FLAGS_D 0x00000040 // Dirty #define PAGE_FLAGS_PS 0x00000080 // Page Size #define PAGE_FLAGS_G 0x00000100 // Global #define PAGE_FLAGS_PAT 0x00001000 // Page Attribute Table Index // 상위 32비트 용 속성 필드 #define PAGE_FLAGS_EXB 0x80000000 // Execute Disable 비트 // 아래는 편의를 위해 정의한 플래그 #define PAGE_FLAGS_DEFAULT ( PAGE_FLAGS_P | PAGE_FLAGS_RW ) // 기타 페이징 관련 #define PAGE_TABLESIZE 0x1000 #define PAGE_MAXENTRYCOUNT 512 #define PAGE_DEFAULTSIZE 0x200000 속성 필드 정의. 7.3.2 페이지 엔트리 생성과 페이지 테이블 생성 /** * 페이지 엔트리에 기준 주소와 속성 플래그를 설정 **/ void kSetPageEntryData( PTENTRY* pstEntry, DWORD dwUpperBaseAddress, DWORD dwLowerBaseAddress, DWORD dwLowerFlags, DWORD dwUpperFlags ) { pstEntry->dwAttributeAndLowerBaseAddress = dwLowerBaseAddress | dwLowerFlags; pstEntry->dwUpperBaseAddressAndEXB = ( dwUpperBaseAddress & 0xFF ) | dwUpperFlags; } /** * IA-32e 모드 커널을 위한 페이지 테이블 생성 **/ void kInitializePageTables( void ) { PML4TENTRY* pstPML4TEntry; // PML4 테이블 생성 // 첫 번째 엔트리 외에 나머지는 모두 0으로 초기화 pstPML4TEntry = ( PML4TENTRY* ) 0x100000; // 페이지 엔트리를 유저 레벨로 설정하여 유저 레벨에서 접근 가능하도록 설정 kSetPageEntryData( &( pstPML4TEntry[ 0 ] ), 0x00, 0x101000, PAGE_FLAGS_DEFAULT, 0 ); for( i = 1 ; i < PAGE_MAXENTRYCOUNT ; i++ ) { kSetPageEntryData( &( pstPML4TEntry[ i ] ), 0, 0, 0, 0 ); } } 아직 보호 모드이므로 64비트 어드레스를 상위 32비트와 하위 32 비트로 나눔. 어드레스를 계산할 때도 동일하게 적용. dwUpperBaseAddress의 값이 dwLowerBaseAddress의 값이 4GB를 넘을 때마다 증가. 어드레스 계산 도중 범위를 초과하면 안됨. 7.3.3 프로세서의 페이징 기능 활성화 CR0의 PG 비트 CR3 레지스터, CR4의 PAE 비트를 1로 설정. PG 비트를 1로 설정하는 순간 체이징 기능이 활성화되므로, 그 전에 미리 CR3 레지스터에 PML4 테이블의 어드레스를 설정. CR4 레지스터의 PAE 비트와 페이지 디렉터리 엔트리의 PS 비트를 1로 설정함으로써 IA-32e 모드 페이징 설정. ; PAE 비트를 1로 설정 mov eax, cr4 or eax, 0x20 mov cr4, eax ;PML4 테이블의 어드레시와 캐시 활성화 mov eax, 0x100000 mov cr3, eax ;페이징 기능 활성화 mov eax, cr0 or eax, 80000000 mov cr0, eax 현재는 보호 모드이므로 해당 코드로 페이징을 활성화하는 것은 IA-32e에서 사용. 7.4 보호 모드 커널에 페이지 테이블 생성 기능 추가7.4.1 페이징 기능 관련 파일 생성page.h 코드 보기page.c 코드 보기 PML4(0x100000 ~ 101000) -&gt; 페이지 디렉터리 포인터 테이블(0x101000 ~ 102000) -&gt; 페이지 디렉터리(0x102000 ~ 142000) 7.4.2 C 커널 엔트리 포인트 수정32비트 커널 코드 보기 7.5 빌드와 수행 마치며끝!","categories":[{"name":"project","slug":"project","permalink":"http://DongyeolLee.github.io/categories/project/"},{"name":"정리","slug":"project/정리","permalink":"http://DongyeolLee.github.io/categories/project/정리/"},{"name":"os","slug":"project/정리/os","permalink":"http://DongyeolLee.github.io/categories/project/정리/os/"}],"tags":[{"name":"os","slug":"os","permalink":"http://DongyeolLee.github.io/tags/os/"}]},{"title":"6. A20 게이트를 활성화하여 1MB이상 영역에 접근해보자","slug":"OS/Project/A20GateActivation","date":"2018-01-17T08:15:18.000Z","updated":"2019-04-30T07:24:41.163Z","comments":true,"path":"2018/01/17/OS/Project/A20GateActivation/","link":"","permalink":"http://DongyeolLee.github.io/2018/01/17/OS/Project/A20GateActivation/","excerpt":"","text":"들어가기A20 게이트에 대해 공부 해보자. 본론6.1 IA-32e 모드 커널과 메모리 맵 1MB(0x100000) 이하의 공간은 IA-32e 모드 커널의 공간으로 활용하기에는 부족. IA-32e 모드 커널을 2MB ~ 6MB까지 위치 시킬 예정. 6.2 IA-32e 모드 커널을 위한 메모리 초기화6.2.1 메모리 초기화 기능 추가BOOL kIntializeKernel64Area() { DWORD* pdwCurrentAddress; // 초기화을 시작할 어드레스 0x100000(1MB)을 설정 pdwCurrentAddress = (DWORD*) 0x100000; // 마지막 어드레스인 0x600000까지 루프를 돌면서 4바이트씩 0으로 채움 while( ( DWORD ) pdwCurrentAddress < 0x600000 ) { *pdwCurrentAddress = 0x00; // 0으로 저장한 후 다시 읽었을 때 0이 나오지 않으면 해당 어드레스를 // 사용하는데 문제가 생긴것으로 종료 if ( *pdwCurrentAddress != 0) { return FALSE; } // 다음 주소로 이동 pdwCurrentAddress++; } return TRUE; } 메모리 영역 1MB ~ 6MB까지 0으로 초기화. 6.2.2 빌드와 실행 0으로 초기화 이후 문자열을 찍어 확인 -&gt; 정상작동. 하지만 PC에 따라 정상작동 안할 가능성도 있음. 하위 호환성을 유지하기 위해 어드레스 라인을 비활성화했기 때문. 6.3 1MB 어드레스와 A20 게이트6.3.1 A20 게이트의 의미와 용도 초창기 XT PC는 최대 1MB까지 접근 가능했기 때문에 1MB가 넘는 어드레스는 하위 어드레스만 남음. 이후 16MB까지 접근 가능한 AC PC가 탄생하면서 XT PC용 프로그램을 AC PC에서 실행하면서 문제 발생. 이런 호완성의 문제 해결을 위해 A20게이트를 만듬. A20 게이트에서 A20의 의미는 어드레스의 20번째 비트를 의미하며 해당 비트가 비활성되면 어드레스 라인의 20번째(1MB)가 항상 0으로 고정. 0x10FFEF가 되더라도 0xFFEF로 처리 6.3.2 A20 게이트 활성화 방법 A20 게이트를 활성화하는 방법은 크게 세 가지. 키보드 컨트롤러 시스템 컨트롤 포트 BIOS 서비스 키보드 컨트롤러를 사용하면 속도가 느리고 복잡하지만 PS/2 방식의 키보드/마우스를 지원하는 PC라면 어디서나 사용 가능. 시스템 컨트롤 포트는 키보드 컨트롤러를 통하는 방법보다 속도가 빠르고 간략함. 가장 확실한 방법은 BIOS 서비스를 사용하는 방법. 시스텀 컨트롤 포트와 BIOS 서비스를 사용해 A20 게이트를 활성화 해볼 예정. 시스템 컨트롤 포트로 A20 게이트 활성화하기 in al, 0x92 ; 시스템 컨트롤 포트(0x92)에서 1 바이트를 읽어 레지스터에 저장 or al, 0x02 ; 읽은 값에 A20 게이트 비트(활성화는 비트 1이 1)를 1로 설정 and al, 0xFE ; 시스템 리셋 방지를 위한 0xFE와 AND 연산하여 비트 0를 0으로 설정 out 0x92, al 시스템 컨트롤 포트는 I/O 포트 어드레스의 0x92에 위치. BIOS 서비스로 A20 게이트 활성화 방법 mov ax, 0x2401 ; A20 게이트 활성화 서비스 설정 int 0x15 ; BIOS interrupt 호출 시스템 컨트롤 포트를 사용하는 것 보다 훨씬 간편. 인터럽트 벡트 0x15 호출. 6.4 A20 게이트 적용과 메모리 크기 검사6.4.1 A20 게이트 활성화 코드 적용 한 가지 방법만 사용해도 되지만 여러 가능성을 대비해 두 가지 방법을 모두 사용. 믿을 만한 BIOS를 먼저 실행하고 실패하면 시스템 컨트롤 포트 사용. A20 게이트 활성화 반영된 코드 보기 6.4.2 메모리 크기 검사 기능 추가 사용 가능한 메모리를 검사하는 가장 확실한 방법은 메모리의 특정 값을 쓰고 다시 읽어 같은 값을 확인. 어드레스가 진짜 물리 메모리라면 쓴 값이 그대로 출력, 진짜 물리 메모리가 아니라면 임의의 값이 출력. 이런 특징을 활용해 메모리 크기 계산 가능. 검사 방법은 1MB 단위로 어드레스를 증가시키면서 각 MB의 첫 번째 4바이트에 0x12345678을 쓰고 읽음. 메모리 크기 검사 코드 반영된 코드 보기 6.4.3 빌드와 실행 메모리 영역을 임의로 작게해서 테스트 결과 정상 작동. 마치며이번 챕터는 그나마 이해가 갔다…","categories":[{"name":"project","slug":"project","permalink":"http://DongyeolLee.github.io/categories/project/"},{"name":"정리","slug":"project/정리","permalink":"http://DongyeolLee.github.io/categories/project/정리/"},{"name":"os","slug":"project/정리/os","permalink":"http://DongyeolLee.github.io/categories/project/정리/os/"}],"tags":[{"name":"os","slug":"os","permalink":"http://DongyeolLee.github.io/tags/os/"}]},{"title":"5. C언어로 커널을 작성하자","slug":"OS/Project/MakingKernelWithC","date":"2018-01-15T05:54:45.000Z","updated":"2019-04-30T07:24:41.165Z","comments":true,"path":"2018/01/15/OS/Project/MakingKernelWithC/","link":"","permalink":"http://DongyeolLee.github.io/2018/01/15/OS/Project/MakingKernelWithC/","excerpt":"","text":"들어가기빌드 시 자동으로 TOTALSECTORCOUNT 값을 업데이트하여 작업 환경을 개선하고, C를 어셈블리어 코드와 연결해 함께 빌드 해보자. 본론5.1 실행 가능한 C 코드 커널 생성 방법 이번 장에서는 C 소스 파일을 추가하고 이를 빌드해 보호 모드 커널 이미지에 통합. 5.1.1 빌드 조건과 제약 사항 엔트리 포인트가 C 코드를 실행하려면 세 가지 제약 조건을 만족해야 함. C 라이브러리를 사용하지 않게 빌드 보호 모드 커널이 실행되면 C 라이브러리가 존재 하지 않음. 0x10200 위치에서 실행하게끔 빌드. 0x10000에는 엔트리 포인트가 존재하므로 512바이트 이후인 0x10200에 로딩. 코드나 데이터 외에 기타 정보를 포함하지 않은 순수한 바이너리 파일 형태. GCC를 통해 실행 파일을 생성하면 ELF 또는 PE 파일 포맷과 같이 특정 OS에서 실행할 수 있는 포맷이 생성되고 해당 포맷들 불필요한 정보를 포함. 5.1.2 소스 파일 컴파일 - 라이브러리를 사용하지 않는 오브젝트 파일 생성 방법x_64-pc-linux-gcc -c -m32 -ffreestanding Main.c C 코드를 컴파일 해 오브젝트 파일을 생성하는 방법은 간단. -ffreestading 옵션으로 라이브러리를 사용하지 않고 오브젝트 파일을 생성. 5.1.3 오브젝트 파일 링크 - 라이브러리를 사용하지 않고 특정 어드레스에서 실행 가능한 커널 이미지 파일 생성 방법 실행 파일이 링크될 때 코드나 데이터 이외에 디버깅 관련 정보와 심볼릭 정보들이 포함 -&gt; 재배치 필요. 섹션 배치와 링커 스크립트, 라이브러리를 사용하지 않는 링크 섹션은 실행 파일 또는 오브젝트 파일에 있으며 공통된 속성(코드, 데이터 등)을 담는 영역. 무수히 많은 섹션 중 핵심 역할을 하는 섹션 세 가지. 실행 가능한 코드가 들어 있는 .text 섹션. 초기화 된 데이터가 들어 있는 .data 섹션. 초기화 되지 않은 데이터가 있는 .bss 섹션. 오브젝트 파일은 중간 단계이기 때문에 다른 오브젝트와 합쳐지는 여부에 따라 주소가 언제든지 변할수 있으므로 각 섹션의 크기와 파일 내에 있는 오프셋 정보만 저장. 오브젝트 파일을 결합하고 실제 메모리에 로딩될 위치를 결정하는 것이 링커. 링커의 주 역할은 오브젝트 파일을 모아 섹션을 통합하고 어드레스 조정. 링커가 실행 파일을 만들기 위해 파일 구성에 대한 정보가 필요 -&gt; 링커 스크립트. OUTPUT_FORMAT(\"elf32-i386\", \"elf32-i386\", elf32-i386) OUTPUT_ARCH(i386) ENTRY(_start) SEARCH_DIR(\"/usr/cross/x86_64-pc-linux/lib\") SECTION { PROVIDE (__executable_start = 0x8048000); = 0x8048000 + SIZEOF_HEADERS; --- 생략 --- .text { --- 생략 --- } .data { --- 생략 --- } .bss { --- 생략 --- } } 세부적인 내용까지는 알수 없지만 .text, .data, .text를 확인. 코드 및 데이터에 관련된 섹션을 앞으로 이동.재배치된 소스 보기 로딩할 메모리 어드레스와 엔트리 포인트 지정 어셈블리어로 작성된 부트 로더나 보호 모드 엔트리 포인트처럼 C 코드 역시 로딩될 메모리를 미리 예측하고 이미지를 생성해야 함. 메모리에 로딩하는 어드레스를 지정하는 방법. 링커 스크립트를 수정. .text 섹션을 수정. 그 이후의 .data 나 .bss는 자동으로 계산된 주소가 적용. 프로그램 명령줄 옵션 사용. 소스 파일 내의 함수 위치와 오브젝트 파일의 순서를 변경해 엔트리 포인트로 지정. 실행 파일을 바이너리로 변환 x_64-pc-linux-objcopy -j .text -j .data -j .rotate -j .bss -S -O binary kernel32.elf kernel32.bin 실행 파일은 코드 섹션과 데이터 섹션 이외의 정보를 포함하므로 이를 제거해야함 -&gt; objcopy 사용. 5.2 C 소스 파일 추가와 보호 모드 엔트리 포인트 통합5.2.1 C 소스 파일 추가보호 모드 커널용 공용 헤더 보기 보호 모드 전반에 걸쳐 사용할 헤더 파일. CHARACTER는 텍스트 모드 화면을 구성하는 문자 하나. C 코드 엔트리 포인트 파일 Main 함수는 C 코드의 엔트리 포인트 함수로서 0x10200 어드레스에 위치. 5.2.2 보호 모드 엔트리 포인트 코드 수정[BITS 32] PROTECTEDMODE: --- 생략 --- push (switch SWITCHSUCCESSMESSAGE - $$ + 0x10000) push (2) push (0) call PRINTMESSAGE // 10200으로 이동 jmp dword 0x08: 0x10200 앞서 작성했던 보호 모드 커널의 엔트리 포인트 코드(EntryPoint.s)를 변경. 보호 모드 커널 엔트리 포인트 이후에 무한 루프 대신 0x10200으로 이동. 5.2.3 makefile 수정 이후 다수의 파일을 컴파일 해야하므로 makefile을 보다 편리하게 수정해야 함. CSOURCEFILES = $(wildcard Source/*.c) 특정 파일 밑에 확정자를 검색. %.o : %.c gcc -c $< 파일 패턴을 활용한 빌드룰을 적용. COBJECTFILES = $(patsubst %.c, %.o, $(CSOURCEFILES)) 소스 파일 목록에 포함된 파일의 확장자를 .c에서 .o로 수정. CENTRYPOINTOBJECTFILE = Main.o COBJECTFILES = $(patsubst %.c, %.o, $(CSOURCEFILES)) COTHEROBJECTFILES = $(subst Main.o, , $(COBJECTFILE)) kernel32.elf: $(CENTRYPOINTOBJECTFILE) $(COBJECTFILES) - Main.o가 가장 앞 x86_64-pc-linux-ld -o $@ $^ 보호 모드 커널 makefile 코드 보기 커널 디렉터리는 소스 디렉터리와 임시 디렉터리로 구분되며 커널 빌드 작업은 임시 디렉터리를 기준을 수행. 5.3 커널 빌드와 실행 소스를 빌드해 보면 커널 이미지가 약 650바이트 정도로 2섹터에 못 미치기 때문에 마지막 섹터를 로딩하는데 문제 발생. 모자란 부분을 0x00과 같은 임의의 값으로 채워주면 문제 해결. 5.3.1 이미지 메이커 프로그램 작성all : ImageMaker.exe ImageMake.exe : ImageMaker.c gcc -o $@ $","categories":[{"name":"project","slug":"project","permalink":"http://DongyeolLee.github.io/categories/project/"},{"name":"정리","slug":"project/정리","permalink":"http://DongyeolLee.github.io/categories/project/정리/"},{"name":"os","slug":"project/정리/os","permalink":"http://DongyeolLee.github.io/categories/project/정리/os/"}],"tags":[{"name":"os","slug":"os","permalink":"http://DongyeolLee.github.io/tags/os/"}]},{"title":"4. 32비트 보호 모드로 전환하자","slug":"OS/Project/ConvertTo32bitProtectMode","date":"2018-01-12T18:24:23.000Z","updated":"2019-04-30T07:24:41.165Z","comments":true,"path":"2018/01/13/OS/Project/ConvertTo32bitProtectMode/","link":"","permalink":"http://DongyeolLee.github.io/2018/01/13/OS/Project/ConvertTo32bitProtectMode/","excerpt":"","text":"들어가기리얼 모드에서 보호 모드로 전환하고, 메세지를 출력해 보호 모드임을 확인해보자!! 본론 간략하게 표시된 리얼모드에서 보호모드 전환 과정. 4.1 세그먼트 디스크립터 생성 세그먼트 디스크립터는 세그먼테이션 기법에서 세그먼트의 정보를 나타내는 자료구조. 세그먼트 디스크립터는 크게 코드 세그먼트 디스크립터와 데이터 세그먼트 디스크립터로 나뉨. 코드 세그먼트 디스크립터, 실행 가능한 코드가 포함된 세그먼트 정보로 CS 세그먼트 셀렉터 사용. 데이터 세그먼트 디스크립터, 데이터가 포함된 세그먼트에 대한 정보로 CS 제외한 나머지 세그먼트 셀렉터 사용. 세그먼트 레지스터 명칭은 보호 모드에서 세그먼트 셀렉터라는 이름으로 명칭 보호 모드의 세그먼트 디스크립터는 8 바이트로 다양한 필드가 존재. 복잡한 필드로 어떻게 설정할지는 목표로 하는 프로젝트를 먼저 정리하고 설정. 커널 코드와 데이터용 디스크립터 각 1개. 모든 디스크립터는 0 ~ 4GB까지 접근. 코드와 데이터 사용할 기본 오퍼랜드 크기는 32비트. 보호 기능은 사용하지 않으며, 프로세서의 명령을 사용하는데 제약 없음. 4.1.1 코드 세그먼트 디스크립터와 데이터 세그먼트 디스크립터 타입 설정 코드와 데이터 세그먼트를 설정하려면 S 필드와 타입 필드를 조합. S 필드는 세그먼트 디스크립터를 설정함으로 값을 1로 설정. 타입 필드는 4 비트의 필드를 이용해서 설정. 프로젝트를 진행하면서 기본 세그먼트 타입만 사용하고, 코드 세그먼트는 실행/읽기, 데이터 세그먼트는 읽기/쓰기 타입으로 설정. (코드 : 0x0A, 데이터 : 0x02) 4.1.2 세그먼트의 영역 설정 이번 프로젝트의 커널 세그먼트 디스크립터는 4GB 전체 영역에 접근. 따라서 커널 세그먼트 디스크립터의 기준 주소를 0으로 설정. 크기 필드는 총 20 비트, 2^20(1MB)는 4GB까지 표현 불가능. G 필드의 값을 1로 설정해 4GB로 확장. 4.1.3 기본 오퍼랜드 크기와 권한 설정 보호 모드는 32 비트로 동작하므로 기본 오퍼랜드의 크기도 32 비트로 설정. D/B 필드의 값을 1로 설정. 보호 모드는 권한을 따로 구분하지 않으므로 0으로 설정. 4.1.4 기타 필드 설정 디스크립터의 유요함을 나타내는 P 필드를 1로 설정. AVL 필드는 이번 프로젝트에서는 사용하지 않을 예정으로 0으로 설정. 4.1.5 세그먼트 디스크립터 생성 코드 CODEDESCRIPTOR : dw 0xFFFF ; Limit [15:0] dw 0x0000 ; Base [15:0] db 0x00 ; Base [23:16] db 0x9A ; P=1, DPL=0, Code Segment, Execute/Read db 0xCF ; G=1, D=1, L=0, Limit[19:16] db 0x00 ; Base [31:24] DATADESCRIPTOR : dw 0xFFFF ; Limit [15:0] dw 0x0000 ; Base [15:0] db 0x00 ; Base [23:16] db 0x92 ; P=1, DPL=0, Data Segment, Read/Write db 0xCF ; G=1, D=1, L=0, Limit[19:16] db 0x00 ; Base [31:24] 코드와 표를 비교하면서 이해. 4.2 GDT 생성 GDT는 연속된 디스크립터의 집합이므로 연속된 어셈블리어 코드로 나타내면 그 자체가 GDT. 하지만 한가지 제약은 NULL 디스크립터를 가장 앞부분에 추가. GDT는 프로세서에 GDT의 시작 주소와 크기 정보를 로딩해야 함. 따라서 이것을 저장하는 자료구조가 필요. GDT 정보를 저장하는 자료구조의 기준 주소는 데이터 세그먼트의 기준 주소와 관계 없이 어드레스 0을 기준으로 하는 선형 주소. GDT의 실제 주소를 변환 해야함. 부트 로더의 의해 0x10000에 로딩되어 실행 되고 있으므로 자료구조를 생성할때 GDT 오프셋 + 0x10000. ; GDTR 자료구조 정의 GDTR: dw GDTEND - GDT - 1 ; 아래 위치하는 GDT 테이블의 전체 크기 dd ( GDT - $$ + 0x10000 ) ; 아래에 위치하는 GDT 테이블의 시작 어드레스 ; 실제 GDT가 있는 선형 주소 계산을 위해 ; 현재 섹션 내의 GDT 오프셋에 세그먼트 기준 주소인 0x10000을 더함 ;GDT 테이블 정의 GDT: ; 널 디스크립터, 반드시 0으로 초기화 해야함 NULLDescriptor: dw 0x0000 dw 0x0000 db 0x00 db 0x00 db 0x00 db 0x00 ; ~~ 생략 ~~ ; 보호 모드 커널용 데이터 세그먼트 디스크립터 DATADESCRIPTOR: dw 0xFFFF ; Limit [15:0] dw 0x0000 ; Base [15:0] db 0x00 ; Base [23:16] db 0x92 ; P=1, DPL=0, Data Segment, Read/Write db 0xCF ; G=1, D=1, L=0, Limit[19:16] db 0x00 ; Base [31:24] GDTEND: 즉, GDT 정보를 저장하는 자료구조의 기준 주소는 GDT가 섹션(SECTION)에서 어느 정도 떨어져 있는지 저장. 따라서 GDT - $$으로 GDT 오프셋을 구함. 4.3 보호 모드로 전환 보호모드로 넘어가려면 간단하게 GDTR 설정, CR0 컨트롤 레지스터 설정, jmp 명령 수행 3단계만 수행하면 가능. 4.3.1 프로세서와 GDT 정보 설정lgdt (GDTR) 프로세서에 GDT 정보 생성을 위함 lgdt 명령어 사용. lgdt 명령으로 2 바이트의 크기와 4 바이트의 기준 주소로 된 GDT 정보 자료구조를 오퍼랜드로 받음. 4.3.2 CR0 컨트롤 레지스터 설정 CR0 컨트롤 레지스터에는 보호 모드 전환 필드 외에 다양한 필드 포함. 하지만 이번 보호 모드에서의 CR0는 세그먼테이션 기능 외에는 사용하지 않을 예정. 4.3.3 보호 모드로 전환과 세그먼트 셀렉터 초기화; 커널 코드 세그먼트를 0x00을 기준으로 하는 것으로 교체하고 EIP의 값을 0x00을 기준으로 재설정 ; CS 세그먼트 셀렉터 : EIP jmp dword 0x08: ( PROTECTEDMODE - $$ + 0x10000 ) ; 커널 코드 세그먼트가 0x00을 기준으로 하는 반명 실제 코드는 0x10000을 기준으로 실행되고 있으므로 ; 오프셋에 0x10000을 더해 세그먼트 교체 후에도 같은 선형 주소를 가리키게 함 [BITS 32] ; 이하의 코드는 32비트 코드로 설정 PROTECTEDMODE: mov ax, 0x10 ; 보호 모드 커널용 데이터 세그먼트 디스크립터를 AX 레지스터에 저장 mov ds, ax ; DS 세그먼트 셀렉터에 설정 mov es, ax ; ES 세그먼트 셀렉터에 설정 mov fs, ax ; FS 세그먼트 셀렉터에 설정 mov gs, ax ; GS 세그먼트 셀렉터에 설정 ; 스택을 0x00000000 ~ 0x0000FFFF 영역에 64KB 크기로 생성 mov ss, ax ; SS 세그먼트 셀렉터에 설정 mov esp, 0xFFFE ; ESP 레지스터의 어드레스를 0xFFFE로 설정 mov ebp, 0xFFFE ; EBP 레지스터의 어드레스를 0xFFFE로 설정 32비트 코드를 준비한 후, 어셈블리어 코드로 CS 세그먼트 셀렉터의 값을 바꿈. CS 세그먼트 셀렉터 교체를 위한 jmp 명령과 세그먼트 레지스터 접두사를 사용. 리얼 모드의 세그먼트 레지스터는 세그먼트의 시작 주소를 저장. 보호 모드의 세그먼트 디스크립터는 다양한 정보를 포함하고 있으므로 세그먼트 셀렉터(레지스터)는 세그먼트의 시작 주소가 아닌 해당 디스크립터의 주소를 저장. 디스크립터의 주소는 보호 모드로 변환하면서 GDT 내의 오프셋으로 접근.(즉, 보호 모드로 변환하면서 세그먼트 셀렉터의 기준 값이 GDT의 시작 주소가 되는 것) 4.3.4 보호 모드용 PRINTSTRING 함수; 메시지를 출력하는 함수 ; PARAM: x좌표, y좌표, 문자열 PRINTMESSAGE: push ebp ; 베이스 포인터 레지스터(EBP)를 스택에 삽입 mov ebp, esp; 베이스 포인터 레지스터(EBP)에 스택 포인터 레지스터(ESP)의 값을 설정 ; 베이스 포인터 레지스터(EBP)를 이용해서 파라미터에 접근할 목적 ; 호출된 직후의 ESP 레지스터 값을 저장하여 BP 레지스터와 고정된 오프셋으로 파라미터에 접근하게함 push esi ; ES 세그먼트 레지스터부터 DX 레지스터까지 스택에 삽입 push edi ; 함수에서 임시로 사용하는 레지스터로 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 원래 값으로 복원 push eax push ecx push edx ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; X, Y의 좌표로 비디오 메모리의 어드레스를 계산함 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; Y 좌표를 이용해서 먼저 라인 어드레스를 구함 mov eax, dword [ ebp + 12 ] ; 파라미터 2(Y좌표)를 EAX 레지스터에 설정 mov esi, 160 ; 한 라인의 바이트 수(2 * 80 컬럼)를 ESI 레지스터에 설정 mul esi ; EAX 레지스터와 ESI 레지스터를 곱하여 화면 Y어드레스 계산 mov edi, eax ; 계산된 화면 Y 어드레스를 EDI 레지스터에 설정 ; X 좌표를 이용해서 2를 곱한 후 최종 어드레스를 구함 mov eax, dword [ ebp + 8 ] ; 파라미터 1(X좌표)를 EAX 레지스터에 설정 mov esi, 2 ; 한 문자를 나타내는 바이트수(2)를 ESI 레지스터에 설정 mul esi ; EAX 레지스터와 ESI 레지스터를 곱하여 화면 X 어드레스를 계산 add edi, eax ; 화면 Y 어드레스와 계산된 X 어드레스를 더해서 실제 비디오 메모리 어드레스를 계산 ; 출력할 문자열의 어드레스 mov esi, dword [ ebp + 16 ] ; 파라미터 3(출력할 문자열의 어드레스) .MESSAGELOOP: ; 메시지를 출력하는 루프 mov cl, byte [ esi ] ; ESI 레지스터가 가리키는 문자열 위치에서 한 문자를 CL 레지스터에 복사 ; CL 레지스터는 ECX 레지스터의 하위 1바이트를 의미 ; 문자열은 1바이트면 충분하므로 ECX 레지스터의 하위 1바이트만 사용 cmp cl, 0 ; 복사된 문자와 0을 비교 je .MESSAGEEND ; 복사한 문자의 값이 0이면 문자열이 종료되었음을 의미하므로 .MESSAGEEND로 이동하여 문자 출력 종료 mov byte [ edi + 0x0B8000 ], cl ; 0이 아니라면 메모리 어드레스 0xB8000:EDI에 문자를 출력 add esi, 1 ; ESI 레지스터에 1을 더하여 다음 문자열로 이동 add edi, 2 ; EDI 레지스터에 2를 더하여 비디오 메모리의 다음 문자 위치로 이동 ; 비디오 메모리는 (문자, 속성)의 쌍으로 구성되므로 문자만 출력하려면 2를 더해야함 jmp .MESSAGELOOP ; 메시지 출력 루프로 이동하여 다음 문자를 출력 .MESSAGEEND: pop edx ; 함수에서 사용이 끝난 EDX 레지스터부터 EBP 레지스터까지를 스택에 삽입된 값을 이용해서 복원 pop ecx ; 스택은 가장 마지막에 들어간 데이터가 먼저나오는 자료구조이므로 삽입의 역순으로 제거해야한다 pop eax pop edi pop esi pop ebp ; 베이트 포인터 레지스터(EBP) 복원 ret ; 함수를 호출한 다음 코드의 위치로 복귀 리얼 모드용 함수를 보호 모드로 변환 하는 것은 스택의 크기가 2 바이트에서 4 바이트로 증가하며, 범용 레지스터의 크기가 4 바이트라는 정도만 알면 쉽게 교체. 3. 플로피 디스크에서 OS 이미지를 로딩하자에서의 PRINTSTRING와 비교. 범용 레지스터가 수정되고 스택의 크기 변경으로 인한 오프셋 변경. 보호 모드는 주소 접근 범위가 4GB로 넓어져 ES 세그먼트가 사라짐. 4.4 보호 모드용 커널 이미지 빌드와 가상 OS 이미지 교체4.4.1 커널 엔트리 포인트 파일 생성EntryPoint.s 코드 보기 EntryPoint.s는 외부(부트 로더)에서 보호 모드 커널로 진입하는 부분. 4.4.2 makefile 수정과 가상 OS 이미지 파일 교체all: Kernel32.bin Kernel32.bin: Source/EntryPoint.s nasm -o Kernel32.bin $","categories":[{"name":"project","slug":"project","permalink":"http://DongyeolLee.github.io/categories/project/"},{"name":"정리","slug":"project/정리","permalink":"http://DongyeolLee.github.io/categories/project/정리/"},{"name":"os","slug":"project/정리/os","permalink":"http://DongyeolLee.github.io/categories/project/정리/os/"}],"tags":[{"name":"os","slug":"os","permalink":"http://DongyeolLee.github.io/tags/os/"}]},{"title":"3. 플로피 디스크에서 OS 이미지를 로딩하자","slug":"OS/Project/OS-imageLoading","date":"2018-01-11T06:48:24.000Z","updated":"2019-04-30T07:24:41.165Z","comments":true,"path":"2018/01/11/OS/Project/OS-imageLoading/","link":"","permalink":"http://DongyeolLee.github.io/2018/01/11/OS/Project/OS-imageLoading/","excerpt":"","text":"들어가기기본 부트로더에서 OS 이미지를 로딩하는 기능을 추가하고 테스트용 OS 이미지를 로드해보자. 본론 부트 로더를 사용해 OS 이미지를 로딩하는 방법으로 BIOS 사용하는 방법과 디스크 컨트롤러를 사용하는 방법 존재. 이번 정리에서는 BIOS로 가상 OS 이미지를 로딩. 3.1 BIOS 서비스와 소프트웨어 인터럽트 BIOS는 PC 주변기기를 제어하는 거의 모든 기능을 제공. BIOS는 함수의 주소를 인터럽트 벡터 테이블에 넣어두고, 인터럽트를 호출하는 방법을 사용해 기능을 제공. BIOS가 제공하는 디스크 서비스는 0x13 인터럽트를 발생 시켜야 함. 소프트웨어 인터럽트는 int 0x13 형태로 사용. BIOS도 만능은 아니므로 파라미터와 결과 값을 레지스터를 사용해 전달. 기본적으로 범용 레지스터와 ES 세그먼트 레지스터를 사용하지만, BIOS 서비스 마다 사용하는 레지스터의 수와 종류가 다르므로 확인을 해야함. 3.2 OS 이미지 로딩 기능 구현3.2.1 디스크 읽기 기능 구현 이번 프로젝트에서는 0x10000에 OS 이미지를 로딩할 예정. 플로피 디스크에 첫 번쨰 섹터는 부트 로더로 BIOS가 메모리에 로딩 시킴. 즉, 두번째 섹터부터 OS 이미지 크기만큼 읽음. – 순서는 섹터 -&gt; 헤드 -&gt; 트랙 순. – 섹터를 다 읽고, 헤드를 1로 바꾸고 다시 같은 섹터를 읽은 뒤, 트랙을 증가 시킴. 앞서 구현했던 환영 메시지 출력 코드를 함수 형태로 작성해 원하는 곳에서 호출할 예정. 이를 위해 스택이 필요. 3.2.2 스택 초기화와 함수 구현 x86 프로세서에서 함수를 사용하려면 스택이 꼭 필요. x86에서는 함수 호출 후 call 호출로 되돌아갈 주소를 스택에 저장한뒤 ret 호출로 되돌아옴. 스택은 함수의 파라미터를 저장하는 역할도 함 -&gt; 호출하는 쪽과 호출되는 쪽은 정해진 규칙에 따라 파라미터를 스택에 저장. 스택 생성을 위해서는 스택 관련 레지스터가 필요. – 스택 세그먼트 레지스터(SS), 스택 영역을 사용할 세그먼트의 기준 주소를 지정. – 스택 포인터 레지스터(SP), 데이터를 삽입하고 제거하는 상위를 지정. – 베이스 포인터 레지스터(BP), 스택의 기준 주소를 임시로 지정할 때 사용. 1234mov ax, 0x0000 ; 스택 세그먼트의 시작 어드레스를 레지스터 값으로 변환mov ss, ax ; SS 설정mov sp, 0xFFFE ; SP 설정mov bp, 0xFFFE ; BP 설정 OS 이미지가 0x10000에 로딩될 예정으로 그 아래 영역을 사용할 예정. 메시지 출력 함수는 이전에 봤던 출력 핵심 코드와 상당히 유사. but, 함수에서 사용하는 레지스터를 저장하고, 복구하는 코드와 넘겨받은 파라미터를 스택에서 꺼내는 코드를 추가해야 함. 화면에서 원하는 위치에 문자열을 출력하려면 x, y 좌표와 문자열의 주소가 필요. 스택에 삽입하는 순서는 파라미터를 받는 쪽과 같은 순서로 삽입하면 순서는 상관없지만 C언어의 호출 규약을 따를 예정. 12// C 언어 함수 호출PrintMessage(ix, iy, pcString) 12345push word [ pcString ]push word [ iy ]push word [ ix ]call PRINTMESSAGEadd sp, 6 호출된 PRINTMESSAGE는 데이터를 꺼낼 때 C언어 함수 호출 규약과 동일. 함수 호출뒤 add sp, 6을 통해 스택에서 데이터를 제거. 호출되는 함수는 파라미터가 순서대로 삽입되어 있다는 사실을 알고 있음. 즉, 스택의 특정 위치를 기준으로 오프셋을 이용해 접근하며 파라미터를 찾음. – but, SP는 push, pop에 따라 계속 변해 불편. – 따라서 고정된 BP를 기준으로 파라미터에 접근. 1234567891011121314151617181920212223push bpmov bp, sp ; BP를 사용해 파라미터 접근push espush sipush di ; 모든 레지스터를 스택에 저장push axpush cxpush dx === 생략 ===mov ax, word [ bp + 4] ; 파라미터 1 (ix)mov bx, word [ bp + 6] ; 파라미터 2 (iy)mov cx, word [ bp + 8] ; 파라미터 3 (pcString)=== 생략 === pop dx pop cx pop ax pop di ; 데이터 복원 pop si pop es pop bp 호출되는 함수가 작업을 마치고 원래 주소 코드로 복귀할 때 정상적인 수행을 위해서는 함수 호출 전후의 레지스터 상태가 동일해야 함. – 따라서 호출되는 함수에서는 자신이 사용하는 레지스터의 값을 미리 스택에 저장, 수행이 끝나면 이를 복원. 보호 모드에서 사용되는 세 가지 함수 호출 규약 stdcall, 파라미터를 스택에 저장하며 호출된 쪽에서 스택을 정리. cdecl, 파라미터를 스택에 저장하며 함수를 호출한 쪽에서 스택을 정리. fastcall, 일부 파라미터를 레지스터에 저장하지만 stdcall과 유사. 3.3 테스트를 위한 가상 OS 이미지 생성 가상 OS 이미지는 세세한 부분까지 구현하지 않고 OS가 제대로 부트 로더로부터 메모리로 복사되는지 확인할 예정. 3.3.1 OS 이미지 통합과 QEMU 실행 1024개의 섹터를 돌며 가상 OS를 출력한 결과. 코드 보기 마치며포기할 뻔 했다. 역시 어셈블리 많이 어렵다..","categories":[{"name":"project","slug":"project","permalink":"http://DongyeolLee.github.io/categories/project/"},{"name":"정리","slug":"project/정리","permalink":"http://DongyeolLee.github.io/categories/project/정리/"},{"name":"os","slug":"project/정리/os","permalink":"http://DongyeolLee.github.io/categories/project/정리/os/"}],"tags":[{"name":"os","slug":"os","permalink":"http://DongyeolLee.github.io/tags/os/"}]},{"title":"2. 내 PC를 부팅하자","slug":"OS/Project/Boot-my-PC","date":"2018-01-10T13:01:37.000Z","updated":"2019-04-30T07:24:41.164Z","comments":true,"path":"2018/01/10/OS/Project/Boot-my-PC/","link":"","permalink":"http://DongyeolLee.github.io/2018/01/10/OS/Project/Boot-my-PC/","excerpt":"","text":"들어가기이번 정리에서는 조금 코드 레벨로 들어간다. 본론2.1 부팅과 부트 로더모든 OS는 동등하게 512바이트 크기의 부트 로더에서 시작. 2.1.1 부팅과 BIOS 부팅은 OS가 실행되기 전까지 수행되는 작업 과정. 부팅 과정 중 하드웨어와 관련된 작업을 BIOS가 담당, BIOS가 수행하는 테스트나 초기화를 POST라고 부름. BIOS는 펌웨어로 전원이 켜짐과 동시에 프로세서가 가장 먼저 실행하는 코드. BIOS에서 제공하는 기능은 인터럽트를 통해 사용 가능. BIOS의 가장 중요한 일은 부트 로더 이미지를 메모리로 복사하는 단계. 부트 로더는 저장 매체의 가장 앞부분에 존재. – 다양한 장치로 부팅할수 있으므로 BIOS는 POST가 완료된 후 여러장치의 앞부분을 검사. – 부팅 가능한 모든 장치를 검사했는데 부트 로더를 찾을 수 없다면 에러. 2.1.2 부트 로더의 역할과 구성 저장 매체에서 첫 번째 MBR에 있는 작은 프로그램. 부트 로더의 가장 중요한 일은 OS 이미지를 메모리에 복사. BIOS는 디스크에서 읽은 첫 번째 섹터(512 바이트)가 정삭적인 부트 로더인지 가장 마지막 2 바이트를 확인. – 마지막 2 바이트 값이 0x55, 0xAA라면 정상적인 부트 로더. 2.2 부트 로더 제작을 위한 준비2.2.1 이클립스 프로젝트 생성 C 프로젝트를 만들되 프로젝트 유형은 Makefile로 설정. 2.2.2 OS의 디렉터리 구조 생성 리얼 모드, 보호 모드, IA-32e 모드 별로 코드를 나눠서 관리. 2.2.3 makefile 파일 생성make 프로그램 소스 파일을 이용해 자동으로 실행 파일 또는 라이브러리 파일로 만들어주는 빌드 관련 유틸리티. 소스 파일과 목적 파일을 비교한 뒤 마지막 빌드 후 수정된 파일만 선택하여 빌드. make 프로그램이 빌드를 자동으로 수행하기 위해 각 소스 파일의 의존 관계나 빌드 순서, 옵션 등을 makefile에 작성. make 문법1234Target : Dependency&lt;tab&gt; Command&lt;tab&gt; Command&lt;tab&gt; Command Target은 생성할 파일, Dependency는 Target 생성에 필요한 소스, Command는 Dependency에 관련된 파일이 수정되면 실행할 명령. 123456789101112# a.c, b.c를 통해 output.exe 파일을 생성하는 예제all : output.exea.o : a.c gcc -c a.cb.0 : b.c gcc -c b.coutput.exe : a.o b.o gcc -o output.exe a.o b.o all은 make를 실행하면서 옵션으로 Target을 명시하지 않으면 사용하는 기본 Target. 12345678910all : output.exelibtest.a : make -C Libraryouput.o : output.c gcc -c output.coutput.exe : libtest.a output.o gcc -o output.exe output.o -ltest -L ./ make는 빌드를 수행하는 도중에 다른 make를 실행 가능. – 즉, 계층적 실행이 가능. – 최상위 디렉터리의 하위에 Library 있고, 빌드 과정에서 Library 디렉터리를 빌드 해야하면 C 옵션을 사용. OS용 makefile 생성123456789101112131415161718192021222324all: BootLoader Disk.img BootLoader: @echo @echo ================== Build BootLoader ================== @echo make -C 00.BootLoader @echo @echo ================== Build Complete ================== @echo Disk.img: 00.BootLoader/BootLoader.bin @echo @echo ================== Disk Image Build Start ================== @echo cp 00.BootLoader/BootLoader.bin Disk.img @echo ================== All Build Complete ================== clean: make -C 00.BootLoader clean rm -f Disk.img 최상위 makefile의 목적은 OS이미지 생성을 위한 각 하위 디렉터리의 makefile 실행. 123456789# 00.BootLoader 내의 makefileall: BootLoader.binBootLoader.bin: BootLoader.asm nasm -o BootLoader.bin BootLoader.asm clean: rm -f BootLoader.bin 부트 로더 makefile의 목적은 BootLoader.asm을 빌드하여 BootLoader.bin을 생성. 2.3 부트 로더 제작과 테스트2.3.1 세상에서 가장 간단한 부트 로더 부트 로더를 메모리에 정삭적으로 복사하려면 마지막 2 바이트만 잘 저장하면 됨. asm 코드 보기 마지막 2 바이트 0x55, 0xAA로 세팅 확인. 2.3.2 QEMU 실행 QEMU로 Disk.img를 로드해 실행해 보면 부트 로더가 정상적으로 작동. 2.3.3 화면 버퍼와 화면 제어 위에서 본 asm 코드를 보면 현재 동작 중인 화면 모드와 관련된 비디오 메모리의 주소를 할당. PC 부팅 후 기본 설정되는 화면 모드는 텍스트 모드(가로 80문자, 세로 25문자)로 메모리 주소 0xB8000에서 시작. 화면에 표시되는 문자는 1 바이트의 속성값과 1바이트의 문자값, 총 2 바이트로 구성되며 화면을 구성하는 총 메모리 크기는 80x25x2 = 4000 바이트. 2.3.4 세그먼트 레지스터 초기화와 Hello, World!세그먼트 레지스터 초기화 이전 BIOS가 부트 로더를 실행했을때 세그먼트에는 BIOS가 사용했던 값들이 저장. Ox07C0으로 초기화. – BIOS가 부트 로더를 읽어 메모리에 복사하는 위치가 0x07C00. – 0x07C00부터 512 바이트 범위에 코드(code segment)와 데이터(data segment)가 존재. 화면 정리 및 부팅 메시지 출력123456789101112131415mov si, 0.SCREENCLEANLOOP: mov byte [ es: si], 0 mov byte [ es: si + 1], 0x0A add si, 2 cmp si, 80 * 25 * 2 jl .SCREENCLEANLOOP mov si, 0 mov di, 0 QEMU를 실행하면 BIOS가 출력한 메시지 때문에 지저분 -&gt; 정리할 필요. – 화면 정리는 0xB8000부터 4000 바이트를 모두 0으로 채움(문자 부분만). 1234567891011121314151617.MESSAGELOOP: mov cl, byte [ si + MESSAGE1 ] cmp cl, 0 je .MESSAGEEND mov byte [ es: di ], cl add si, 1 add di, 2 jmp .MESSAGELOOP.MESSAGEEND: jmp $MESSAGE1: db &apos;OS BootLoader Start!!&apos;, 0 화면 출력을 나타내는 di 인덱스는 속성값은 바꾸지 않아 2 증가, 문자열 인덱스 si는 1 증가. 2.3.5 부트 로더 테스트 다시 makefile로 빌드 후 QEMU를 실행해보면 정상작동. MESSAGE1을 어떻게 바꾸냐에 따라 문자 변경 가능. – 친구에게 인증하려고 저 문구 작성. 마치며역시 좀 어렵다.첫 번째는 무작정 코드를 작성하면서 책을 읽고 블로깅의 정리를 위해 2번째 읽고 있다. 몇번 읽어야 이해가 완전히 될까. 그래도 정리를 하면서 이전보다는 확실히 더 깊게 알게된건 확실하다.","categories":[{"name":"project","slug":"project","permalink":"http://DongyeolLee.github.io/categories/project/"},{"name":"정리","slug":"project/정리","permalink":"http://DongyeolLee.github.io/categories/project/정리/"},{"name":"os","slug":"project/정리/os","permalink":"http://DongyeolLee.github.io/categories/project/정리/os/"}],"tags":[{"name":"os","slug":"os","permalink":"http://DongyeolLee.github.io/tags/os/"}]},{"title":"1. 64비트 프로세서의 이모저모","slug":"OS/Project/64bits-processor","date":"2018-01-04T13:10:04.000Z","updated":"2019-04-30T07:24:41.163Z","comments":true,"path":"2018/01/04/OS/Project/64bits-processor/","link":"","permalink":"http://DongyeolLee.github.io/2018/01/04/OS/Project/64bits-processor/","excerpt":"","text":"들어가기실질적인 OS 개발에 앞서 간단하게 책에 나온 운영 모드를 정리. 본론1.1 운영 모드 총 다섯 가지 운영 모드를 지원하지만, 꼭 필요한 리얼 모드, 보호 모드, IA-32e 모드 를 중심으로 진행. 1.1.1 64비트 OS가 갖추어야 할 필수 운영 모드 리얼 모드 프로세서가 전원이 켜지거나 리셋되면 프로세서는 리얼 모드로 진입. 16 비트 프로세서와 동일하게 동작, BIOS(Basic Input Output System)의 기능 사용. OS 이미지를 디스크에서 메모리로 복사하여 보호 모드로 변경. 보호 모드 리얼 모드에서 IA-32e 모드로 전환시 반드시 보호 모드를 거쳐야 함. 32 비트, 기본 동작 모드로 여러 기능(보호, 멀티태스킹, 세그먼테이션, 페이징)을 하드웨어적으로 지원. IA-32e 모드 서브 모드로 32비트 호환 모드와 64비트 모드 존재. 32비트 코드를 그대로 실행 가능. 1.1.2 운영 모드 사이의 관계와 운영 모드의 전환 화살표 위에 표시된 내용은 해당 모드로 전환하는데 필요한 조건을 나타냄. 1.2 운영 모드와 레지스터 운영 모드 앞에 붙은 숫자는 레지스터의 크기와 관계 -&gt; 숫자가 커질수록 레지스터 개수 증가. OS를 개발하는 과정에서 큰 비중을 차지하는 레지스터는 범용 레지스터, 세그먼트 레지스터, 컨트롤 레지스터. 1.2.1 범용 레지스터 범용 레지스터는 계산, 메모리 어드레스 지정, 임시 저장 공간 등의 목적으로 사용. 범용 레지스터의 수가 늘어날수록 수행속도는 증가. 다양한 목적으로 사용 가능하지만, 특정 명령어는 특정 레지스터와 같이 사용 운영 모드별로 레지스터가 개별적으로 존재하지 않고 접두사나 접미사를 붙여 접근하는 크기를 표시. 1.2.2 세그먼트 레지스터 16 비트 레지스터로 어드레스 영역을 다양한 크기로 구분. 리얼 모드에서는 고정된 크기의 어드레스 영역을 지정, 보호 모드와 IA-32e 모드에서는 접근 권한과 세그먼트의 시작 어드레스를 지정하는데 사용되기도 함. 세그먼트 레지스터 접두사를 통해 명시적으로 특정 세그먼트를 설정 가능. 1.2.3 컨트롤 레지스터 운영 모드를 변경하고, 운영 중인 모드의 특정 기능을 제어하는 레지스터. 컨트롤러 레지스터는 운영 모드와 확장 기능을 제어하는 만큼 다소 복잡, 운영 모드에 따라 필수 필드와 옵션 필드가 달라짐. 1.3 운영 모드와 메모리 관리 기법 메모리 관리 기법은 크게 세그멘테이션과 페이징. 세그멘테이션은 세그멘트 레지스터에 세그먼트의 시작 주소 혹은 디스크립터 위치를 설정. 페이징은 컨트롤 레지스터 중 CR3 레지스터에 물지 주소를 설정. 1.3.1 리얼 모드의 메모리 관리 방식 리얼 모드는 최대 1MB까지 주소 공간을 사용, 세그멘테이션만 지원. 세그멘테이션에서 세그먼트의 시작 어드레스는 기준 어드레스로 사용. 리얼 모드의 세그먼테이션은 세그먼트 레지스터 값 + 범용 레지스터 값. 세그먼트 레지스터 크기 16 비트로 1MB 영역 접근??(2^16 = 65536) – 세그먼트 레지스터 값 * 16을 기준 주소로하고 범용 레지스터와 더함. 1.3.2 보호 모드의 메모리 관리 방식 보호 모드는 세그먼테이션과 페이징 모두 지원. 보호 모드의 세그먼테이션은 레지스터에 기준 주소를 직접 설정하는 대신 디스크립터 자료구조의 위치를 설정. 세그먼트 레지스터의 명칭도 세그먼트 디스크립터를 선택한다는 의미에서 세그먼트 셀렉터로 변경. 세그먼트에 대한 정보를 나태내는 세그먼트 디스크립터. – 시작 어드레스와 크기, 권한, 타입 등의 정보 저장. 보호 모드에서 세그먼트 레지스터는 세그먼트 디스크립터의 위치를 가르킴. 세그먼트 디스크립터는 GDT(Global Descriptor Table)에 저장. 주소를 계산하는 방법은 기준 주소에 범용 레지스터 값을 더함 -&gt; 선형 주소. – 선형 주소를 기반으로 물리 주소를 계산. 선형 주소는 페이징의 입력 값이되어 물리 주소로 변환. 페이징, 물리 메모리를 페이지로 나누고 선형 주소를 물리 주소로 페이지로 연결하는 방식 -&gt; 주소 공간을 더 넓게 사용 가능. 1.3.3 IA-32e 모드의 메모리 관리 방식 세그먼트 디스크립터에 설정된 기준 주소와 크기에 관계없이 모든 기준 주소는 0, 크기는 64 비트. 주소 공간이 늘어난 만큼 변환 단계도 늘어나지만 기본적인 원리는 보호 모드 페이징과 같음. 마치며막상 OS 개발을 시작해보려니 어렵다. 지속적인 공부가 필요할듯….부족한 부분이나 이해가 가지 않은 부분은 뒷 장을 진행하면서 보충하자!!","categories":[{"name":"project","slug":"project","permalink":"http://DongyeolLee.github.io/categories/project/"},{"name":"정리","slug":"project/정리","permalink":"http://DongyeolLee.github.io/categories/project/정리/"},{"name":"os","slug":"project/정리/os","permalink":"http://DongyeolLee.github.io/categories/project/정리/os/"}],"tags":[{"name":"os","slug":"os","permalink":"http://DongyeolLee.github.io/tags/os/"}]},{"title":"Mac OX에 emscripten 설치하기","slug":"JS/EmscriptenInstall","date":"2017-12-30T18:11:46.000Z","updated":"2019-04-30T07:24:41.162Z","comments":true,"path":"2017/12/31/JS/EmscriptenInstall/","link":"","permalink":"http://DongyeolLee.github.io/2017/12/31/JS/EmscriptenInstall/","excerpt":"","text":"들어가기emscipten은 C 또는 C++를 최적화된 JavaScript로 변환해주는 LLVM(Low Level Virtual Machine)기반 프로젝트로 C와 C++ 코드를 플러그인 없이 웹에서 native 수준의 속도로 실행할 수 있습니다. emscipten에 대한 보다 자세한 설명은 추후 포스팅에서 이어나가도록 하겠습니다. 그럼 홈페이지에 나와 있는 설치 방법을 보겠습니다. 설치 먼저, emcripten 사이트에서 Mac OX 환경에 맞는 sdk를 다운로드합니다. 다운로드가 완료되면 폴더 압축을 풀어준 뒤 sdk 폴더 안으로 들어갑니다. 1./emsdk update ./emsdk update로 사용 가능한 tool의 최신 레지스트리를 가져옵니다. 1./emsdk install latest 이어 가장 최신 버젼의 sdk를 설치합니다. 1./emsdk activate latest 현재 user로 하여금 설치한 sdk를 사용할 수 있게 활성화 합니다. 1source ./emsdk_env.sh 경로 및 다른 환경 변수를 활성화 합니다. test 실행emscipten의 설치가 완료되면 ./emcc 또는 ./em++를 활용해 간단한 테스트를 진행 할수가 있습니다. 우선 설치가 잘 진행됐는지 버젼 확인부터 해보겠습니다. 압축 푼 폴더 내부에 emscripten/{version}/ 에서 테스트를 진행할 수 있습니다. 보시는 거와 같이 emscipten이 정상적으로 설치가 됐습니다. 정상적으로 설치가 됐으니 C로 작성된 코드를 테스트 해보겠습니다. 코드 작성은 직접 작성해도 되지만 test 폴더 안에 있는 예제를 활용해 보겠습니다. 123456#include &lt;stdio.h&gt;int main() &#123; printf(&quot;hello, world!\\n&quot;); return 0;&#125; C로 작성된 hello wordl 예제입니다. 1./emcc tests/hello_world.c JavaScript 코드로 변환하기 위해서는 ./emcc 뒤 파일을 지정하면 됩니다. 그럼 a.out.js 파일을 확인할 수 있고 이를 다시 node a.out.js 명령어를 치면 터미널에 “hello, world”를 확인할 수 있습니다. 1./emcc tests/hello_world.c -o hello.html 브라우져 실행을 위해서는 테스트 파일을 html로 지정해주기만 하면 hello.html를 통해 확인할 수 있습니다. 마치며보다 많은 예제와 사용법은 emscipten 공식 홈페이지를 참고해주세요. 참조emscriptenemscripten install documentemscripten tutorial","categories":[{"name":"programming","slug":"programming","permalink":"http://DongyeolLee.github.io/categories/programming/"},{"name":"javascript","slug":"programming/javascript","permalink":"http://DongyeolLee.github.io/categories/programming/javascript/"},{"name":"etc","slug":"programming/javascript/etc","permalink":"http://DongyeolLee.github.io/categories/programming/javascript/etc/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://DongyeolLee.github.io/tags/javascript/"},{"name":"emscripten","slug":"emscripten","permalink":"http://DongyeolLee.github.io/tags/emscripten/"},{"name":"javascript compiler","slug":"javascript-compiler","permalink":"http://DongyeolLee.github.io/tags/javascript-compiler/"}]},{"title":"힙 정렬(Heap sort)","slug":"Datastructure/HeapSort","date":"2017-12-24T10:55:03.000Z","updated":"2019-04-30T07:24:41.160Z","comments":true,"path":"2017/12/24/Datastructure/HeapSort/","link":"","permalink":"http://DongyeolLee.github.io/2017/12/24/Datastructure/HeapSort/","excerpt":"","text":"#들어가기이번 포스팅에는 힙 정렬(heap sort)에 대해 알아보겠습니다. #힙 정렬(heap sort)먼저 힙 정렬(heap sort)을 이해하기 위해서 힙(heap) 에 대해 알아보겠습니다.힙(heap) 은 다음과 같은 두가지 조건을 만족해야 합니다. complete binary tree heap property 즉, 완전 이진 트리이면서 힙이 가지고 있는 특성(max or min)을 만족해야 합니다. 포스팅에서는 max heap property를 기준으로 설명하겠습니다. 위의 예시를 보면 (a)는 힙(heap) 이지만 (b), (c)는 힙(heap) 이라고 할 수 없습니다. (a), max heap property를 만족하면서 완전 이진 트리. (b), 완전 이진 트리이긴하지만 heap property를 만족하지 않습니다. (c), max 또는 min property를 만족하지만, 완전 이진트리가 아닙니다. 또 하나 참고로 알아야 할 것이 동일한 데이터를 가지더라도 힙(heap) 은 달라질 수 있습니다. 즉, 힙(heap)은 동일한 데이터에 유일하지 않습니다. 그렇다면 트리로 복잡하게 표현된 힙(heap) 은 어떤 식으로 표현할 수 있을 까요?? 각각의 트리에 번호를 루트에서부터 부여해 1차원 배열로 표현이 가능합니다. 이렇게 1치원 배열로 표현된 힙(heap) 을 다루기 위한 기본 연산으로 max-heapify가 필요합니다. max-heapify를 사용하기 위해서는 트리의 전체 모양이 완전 이진 트리여야 하고 왼쪽 subtree와 오른쪽 subtree가 그 자체로 힙(heap) 이여야합니다. 즉, max-heapify는 루트 노드만이 힙(heap) 을 만족하지 않아 루트 노드를 포함해 힙(heap) 을 만드는 기본 연산입니다. 예시를 한번 보겠습니다. 루트 노드 4를 제외하고 루트를 기준으로 왼쪽 subtree와 오른쪽 subtree는 모두 힙(heap) 을 만족하지만 루트 노드를 포함해서는 힙(heap) 을 만족하지 않는 상황입니다. 이럴 때 max-heapify의 연산으로 루트를 포함한 전체 트리를 힙(heap) 으로 만들수 있습니다. 먼저, max-heapify의 동작 방식부터 보겠습니다. 이번 포스팅에서 max property를 기준으로 하기 때문에 루트 노드 4가 두 자식들 중 더 큰 자식이 나보다 크면 해당 자식과 위치를 교환합니다. 16과 자리를 교체하고 나면 다시 4가 루트인 서브트리를 기준으로 왼쪽 subtree와 오른쪽 subtree는 힙(heap) 을 만족하지만 4를 포함하면 만족하지 않기 때문에 다시 max-heapify 연산을 진행합니다. max-heapify 연산은 자식이 존재 하지 않거나 두 자식이 나보다 작으면 동작을 멈추게 됩니다. 1234567891011121314MAX-HEAPIFY (A, i) &#123; if there is no child of A[i] return; k &lt;- index of the biggest child of i; if A[i] &gt;= A[k] return; exchage A[i] and A[k]; MAX-HEAPIFY(A, k);&#125; 수도 코드를 보면 자식이 존재하지 않을 때와 또는 두 자식보다 클 경우 종료되는 것을 확인할 수 있습니다. 조금 더 직관적인 예시를 한번 보겠습니다. 루트 노드를 기준으로 왼쪽 subtree가 힙(heap) 을 만족하지 않습니다. 하지만 4를 기준으로 다시 볼때 4의 왼쪽, 오른쪽 subtree 모두 힙(heap) 을 만족하므로 heapify 연산을 사용해 전체를 힙(heap) 으로 만들수 있습니다. 즉, 위의 수도 코드를 사용한다면 MAX-HEAPIFY(A, 2)와 같은 방법으로 전체를 힙(heap)으로 만들 수 있습니다. 자! 그렇다면 이제부터 힙(heap) 과 heapify 연산을 활용해 힙 정렬(heap sort)을 알아보겠습니다. 힙 정렬(heap sort)을 하기 위해서 먼저 정렬해야 할 배열을 완전 이진 트리 형태로 표현합니다. 하지만 이 상태만으로는 힙(heap) property를 만족하진 않습니다. 힙 정렬(heap sort)구현을 위해 첫번째 할 일은 바로 표현된 완전 이진 트리를 힙(heap) 으로 만드는 것 입니다. 표현된 완전 이진 트리를 힙(heap) 으로 만들기 위해서 뒤에서 부터 탐색해 자식이 있는 노드에서부터 앞서 활용했던 max-heapify를 사용합니다. 즉, 16을 기준으로 subtree를 비교하면서 max-heapify를 실행합니다. 16과 subtree는 그 자체로 힙(heap) 이므로 다음 노드인 2로 넘어갑니다. 2를 기준으로 subtree를 비교할때 자식 노드 중 제인 큰 14보다 2는 작은 상황입니다. 따라서 2와 14를 교체합니다. 또 3은 다시 10과 교체하고 1은 16과 교체합니다. 루트 노드까지 올라가면서 max-heapify 연산을하면 힙(heap) 을 완성할 수 있습니다. 즉, 루트 노드가 최대값이 됩니다. 123456Build-Max-Heap(A) &#123; heap-size[A] &lt;- length[A] for i &lt;- absolute length[A]/2 downto 1 // 배열 A의 길이를 2로 나눈 절대값부터 1까지 do MAX-HEAPIFY(A, i)&#125; 수도 코드를 보면 length[A]/2의 절대 값을 취해 자식이 있는 노드 중 가장 밑에 있는 노드부터 시작해 루트 노드까지 MAX-HEAPIFY를 진행합니다. Build-Max-Heap의 시간 복잡도는 O(n)입니다. MAX-HEAPIFY를 한 번 수행하는데 시간 복잡도는 O(logn)이고 이를 n/2번 실행함으로 시간 복잡도는 O(nlogn)이겠지만 MAX-HEAPIFY가 매번 N만큼 실행 되는 것이 아니므로 보다 정확하게 계산을 진행하면 O(n)이 나옵니다. 그렇다면 정렬되지 않은 배열을 Build-Max-heap을 통해 힙(heap) 형태로 만들어 놓으면 루트 노드는 최대 값이 들어 있는 모양이 됩니다. 이때 루트에 들어있는 최대값을 힙(heap) 의 가장 마지막 값과 바꾸고 힙(heap) 의 사이즈를 1 줄여 줍니다. 그리고 다시 루트에서 부터 heapify를 통해 힙(heap) 으로 만들고 이를 반복합니다. 123456789HeapSort(A) &#123; Build-Max-Heap(A); // 배열을 힙으로 만듬 O(n) for i &lt;- heap_size downto 2 // 정렬 O(n-1) exchange A[1] and A[i] // O(1) heap_size &lt;- heap_size -1 // O(1) MAX-HEAPIFY(A, 1) // O(logn) &#125; 결국 모든 힙(heap) 의 요소를 루트 노드에서 빼면서 진행하다 보면 배열은 정렬이 되고 이를 힙 정렬(heap sort)이라고 합니다. 시간 복잡도는 O(nlogn)입니다. #마치며이로써 힙 정렬(heap sort)의 정리를 마치겠습니다. #참조부경대학교 권오흠 교수님 강의 | 2015년 1학기 - 힙정렬 1부경대학교 권오흠 교수님 강의 | 2015년 1학기 - 힙정렬 2부경대학교 권오흠 교수님 강의 | 2015년 1학기 - 힙정렬 3","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"concepts","slug":"computer-science/algorithms/concepts","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/concepts/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"},{"name":"sort","slug":"sort","permalink":"http://DongyeolLee.github.io/tags/sort/"},{"name":"heap sort","slug":"heap-sort","permalink":"http://DongyeolLee.github.io/tags/heap-sort/"}]},{"title":"commit 없이 로컬에 코드 반영하기","slug":"Spadework/GitUpdate-Index","date":"2017-12-20T02:16:01.000Z","updated":"2019-04-30T07:24:41.166Z","comments":true,"path":"2017/12/20/Spadework/GitUpdate-Index/","link":"","permalink":"http://DongyeolLee.github.io/2017/12/20/Spadework/GitUpdate-Index/","excerpt":"","text":"#들어가기개인 설정 관련 파일에 경우 .gitignore에 등록하여 git에서 tracking하지 못하게 하는 경우가 많습니다. 하지만 한 예로 Vagrantfile(virtual box와 연동해서 쓰는 파일) 같은 경우는 Vagrantfile 자체가 지속적으로 버젼 관리가 되어야 합니다. 또 그 파일 안에서 ip 설정 등 개발 환경을 설정해야 합니다.즉, 버젼 관리가 필요한 파일 내부에 local ip 세팅 등 개인적 환경 세팅을 하면 이 역시 git에서 tracking하게 됩니다. 개인적인 환경 변화로 인한 commit은 공동 project라면 해서는 안되죠. 하지만 개발을 하려면 ip 설정, port 등 꼭 자신의 환경에 맞게 수정해야 하는데 어떤식으로 가능할까요? #본론초기에는 Vagrantfile 내부에 저에게 할당된 개발 ip와 port 등을 세팅하고 commit 할때는 해당 파일을 제외하는 식으로 진행했습니다. 하지만 git update-index를 사용하면서 보다 편리한 개발을 진행할 수 있게 됐습니다.git update-index는 git이 tracking하고 있는 파일들을 option을 사용해 수정을 하는 명령어 입니다. 1git update-index --assume-unchanged [file name] 그 중 –assume-unchanged option은 git이 tracking 하는 파일이지만 working tree에서 더 이상 해당 파일을 tracking하지 않게 해주는 명령어 입니다. 1git update-index --no-assume-unchanged [file name] 다시 –no-assume-unchanged을 사용해 tracking 할수도 있습니다. git update-index을 사용하기 전까지 stash에도 넣어보고 .gitignore에도 넣어보는 등 많은 시도를 해보았습니다. stash에 넣으면 stash에 넣은 파일은 다시 수정되기 전 상태로 돌아가 사용할 수 없었습니다. 또 .gitignore을 추가하자니 .gitignore을 push 해야하는 문제도 있었습니다. .gitignore의 더 큰 문제점은 제가 수정했던 파일 자체가 앞서 설명드렸던거와 같이 지속적인 버젼 관리를 해야하기에 사용할 수 없었습니다. #마치며설명 도중 틀린 설명이 있다면 코멘트로 남겨주세요. 수정하겠습니다!! #참조Git Documentation","categories":[{"name":"삽질기","slug":"삽질기","permalink":"http://DongyeolLee.github.io/categories/삽질기/"}],"tags":[{"name":"git","slug":"git","permalink":"http://DongyeolLee.github.io/tags/git/"},{"name":"git update-index","slug":"git-update-index","permalink":"http://DongyeolLee.github.io/tags/git-update-index/"}]},{"title":"퀵 정렬(Quick sort)","slug":"Datastructure/QuickSort","date":"2017-12-18T02:01:01.000Z","updated":"2019-04-30T07:24:41.161Z","comments":true,"path":"2017/12/18/Datastructure/QuickSort/","link":"","permalink":"http://DongyeolLee.github.io/2017/12/18/Datastructure/QuickSort/","excerpt":"","text":"#들어가기이번 시간에는 분할정복법을 사용한 퀵 정렬(quick sort)를 알아보겠습니다. #퀵 정렬(quick sort)먼저 퀵 정렬(quick sort)의 간략한 개념부터 살펴보겠습니다. 위의 사진에서 볼수 있듯이 pivot을 선택 pivot을 기준으로 분할 분할된 구역에서 다시 순환적으로 정렬(정복) 즉, 퀵 정렬(quick sort)의 중요한 부분은 ‘어떻게 pivot보다 작은 값과 큰 값을 구분해 정렬하는냐’에 있습니다. 123456789101112qsort(A[], p, r) &#123; // p는 배열의 첫번째 index 값, r은 마지막 index 값 if(p &lt; r) then &#123; q = partition(A[], p, r); // 분할 qsort(A[], p, q-1); // pivot보다 작은 영역 정렬 qsort(A[], q+1, p); // pivot보다 큰 영역 정렬 &#125;&#125;partition(A[], p, r) &#123; partiton이 하는 일은 배열에서 pivot을 기준으로 큰 영역과 작은 영역으로 재배치 한 후, 바뀐 pivot의 index값을 반환 합니다.&#125; pseudo code를 보면 실제로 partition 함수에서 pivot을 기준으로 영역을 나누고 바뀐 pivot의 위치를 반환하면 그 이후는 재귀 함수 호출로 간단히 구현이 가능합니다.partition 함수를 조금 더 구체화 해보겠습니다. 123456789101112partition(A[], p, r) &#123; x←A[r]; // x, 현재 pivot의 값 i←p-1; // i, 작은 영역의 마지막 요소를 가르키는 변수 for j←p to r-1 // 배열을 전체 탐색 if A[j] ≤ x then // 해당 배열의 값이 pivot보다 작은 경우 i←i+1; // i 값 증가 exchange A[i] and A[j]; // i와 j의 교체 exchange A[i+1] and A[r]; // pivot 위치 선정, 작은 영역의 마지막 index + 1로 이동 return i+1;&#125; partition의 pseudo code에서 왜 i와 j의 값을 교체하는지 조금은 헷갈릴수 있습니다. 예를 한번 들어보겠습니다. 다음과 같은 상황에서 pivot의 값, x의 값은 15이고 j = 4, i = 0인 상황입니다. A[j]의 경우 pivot보다 작으므로 i값이 1 증가하면 i = 1이 됩니다. A[1]은 현재 pivot보다 큰 영역의 숫자이므로 A[j]와 교환을 해도 그 영역은 유지가 됩니다. 즉, i 보다 작은 index 영역이 pivot보다 작은 영역임을 유지하면 됩니다. 그렇다면 시간 복잡도는 어떻게 될까요? 최악의 경우 n의 제곱이 됩니다. 아이러니하게도 퀵 정렬(quick sort)의 최악의 경우는 이미 정렬된 배열의 가장 큰 값이나 가장 작은 값을 pivot으로 선택할 경우 입니다. 이럴 경우 pivot의 한 쪽은 정렬을 하지 않습니다. pivot 자체가 가장 큰 값이거나 가장 작은 값이기 때문이죠. 자세히 시간 복잡도를 보면 T(n) = T(0) + T(n-1) + O(n) T(n-1) = T(0) + T(n-2) + O(n-1) T(n-2) = T(0) + T(n-3) + O(n-2) pivot을 제외한 왼쪽 영역을 정렬하는데 시간 T(n) = T(n-1) + O(n)이 됩니다. 이런 식으로 T를 계속 치환해 나가다보면 T(n) = O(1) + O(2) + O(3) + … + O(n) 이 됩니다. 이는 {n(n-1)}/2로 다시 쓸수 있으므로 최악의 경우 시간 복잡도는 O(n^2)이 됩니다. 최선의 경우는 정렬되지 않은 상태에서 정확히 pivot이 중간 값일 떄 입니다. 시간 복잡도는 T(n) = nlogn이 됩니다. 이는 n이 pivot을 중심으로 정확히 절반 씩 영역을 나누는데 O(n)입니다. 또 절반씩 나누어진 영역에서 pivot을 중심으로 반을 나누면 O(n/2)이고 두 영역이니 이 역시 O(n)입니다. 결국은 최선의 경우 시간 복잡도는 n * 분할된 횟수인 logn이 됩니다. 그렇다면 우리는 최악의 경우 O(n^2)이 나올수도 있는 퀵 정렬(quick sort)를 쓰는 이유는 무엇일까요? 답은 퀵 정렬(quick sort)은 극단적인 최악의 경우를 제외하면 모든 정렬에서 평균 O(nlogn)이 나오기 떄문입니다. 1:9로 나누는 pivot이 선택된다고 가정했을때 시간 복잡도가 O(nlogn)이 나오는 걸 확인할수 있습니다. #마치며이로써 퀵 정렬(quick sort)의 정리를 마치겠습니다.설명 도중 틀린 설명이 있다면 코멘트로 남겨주세요. 수정하겠습니다!! #참조부경대학교 권오흠 교수님 강의 | 2015년 1학기","categories":[{"name":"computer science","slug":"computer-science","permalink":"http://DongyeolLee.github.io/categories/computer-science/"},{"name":"algorithms","slug":"computer-science/algorithms","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/"},{"name":"concepts","slug":"computer-science/algorithms/concepts","permalink":"http://DongyeolLee.github.io/categories/computer-science/algorithms/concepts/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://DongyeolLee.github.io/tags/algorithms/"},{"name":"sort","slug":"sort","permalink":"http://DongyeolLee.github.io/tags/sort/"},{"name":"quick sort","slug":"quick-sort","permalink":"http://DongyeolLee.github.io/tags/quick-sort/"}]},{"title":"IncorrectValidationError","slug":"Spadework/IncorrectValidationError","date":"2017-12-12T01:47:36.000Z","updated":"2019-04-30T07:24:41.167Z","comments":true,"path":"2017/12/12/Spadework/IncorrectValidationError/","link":"","permalink":"http://DongyeolLee.github.io/2017/12/12/Spadework/IncorrectValidationError/","excerpt":"","text":"#들어가기최근 지인의 요청으로 glassfish 서버 인증서를 갱신해달라는 요청을 받았습니다. 이 전에도 한번 갱신한 적이 있어 흔쾌히 승낙하고 진행하던 중 처음보는 error를 만나 간단하지만 어떻게 해결했는지 공유하겠습니다. #본론인증서는 letsencrypt에서 무료로 발급하는 인증서를 사용하고 있었습니다. letsencrypt의 인증서는 3개월이 만료기간으로 그 기간이 지나면 자동 또는 수동으로 인증서를 갱신하여야 합니다.1letsencrypt-auto -certonly 위의 명령어를 활용하면 간단하게 인증서를 받아오고 환경에 맞게 인증서를 변환해주면 되는 간단한 작업입니다. 하지만 예상치 못한 error와 직면하게 됐습니다. Incorrect validation certificate for tls-sni-01 challenge. 인증서를 발급받기 직전 서버와의 커넥션을 확인하는 과정에서 위와 같은 error가 발생했습니다. 위의 error는 443번 포트를 활용해 유효성을 검사하는 도중 발생하는 error입니다. 이럴 경우 포트 443(ssl)번과 80(http)번이 제대로 동작하고 있는지 확인해야 합니다. 저 같은 경우는 내부 서버 자체의 포트는 잘 맵핑이 되어있었습니다. 하지만 iptime 공유기에서 포트포워딩을 해줄때 443 -&gt; 80(외부 -&gt; 내부)으로 엉뚱한 웹서버에 포트포워딩되어 인증서 발급과정에서 error가 발생했습니다. 따라서 설정을 433 -&gt; 443(외부 -&gt; 내부)로 변경하니 다시 인증서를 정상적으로 발급 받을수 있었습니다. #마치며부족한 설명이었지만 이 글을 통해 소개한 error를 해결하는데 조금이라도 도움이 되는 기회였으면 좋겠습니다. 설명 도중 틀린 설명이 있다면 코멘트로 남겨주세요. 수정하겠습니다!!","categories":[{"name":"삽질기","slug":"삽질기","permalink":"http://DongyeolLee.github.io/categories/삽질기/"}],"tags":[{"name":"https","slug":"https","permalink":"http://DongyeolLee.github.io/tags/https/"},{"name":"letsencrypt","slug":"letsencrypt","permalink":"http://DongyeolLee.github.io/tags/letsencrypt/"},{"name":"error","slug":"error","permalink":"http://DongyeolLee.github.io/tags/error/"}]},{"title":"도대체 이벤트 루프(event loop)가 뭐야??","slug":"JS/EventLoop","date":"2017-12-11T02:15:52.000Z","updated":"2019-04-30T07:24:41.163Z","comments":true,"path":"2017/12/11/JS/EventLoop/","link":"","permalink":"http://DongyeolLee.github.io/2017/12/11/JS/EventLoop/","excerpt":"","text":"#들어가기Javascript로 개발을 하다보면 event loop라는 용어를 심심치 않게 접하게 됩니다. event loop가 도대체 뭐길래 javascript 관련해 글을 읽다보면 event loop가 자주 나오는 걸까요? #이벤트 루프(event loop)Javascript의 Runtime의 구조를 크게 보면 메모리 할당과 관련 있는 heap과 Stack frame이 저장되는 stack이 있습니다. 하지만 런타임 그 자체로 보면 그 내부의 우리가 javascript를 사용하면서 자주 쓰는 setTimeout이나 DOM 또는 Http Request를 찾아볼 수 없습니다. Javascript Runtime을 포함한 좀 더 큰 그림으로 구조를 살펴보겠습니다. 브라우저가 제공하는 web APIs와 Callback queue, Event loop를 확인할 수 있습니다. 자바스크립트의 큰 특징 중 하나는 ‘single thread’ 기반의 언어라는 점입니다. 스레드가 하나라는 말은 동시에 하나의 작업만을 처리할 수 있다라는 소리와 같고, 또 구조에서 볼수 있듯이 하나의 call stack을 가지고 있다는 소리와 같습니다. 1234567891011121314function multiply(x, y) &#123; return x*y;&#125;function square(n) &#123; return multiply(n, n);&#125;function printS(n) &#123; var s = square(n); console.log(s);&#125;printS(4); 간단한 코드로 스택의 변화를 보면 printS(4)를 하기위해 stack 밑에서부터 printS(4), square(n), multiply(x, y) 순으로 쌓이게 됩니다. 만약 stack에 쌓이는 함수들 중 엄청난 시간을 필요로 하는 함수가 stack에 push되면 어떻게 될까요? single thread 기반의 javascript는 그 함수가 끝날때 까지 아무것도 하지 못하는 치명적인 문제가 발생할겁니다. 즉, browser 측면에서 보면 stack에 있는 함수 때문에 browser가 동작하지 않는 문제가 발생합니다. 다음과 같은 문제를 해결하기 위해 javascript는 callback를 사용합니다. 1234567console.log(&quot;hi&quot;);setTimeout(function() &#123; console.log(&quot;i am in time-out&quot;);&#125;,5000);console.log(&quot;end&quot;); 위의 코드를 실행해보면 ‘hi’, ‘end’가 출력된 뒤 5초정도 후 ‘i am in time-out’이 출력되는 것을 확인할 수 있습니다. 그럼 위와 같은 코드가 앞서 확인한 스택과 어떻게 동작할까요?? 먼저 stack에는 console.log(“hi”)가 들어가 ‘hi’를 출력한 뒤 stack을 빠져 나갑니다. 다음 setTimeout()함수가 stack에 push 됩니다. 하지만 5초뒤에 작동할 함수를 위해 stack에 넣어 둘수는 없습니다. 그렇게 되면 모든 함수가 기다려야 하는 문제가 발생합니다. 즉 이런 상황에서는 stack에 넣지 않고 따로 처리를 합니다. stack을 계속 보면 console.log(“end”)가 push 되고 ‘end’를 출력합니다. 그리고 5초 뒤 다시 stack에 console.log(“i am in time-out”)가 push 되어집니다. 어떻게 동작하는 걸까요? 여기서 event loop가 등장합니다. 앞서 javascript 구조를 큰 그림으로 볼때 web APIs라는 것을 볼 수 있었습니다. setTimeout의 콜백함수는 web APIs로 보내지고 setTimeout은 stack에서 빠져나오게 됩니다. web APIs의 timer가 5초가 지난 뒤 작업이 끝나면 콜백을 다시 task queue 또는 callback queue로 보냅니다. 마침내 event loop가 stack이 비워져 있는지 확인한 뒤 stack으로 callback을 보냅니다. event loop가 하는 일은 간단합니다. queue의 첫번째 있는 작업을 stack이 비워져있는지 확인한 뒤 작업을 stack으로 보내는 역할을 합니다. 1234567console.log(&quot;1&quot;);setTimeout(function() &#123; console.log(&quot;2&quot;);&#125;,0);console.log(&quot;3&quot;); 그럼 이제 다음과 같은 코드에서 왜 1 3 2로 출력되는지도 알수 있습니다. event loop가 스택이 비워져 있는 상태인지 확인을 하기 때문에 1 3 2로 출력되는 것 입니다. 즉, stack이 비워져 있지 않은 상태라면 event loop는 queue에 있는 작업을 stack으로 보내지 않고 기다립니다. #마치며부족한 설명이었지만 이 글을 통해 javascript event loop의 대해서 조금이라도 이해하는 기회가 되었으면 좋겠습니다. 설명 도중 틀린 설명이 있다면 코멘트로 남겨주세요. 수정하겠습니다!! #참조Philip Roberts: What the heck is the event loop anyway? | JSConf EU 2014","categories":[{"name":"programming","slug":"programming","permalink":"http://DongyeolLee.github.io/categories/programming/"},{"name":"javascript","slug":"programming/javascript","permalink":"http://DongyeolLee.github.io/categories/programming/javascript/"},{"name":"etc","slug":"programming/javascript/etc","permalink":"http://DongyeolLee.github.io/categories/programming/javascript/etc/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://DongyeolLee.github.io/tags/javascript/"},{"name":"event loop","slug":"event-loop","permalink":"http://DongyeolLee.github.io/tags/event-loop/"}]}]}